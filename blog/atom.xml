<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bobo2334.github.io/blog</id>
    <title>我的学习笔记 Blog</title>
    <updated>2021-11-24T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bobo2334.github.io/blog"/>
    <subtitle>我的学习笔记 Blog</subtitle>
    <icon>https://bobo2334.github.io/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Scoop 安装和使用]]></title>
        <id>Scoop 安装和使用</id>
        <link href="https://bobo2334.github.io/blog/scoop-the-windows-package-manager"/>
        <updated>2021-11-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[引入 Scoop]]></summary>
        <content type="html"><![CDATA[<h2>引入 Scoop</h2><p>包管理器用于安装软件及其依赖，配置软件环境变量、更新软件和卸载软件。</p><p>Scoop<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 是 Windows 上的一款包管理器，用 PowerShell 实现的，它可以帮助使用者特别是开发人员管理软件环境，快速构建开发环境。常用的开发工具都可以通过 Scoop 安装、管理。</p><p>Scoop 的本质是一系列 PowerShell 脚本的集合，所以运行 Scoop 需要 PowerShell 环境。并且它是针对 Windows 系统设计的，不具有跨平台性。</p><p>Scoop 对软件的管理功能依赖于提前定义好的针对不同软件的配置文件，这些文件为 JSON 格式，称为 <strong>Manifest</strong>，由众多开发者维护，并托管在 Github。一个 Manifest 对应一个软件，其中包含了该软件的下载地址、安装/卸载脚本和其它必要信息。存放 Manifest 的仓库被称为 <strong>Bucket</strong>，对应一个 Git 仓库。Manifest 和 Bucket 是 Scoop 中的核心概念。</p><p>Scoop 对 Manifest 和 Bucket 的管理依赖于 Git。目前 Scoop 的官方 Bucket 都托管在 GitHub。</p><p>Scoop 安装软件的过程依赖于 7-zip 和其它类型的解包软件如 innounp，Scoop 会将安装包里的文件解压至软件安装目录。<code>.zip</code>、<code>.7z</code>、<code>.msi</code>和大部分的<code>.exe</code>文件都能解包，软件的安装过程都是自动的，并不是传统的可视化界面方式，不需要人工干预，都由 Scoop 自动管理，程序文件放在统一的位置。软件开发者并不需要专门为 Scoop 制作专门的安装包，通用的软件安装包都可以通过 Scoop 安装。</p><p>通过 Scoop 安装的软件大多是“绿色软件”，即不会写入注册表、不会创建桌面快捷方式，软件单独运行，不会有过多的依赖。Scoop 会根据 Manifest 中的信息为软件创建开始菜单中的快捷方式、创建命令链接、配置环境变量，通过 Scoop 安装软件不会污染系统环境。</p><h2>安装前准备</h2><p>Scoop 的安装和使用都需要访问到 Github，考虑到国内网络情况的特殊性，请你自备代理软件以确保能正常访问 GitHub。</p><p>大部分的命令行应用不会读取系统代理设置，所以有些情况下及时你启动了代理软件命令行应用也不会通过代理软件访问网络，你可能需要手动设置命令行环境的代理。</p><p>在 PowerShell 中，你可以执行以下命令来设置代理，请酌情替换其中的地址和端口。</p><pre><code class="language-powershell">$Env:http_proxy=&quot;http://127.0.0.1:11223&quot;
$Env:https_proxy=&quot;http://127.0.0.1:11223&quot;
</code></pre><p>该命令只在当前会话生效，当你关闭了 PowerShell 再次打开一个新的会话时则你需要再次执行该命令才能让代理设置生效。</p><p>你可以将这些命令写入<code>$PROFILE</code>文件来避免重复执行命令。PowerShell 在每次会话启动之后都会执行一次<code>$PROFILE</code>配置文件中的命令。</p><p>以下命令用于创建并用记事本打开<code>$PROFILE</code>文件。</p><pre><code class="language-powershell">if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }
notepad $PROFILE
</code></pre><p>在打开的记事本中写入设置代理的命令，保存该文件，并重新打开 PowerShell 即可生效。</p><pre><code class="language-powershell">$Env:http_proxy=&quot;http://127.0.0.1:11223&quot;
$Env:https_proxy=&quot;http://127.0.0.1:11223&quot;
</code></pre><h2>前提</h2><p>Scoop 依赖以下系统环境才能正常工作。</p><ol><li>PowerShell 5+</li><li>.NET Framework 4.5+</li></ol><p>对于现代的 Windows 10 系统来说，这些条件已自动满足，对于较为古老的 Windows 7 系统用户来说，你可能需要手动升级 PowerShell 到<code>PowerShell 5</code>，并安装<code>.NET Framework 4.5</code>。</p><p>Scoop 依赖 Git 和 7-zip 来完成基本的工作，但是你不需要手动安装这些软件。你只需要确保良好的网络环境。</p><h2>设置安装位置</h2><p>// TODO 补充此章节，还有各个步骤的截图</p><h2>安装 Scoop</h2><p>接下来的命令都在 PowerShell 中执行。</p><p>下面的命令用于允许执行外部 PowerShell 脚本。你可能看到提示信息，请输入“Y”并按下回车键。</p><pre><code class="language-powershell">Set-ExecutionPolicy RemoteSigned -scope CurrentUser
</code></pre><p>下面的命令用于安装 Scoop。</p><pre><code class="language-powershell">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&#x27;https://get.scoop.sh&#x27;)
</code></pre><p>在安装完成之后你将得到一个新的可执行命令<code>scoop</code>。下面的命令用于安装 7-zip 和 Git。</p><pre><code class="language-powershell">scoop install 7-zip git
</code></pre><p>等待命令执行完毕之后你就可以在命令行中使用<code>7z</code>和<code>git</code>命令，Scoop 已经为你配置好了环境变量和命令链接。</p><p>在安装好 Git 之后你需要为 Git 设置代理，以下命令用来为 Git 设置代理，请酌情替换其中的地址和端口。</p><pre><code class="language-bash">git config --global http.proxy http://127.0.0.1:11223
git config --global https.proxy https://127.0.0.1:11223
</code></pre><p>对 Git 的设置是永久性的，以下命令用于取消为 Git 设置代理，使用时请去掉注释前缀。</p><pre><code class="language-bash"># git config --global --unset http.proxy
# git config --global --unset https.proxy
</code></pre><p>下面的命令用于添加<code>extras</code>软件仓库。</p><pre><code class="language-powershell">scoop bucket add extras
</code></pre><h2>Scoop 的目录结构</h2><p>// TODO 补充此章节，还有各个步骤的截图</p><h2>Scoop 软件管理命令</h2><table><thead><tr><th>命令</th><th>示例</th><th>备注</th></tr></thead><tbody><tr><td><code>scoop search &lt;关键词&gt;</code></td><td><code>scoop search firefox</code></td><td>搜索和关键词相关的软件包</td></tr><tr><td><code>scoop info &lt;包名&gt;</code></td><td><code>scoop info firefox</code></td><td>查看软件包信息</td></tr><tr><td><code>scoop install &lt;包名&gt;</code></td><td><code>scoop install nodejs-lts adopt8-hotspot</code></td><td>安装指定软件，可以一次性安装多个软件，用空格分割这些软件名</td></tr><tr><td><code>scoop uninstall &lt;包名&gt;</code></td><td><code>scoop uninstall nodejs-lts</code></td><td>卸载指定软件</td></tr><tr><td><code>scoop reinstall &lt;包名&gt;</code></td><td><code>scoop reinstall nodejs-lts</code></td><td>重新安装指定软件</td></tr><tr><td><code>scoop reset &lt;包名&gt;</code></td><td><code>scoop reset python</code></td><td>重新执行软件安装后脚本，以解决冲突</td></tr><tr><td><code>scoop list</code></td><td></td><td>列出所有已安装软件</td></tr><tr><td><code>scoop list &lt;关键词&gt;</code></td><td><code>scoop list node</code></td><td>列出和关键词相关的已安装软件</td></tr><tr><td><code>scoop status</code></td><td></td><td>查询更新信息</td></tr><tr><td><code>scoop update &lt;包名&gt;</code></td><td><code>scoop update vscode</code></td><td>更新指定的软件</td></tr><tr><td><code>scoop update</code></td><td></td><td>更新 Scoop 和所有仓库信息</td></tr></tbody></table><h2>Scoop 仓库管理命令</h2><p>仓库相关命令均以<code>scoop bucket</code>开始。</p><table><thead><tr><th>命令</th><th>示例</th><th>备注</th></tr></thead><tbody><tr><td><code>scoop bucket known</code></td><td></td><td>列出知名软件仓库</td></tr><tr><td><code>scoop bucket add &lt;知名仓库名&gt;</code></td><td><code>scoop bucket add jetbrains</code></td><td>添加知名软件仓库，不用输入仓库地址</td></tr><tr><td><code>scoop bucket add &lt;别名&gt; &lt;仓库地址&gt;</code></td><td><code>scoop bucket add bobo2334 https://github.com/bobo2334/scoop-bucket.git</code></td><td>添加第三方软件仓库</td></tr><tr><td><code>scoop bucket rm &lt;别名&gt;</code></td><td><code>scoop bucket rm nerd-fonts</code></td><td>移除软件仓库</td></tr><tr><td><code>scoop bucket list</code></td><td></td><td>列出所有已添加的软件仓库</td></tr></tbody></table><h2>卸载 Scoop</h2><p>如果 Scoop 不能让你满意的话，你可以用下面的命令来移除 Scoop。这将会删除所有你用 Scoop 安装的软件，最后删除 Scoop 它自身。</p><pre><code class="language-powershell">scoop uninstall scoop
</code></pre><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://scoop.sh/">Scoop</a><a href="#fnref-1" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端]]></title>
        <id>Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端</id>
        <link href="https://bobo2334.github.io/blog/use-pwsh-and-oh-my-posh3-on-windows"/>
        <updated>2021-11-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>在 macOS 中用 zsh 配合 oh-my-zsh 可以打造出一个用的很舒服的终端，其实在 Windows 中也可以。</p><p>在 Windows 中可以用 pwsh<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 和 oh-my-posh<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 打造出一个好用的终端。</p><p>Windows 自带的 PowerShell 版本低，所以需要额外安装一个新版本的 pwsh，而不是用系统提供的。</p><p>oh-my-posh3 现在已基于 Go 语言重构，是一个跨平台的命令行工具，安装和配置方式和 oh-my-posh2 相比有些变化。</p><p>终端软件用的是 Windows Terminal<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup>，这是一个现代化的、可自定义的好看的终端模拟器。</p><p>历史命令提示是通过 PowerShell 的 PSReadLine<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup> 模组实现的。</p><h2>前置条件</h2><p>Scoop<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup> 是 Windows 上的一款基于 PowerShell 的包管理器，接下来的软件都是用 Scoop 安装的，因为它能很方便地管理软件和配置环境变量。Scoop 的安装及使用不在本文的讨论范围内。</p><p>由于多数软件来源于 Github，在网络不好的情况下可能会安装失败，请自行寻找代理软件。</p><p>以下命令用于在 PowerShell 中配置代理，请自行替换地址和端口号。</p><pre><code class="language-powershell">$Env:http_proxy=&quot;http://127.0.0.1:11223&quot;;$Env:https_proxy=&quot;http://127.0.0.1:11223&quot;
</code></pre><p>Scoop 基于 Git，为了让 Scoop 能正常工作，请参考以下命令用于配置 Git 的代理。</p><pre><code class="language-bash">git config --global http.proxy http://127.0.0.1:11223
git config --global https.proxy https://127.0.0.1:11223
</code></pre><h2>安装 pwsh</h2><pre><code class="language-powershell">scoop install pwsh
</code></pre><h2>安装 Windows Terminal</h2><pre><code class="language-powershell">scoop install windows-terminal
</code></pre><h2>安装 Cascadia Code 字体</h2><p>部分命令行字符需要正确配置字体才能正常显示，安装字体需要管理员权限，注意授权提示。</p><p>更多命令行字符字体可参考 nerd-fonts<sup id="fnref-6"><a href="#fn-6" class="footnote-ref">6</a></sup> 项目。</p><pre><code class="language-powershell">scoop install sudo
scoop bucket add nerd-fonts
sudo scoop install CascadiaCode-NF-Mono
</code></pre><h2>在 Windows Terminal 中集成 pwsh</h2><p>在 Window Terminal 中添加一个新的终端配置。命名为“PWSH”，命令为<code>pwsh</code>。设置字体为“CaskaydiaCove NF”。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184401253.png" alt="image-20211124184401253"/></p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184424643.png" alt="image-20211124184424643"/></p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184447256.png" alt="image-20211124184447256"/></p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184503221.png" alt="image-20211124184503221"/></p><p>保存此配置，在“启动”选项卡中把刚刚新增的“PWSH”配置文件设置为默认配置文件。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184748158.png" alt="image-20211124184748158"/></p><p>打开 PWSH，配置完成。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184925333.png" alt="image-20211124184925333"/></p><h2>安装 oh-my-posh3</h2><p>在 oh-my-posh 的官方文档中使用的安装命令为<code>scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json</code>，请不要使用该命令。</p><p>oh-my-posh3 已存在于 Scoop 的 main 仓库中，请安装此软件包，后面的配置跟包名有关。</p><pre><code class="language-powershell">scoop install oh-my-posh3
</code></pre><p>接下来编写 PWSH 的用户配置，以下命令用于创建一个配置文件并用记事本打开。该配置文件的作用是在每次 pwsh 初始化的时候自动执行其中的命令。</p><pre><code class="language-powershell">if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }
notepad $PROFILE
</code></pre><p>在弹出的记事本里写入 oh-my-posh 的初始化命令，该命令会在每次 pwsh 初始化的时候执行。</p><pre><code class="language-powershell">$env:POSH_GIT_ENABLED = $true
oh-my-posh --init --shell pwsh --config &quot;$(scoop prefix oh-my-posh3)\themes\wopian.omp.json&quot; | Invoke-Expression
</code></pre><p>重新打开终端就能看到一个带主题的 PowerShell，如果有些字符显示不出来就是字体没有配置好。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124185954914.png" alt="image-20211124185954914"/></p><h2>配置历史命令提示</h2><p>在 PWSH 中执行命令，安装 PSReadLine 模组。在安装时请输入“Y”来确认安装。以下命令用于安装 PSReadLine，请在 PWSH 中执行而不是在 PowerShell 中。</p><pre><code class="language-powershell">Install-Module PSReadLine
</code></pre><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124194613000.png" alt="image-20211124194613000"/></p><p>然后编辑<code>$PROFILE</code>文件，在每次终端打开的时候对<code>PSReadLine</code>进行初始化。</p><pre><code class="language-powershell">notepad $PROFILE
</code></pre><p>在配置文件中附加上以下内容。</p><pre><code class="language-powershell">Set-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录
Set-PSReadlineKeyHandler -Key Tab -Function Complete # 设置 Tab 键补全
Set-PSReadLineKeyHandler -Key &quot;Ctrl+d&quot; -Function MenuComplete # 设置 Ctrl+d 为菜单补全和 Intellisense
Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo # 设置 Ctrl+z 为撤销
Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向上键为后向搜索历史记录
Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward # 设置向下键为前向搜索历史纪录
</code></pre><p>保存配置文件，重启终端，就能看到一个带历史命令提示的终端了。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124190601792.png" alt="image-20211124190601792"/></p><h2>更改 oh-my-posh 的主题</h2><p>oh-my-posh 提供了多套主题可供选择，在 PWSH 中执行以下命令对所有主题进行预览。</p><pre><code class="language-powershell">Get-ChildItem -Path &quot;$(scoop prefix oh-my-posh3)\themes\*&quot; -Include &#x27;*.omp.json&#x27; | Sort-Object Name | ForEach-Object -Process {
    $esc = [char]27
    Write-Host &quot;&quot;
    Write-Host &quot;$esc[1m$($_.BaseName)$esc[0m&quot;
    Write-Host &quot;&quot;
    oh-my-posh --config $($_.FullName) --pwd $PWD
    Write-Host &quot;&quot;
}
</code></pre><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124195044478.png" alt="image-20211124195044478"/></p><p>其中以<code>.omp</code>结尾的是主题文件的名称，如果需要使用某个主题就替换掉<code>$PROFILE</code>文件中初始化命令中的配置文件名就可以了。</p><p>以下命令用于用记事本打开<code>$PROFILE</code>文件。</p><pre><code class="language-powershell">notepad $PROFILE
</code></pre><p>在打开的记事本中你会看到 oh-my-posh 的初始化命令。</p><pre><code class="language-powershell">oh-my-posh --init --shell pwsh --config &quot;$(scoop prefix oh-my-posh3)\themes\wopian.omp.json&quot; | Invoke-Expression
</code></pre><p>将你中意的主题名称替换命令中的<code>wopian.omp</code>，保存该配置文件然后重启终端就可以看到新主题的效果了。</p><h2>更改 Windows Terminal 的配色</h2><p>在 Windows Terminal 中默认有多套配色方案可选，这里推荐一套自定义的配色方案，来自于 Dracula<sup id="fnref-7"><a href="#fn-7" class="footnote-ref">7</a></sup>。</p><p>在 Windows Terminal 的设置页面中，点击“打开 JSON 文件”，在该文件的<code>schemes</code>数组中添加一个配色方案对象。</p><pre><code class="language-json">&quot;schemes&quot;: [
    {
        &quot;name&quot;: &quot;Dracula&quot;,
        &quot;cursorColor&quot;: &quot;#F8F8F2&quot;,
        &quot;selectionBackground&quot;: &quot;#44475A&quot;,
        &quot;background&quot;: &quot;#282A36&quot;,
        &quot;foreground&quot;: &quot;#F8F8F2&quot;,
        &quot;black&quot;: &quot;#21222C&quot;,
        &quot;blue&quot;: &quot;#BD93F9&quot;,
        &quot;cyan&quot;: &quot;#8BE9FD&quot;,
        &quot;green&quot;: &quot;#50FA7B&quot;,
        &quot;purple&quot;: &quot;#FF79C6&quot;,
        &quot;red&quot;: &quot;#FF5555&quot;,
        &quot;white&quot;: &quot;#F8F8F2&quot;,
        &quot;yellow&quot;: &quot;#F1FA8C&quot;,
        &quot;brightBlack&quot;: &quot;#6272A4&quot;,
        &quot;brightBlue&quot;: &quot;#D6ACFF&quot;,
        &quot;brightCyan&quot;: &quot;#A4FFFF&quot;,
        &quot;brightGreen&quot;: &quot;#69FF94&quot;,
        &quot;brightPurple&quot;: &quot;#FF92DF&quot;,
        &quot;brightRed&quot;: &quot;#FF6E6E&quot;,
        &quot;brightWhite&quot;: &quot;#FFFFFF&quot;,
        &quot;brightYellow&quot;: &quot;#FFFFA5&quot;
    }
]
</code></pre><p>保存该 JSON 文件，重启 Windows Terminal，在 PWSH 的外观配置中选择新添加的 Dracula 配色方案。前文中我用的配色方案就是 Dracula。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124202122113.png" alt="image-20211124202122113"/></p><h2>在 VS Code 里使用</h2><p>在 VS Code 的配置文件<code>settings.json</code>中加入以下配置。</p><pre><code class="language-json">&quot;terminal.integrated.profiles.windows&quot;: {
  &quot;Windows PowerShell&quot;: {
    &quot;path&quot;: &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot;
  },
  &quot;PWSH&quot;: {
    &quot;path&quot;: &quot;pwsh&quot;
  }
},
&quot;terminal.integrated.defaultProfile.windows&quot;: &quot;PWSH&quot;,
&quot;terminal.integrated.fontFamily&quot;: &quot;&#x27;CaskaydiaCove NF&#x27;&quot;
</code></pre><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://github.com/PowerShell/PowerShell">PowerShell/PowerShell: PowerShell for every system!</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://ohmyposh.dev/">Home | Oh My Posh</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://github.com/microsoft/terminal">microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place!</a><a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-4"><a href="https://github.com/PowerShell/PSReadLine">PowerShell/PSReadLine: A bash inspired readline implementation for PowerShell</a><a href="#fnref-4" class="footnote-backref">↩</a></li><li id="fn-5"><a href="https://scoop.sh/">Scoop</a><a href="#fnref-5" class="footnote-backref">↩</a></li><li id="fn-6"><a href="https://www.nerdfonts.com/">Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher</a><a href="#fnref-6" class="footnote-backref">↩</a></li><li id="fn-7"><a href="https://draculatheme.com/windows-terminal">Dark theme for Windows Terminal and 218+ apps — Dracula</a><a href="#fnref-7" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以容器的方式暴露 Docker Remote API 并启用 TLS]]></title>
        <id>以容器的方式暴露 Docker Remote API 并启用 TLS</id>
        <link href="https://bobo2334.github.io/blog/enable-docker-remote-api-with-tls-protection-via-container"/>
        <updated>2021-09-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>之前在“开启 Docker Remote API 并启用 TLS”<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 中记录过 Docker 暴露 Remote API 并配置 TLS 支持，虽然其中引用了别人的脚本来简化证书的签发步骤，但是在证书签发完成之后还是需要对 Docker 的启动命令进行修改，还是一个比较繁琐的步骤。</p><p>后来我发现了 docker-remote-api-tls<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 项目，它提供了一个镜像，在运行镜像之后它会自动完成证书签发和 API 转发步骤。</p><h2>部署</h2><p>可以通过 Docker Compose 方便地启动这个容器，下面是<code>docker-compose.yml</code>文件的内容。</p><pre><code class="language-yaml">version: &quot;3&quot;
services:
  api:
    image: kekru/docker-remote-api-tls:v0.3.0
    ports:
      - 2376:443
    environment:
      - CREATE_CERTS_WITH_PW=dockercompose
      - CERT_EXPIRATION_DAYS=3650
      - CA_EXPIRATION_DAYS=36500
      - CERT_HOSTNAME=192.168.229.129.nip.io
    volumes:
      - /root/compose/docker-remote-api-with-tls/certs:/data/certs
      - /var/run/docker.sock:/var/run/docker.sock:ro
    restart: unless-stopped
</code></pre><p>有以下几点需要注意：</p><ol><li>第 6 行，容器内的端口是 443，需要映射到容器外 2376 端口；</li><li>第 8 行，<code>CREATE_CERTS_WITH_PW</code>设置证书密码；</li><li>第 9 行，<code>CERT_EXPIRATION_DAYS</code>设置证书过期时间，默认 365 天；</li><li>第 10 行，<code>CA_EXPIRATION_DAYS</code>设置 CA 证书过期时间，默认 900 天；</li><li>第 11 行，<code>CERT_HOSTNAME</code>设置域名，如果没有域名可以用 nip.io<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup> 来得到一个可以解析到任意 IP 的域名。形如<code>192.168.229.129.nip.io</code>的域名会被解析至<code>192.168.229.129</code>；还有其他形式的域名可以在 nip.io 网站中查看；</li><li>第 13 行，挂载证书目录，首次启动时证书会被自动创建并存放在此目录中；</li><li>第 14 行，挂载<code>docker.sock</code>。</li></ol><p>通过<code>docker compose up -d</code>启动容器。根据配置，证书会被自动创建在<code>/root/compose/docker-remote-api-with-tls/certs</code>目录中。</p><p>该目录的结构如下：</p><pre><code>certs/
├── ca-cert.pem
├── ca-key.pem
├── client
│   ├── ca.pem
│   ├── cert.pem
│   └── key.pem
├── server-cert.pem
└── server-key.pem
</code></pre><p>其中，客户端需要的证书文件存放在<code>client</code>目录中。此时 Docker Remote API 已经暴露在 2376 端口，客户端可以使用证书文件来通过认证。</p><p>如果需要重新签发证书文件，只需要清空<code>certs</code>文件夹即可。</p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="./enable-docker-remote-api-with-tls-protection.md">开启 Docker Remote API 并启用 TLS</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://github.com/kekru/docker-remote-api-tls">kekru/docker-remote-api-tls: Docker Image that forwards to the Docker API Socket and requires TLS Client authentication</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://nip.io/">nip.io - wildcard DNS for any IP Address</a><a href="#fnref-3" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开启 Docker Remote API 并启用 TLS]]></title>
        <id>开启 Docker Remote API 并启用 TLS</id>
        <link href="https://bobo2334.github.io/blog/enable-docker-remote-api-with-tls-protection"/>
        <updated>2021-09-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>Portainer<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 是一款 Docker 可视化管理面板，它不仅可以管理本地的 Docker 实例，还可以通过 Docker Remote API 访问管理远程 Docker 资源。Docker Remote API 就是通过 HTTP 协议暴露 Docker 资源，启用 TLS 可以实现远程访问鉴权。</p><p>Docker 的官方文档提供了详细的开启 Docker Remote API 和开启 TLS 的教程 <sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>。但是在签发证书的过程中涉及到的命令比较多，且繁琐，我就从网络上寻找到了别人写好的签发证书的脚本 <sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup>，可以很方便地替代纯手工操作。</p><p>本文中的操作都在 CentOS 7 中完成。</p><h2>签发证书</h2><p>将脚本命名为<code>auto-tls-certs.sh</code>。其中需要配置的内容有：</p><ol><li><code>CODE</code>，作为文件名的后缀，用于区分文件；</li><li><code>IP</code>，机器的公网 IP 地址；</li><li><code>PASSWORD</code>，证书密码。</li></ol><p>脚本内容如下：</p><pre><code class="language-bash">#!/bin/bash
#
# -------------------------------------------------------------
# 自动创建 Docker TLS 证书
# -------------------------------------------------------------

# 以下是配置信息
# --[BEGIN]------------------------------

CODE=&quot;tx&quot;
IP=&quot;1.1.1.1&quot;
PASSWORD=&quot;pass&quot;

COUNTRY=&quot;CN&quot;
STATE=&quot;BEIJING&quot;
CITY=&quot;BEIJING&quot;
ORGANIZATION=&quot;Org&quot;
ORGANIZATIONAL_UNIT=&quot;Dev&quot;
COMMON_NAME=&quot;$IP&quot;
EMAIL=&quot;.&quot;

# --[END]--

# Generate CA key
openssl genrsa -aes256 -passout &quot;pass:$PASSWORD&quot; -out &quot;ca-key-$CODE.pem&quot; 4096
# Generate CA
openssl req -new -x509 -days 365 -key &quot;ca-key-$CODE.pem&quot; -sha256 -out &quot;ca-$CODE.pem&quot; -passin &quot;pass:$PASSWORD&quot; -subj &quot;/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$COMMON_NAME/emailAddress=$EMAIL&quot;
# Generate Server key
openssl genrsa -out &quot;server-key-$CODE.pem&quot; 4096

# Generate Server Certs.
openssl req -subj &quot;/CN=$COMMON_NAME&quot; -sha256 -new -key &quot;server-key-$CODE.pem&quot; -out server.csr

echo &quot;subjectAltName = IP:$IP,IP:127.0.0.1&quot; &gt;&gt; extfile.cnf
echo &quot;extendedKeyUsage = serverAuth&quot; &gt;&gt; extfile.cnf

openssl x509 -req -days 365 -sha256 -in server.csr -passin &quot;pass:$PASSWORD&quot; -CA &quot;ca-$CODE.pem&quot; -CAkey &quot;ca-key-$CODE.pem&quot; -CAcreateserial -out &quot;server-cert-$CODE.pem&quot; -extfile extfile.cnf

# Generate Client Certs.
rm -f extfile.cnf

openssl genrsa -out &quot;key-$CODE.pem&quot; 4096
openssl req -subj &#x27;/CN=client&#x27; -new -key &quot;key-$CODE.pem&quot; -out client.csr
echo extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf
openssl x509 -req -days 365 -sha256 -in client.csr -passin &quot;pass:$PASSWORD&quot; -CA &quot;ca-$CODE.pem&quot; -CAkey &quot;ca-key-$CODE.pem&quot; -CAcreateserial -out &quot;cert-$CODE.pem&quot; -extfile extfile.cnf

rm -vf client.csr server.csr

chmod -v 0400 &quot;ca-key-$CODE.pem&quot; &quot;key-$CODE.pem&quot; &quot;server-key-$CODE.pem&quot;
chmod -v 0444 &quot;ca-$CODE.pem&quot; &quot;server-cert-$CODE.pem&quot; &quot;cert-$CODE.pem&quot;

# 打包客户端证书
mkdir -p &quot;tls-client-certs-$CODE&quot;
cp -f &quot;ca-$CODE.pem&quot; &quot;cert-$CODE.pem&quot; &quot;key-$CODE.pem&quot; &quot;tls-client-certs-$CODE/&quot;
cd &quot;tls-client-certs-$CODE&quot;
tar zcf &quot;tls-client-certs-$CODE.tar.gz&quot; *
mv &quot;tls-client-certs-$CODE.tar.gz&quot; ../
cd ..
rm -rf &quot;tls-client-certs-$CODE&quot;

# 拷贝服务端证书
mkdir -p /etc/docker/certs.d
cp &quot;ca-$CODE.pem&quot; &quot;server-cert-$CODE.pem&quot; &quot;server-key-$CODE.pem&quot; /etc/docker/certs.d/
</code></pre><p>使用<code>sh auto-tls-certs.sh</code>命令来生成证书，并且生成好的证书会被自动打包为<code>.tar.gz</code>归档，非常方便。下面的图片展示了执行脚本后生成的文件列表。</p><p><img src="./enable-docker-remote-api-with-tls-protection.assets/image-20210816222131111-16291236956091.png" alt="image-20210816222131111-16291236956091"/></p><h2>配置 Docker</h2><p>只需关注<code>.pem</code>文件，把证书找个专门的位置存放。</p><pre><code class="language-bash">mkdir /etc/.docker
cp ~/docker-cert/*.pem /etc/.docker/
</code></pre><p>修改 Docker 启动文件。</p><pre><code class="language-bash">nano /lib/systemd/system/docker.service
</code></pre><p>修改<code>Service</code>下的<code>ExecStart</code>配置。</p><pre><code class="language-conf">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -D -H tcp://0.0.0.0:2376 --tlsverify --tlscacert=/etc/.docker/ca-tx.pem --tlscert=/etc/.docker/server-cert-tx.pem --tlskey=/etc/.docker/server-key-tx.pem
</code></pre><p><img src="./enable-docker-remote-api-with-tls-protection.assets/image-20210816222434122-16291238760702.png" alt="image-20210816222434122-16291238760702"/></p><p>重启 Docker。</p><pre><code class="language-bash">systemctl daemon-reloadservice docker restart
</code></pre><h2>开放端口</h2><p>在防火墙、安全组中放行 2376 端口。</p><h2>测试</h2><p>把证书的压缩包<code>tls-client-certs-tx.tar.gz</code>下载到本机，解压得到证书文件。</p><p><img src="./enable-docker-remote-api-with-tls-protection.assets/image-20210816222527037.png" alt="image-20210816222527037"/></p><p>用<code>curl</code>命令测试，如果有 JSON 格式的信息输出则配置成功。</p><pre><code class="language-bash">curl https://你的 IP/info --cert cert-tx.pem --key key-tx.pem --cacert ca-tx.pem
</code></pre><p><img src="./enable-docker-remote-api-with-tls-protection.assets/image-20210816222600935-16291239626163.png" alt="image-20210816222600935-16291239626163"/></p><h2>用 Portainer 连接</h2><p>Portainer 是一款非常好用的 Docker 可视化管理工具，通过暴露 Docker Remote API 可以远程连接并管理 Docker 资源。</p><p>在<code>Endpoints</code>页面中点击<code>Add endpoint</code>，<code>Environment type</code>选择<code>Docker</code>。</p><p>在对应的输入框中填写 IP 地址和端口号，开启 TLS，选择三个对应的证书文件。</p><p><img src="./enable-docker-remote-api-with-tls-protection.assets/image-20210816222733033-16291240547284.png" alt="image-20210816222733033-16291240547284"/></p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://documentation.portainer.io/">Documentation</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://docs.docker.com/engine/security/protect-access/">Protect the Docker daemon socket | Docker Documentation</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://www.gaoyaxuan.net/blog/324.html">Docker 开启 TLS 访问，更加安全 - 实用教程 - 高亚轩的 BLOG</a><a href="#fnref-3" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSH 密钥登录]]></title>
        <id>SSH 密钥登录</id>
        <link href="https://bobo2334.github.io/blog/ssh-certificate-authentication"/>
        <updated>2021-09-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><blockquote><p>SSH 默认采用密码登录，这种方法有很多缺点，简单的密码不安全，复杂的密码不容易记忆，每次手动输入也很麻烦。密钥登录是比密码登录更好的解决方案。<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup></p></blockquote><h2>生成秘钥</h2><p>可以用 OpenSSH 中的<code>ssh-keygen</code>命令行工具来生成秘钥。<code>-t</code>参数指定了加密方式，通常为<code>ras</code>或<code>dsa</code>。</p><pre><code class="language-bash">ssh-keygen -t rsa
</code></pre><p>生成的密钥文件默认就会是<code>~/.ssh/id_rsa</code>（私钥）和<code>~/.ssh/id_rsa.pub</code>（公钥）。</p><p>也可以用 PuTTY 中提供的 PuTTY Key Generator（puttygen.exe）<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 来用可视化用户界面来生成秘钥文件。</p><p><img src="./ssh-certificate-authentication.assets/image-20210816230720070.png" alt="image-20210816230720070"/></p><h2>把公钥放在服务器上</h2><p>用户公钥保存在<code>~/.ssh/authorized_keys</code>文件中，如果该文件不存在，你可以手动创建一个。</p><p>然后将公钥的文本内容放入其中，每行一个。</p><h2>关闭密码登录</h2><p>编辑<code>/etc/ssh/sshd_config</code>文件，找到对应的配置项并修改。</p><pre><code class="language-conf"># 不允许密码直接登录
PasswordAuthentication no
# 不允许空密码登录
PermitEmptyPasswords
# 不允许交互式密码登录
ChallengeResponseAuthentication no
# 不允许 root 用户使用密码登录
PermitRootLogin prohibit-password
# 使用秘钥登录
PubkeyAuthentication yes
</code></pre><p>重启<code>sshd</code>，让配置生效。</p><pre><code class="language-bash">sudo systemctl restart sshd
</code></pre><h2>测试配置是否生效</h2><p>使用<code>ssh</code>命令连接远程服务器，使用<code>-i</code>参数传递私钥文件。</p><pre><code class="language-bash">ssh -i .\centos7\.vagrant\machines\default\virtualbox\private_key vagrant@192.168.33.12
</code></pre><h2>参考资料</h2><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server">How To Configure SSH Key-Based Authentication on a Linux Server | DigitalOcean</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-using_openssh_certificate_authentication">14.3. Using OpenSSH Certificate Authentication Red Hat Enterprise Linux 6 | Red Hat Customer Portal</a></li></ul><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://wangdoc.com/ssh/key.html">SSH 密钥登录 - SSH 教程 - 网道</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">Download PuTTY: latest release (0.76)</a><a href="#fnref-2" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用 Github Actions 部署 Vuepress 项目到 Github Pages]]></title>
        <id>利用 Github Actions 部署 Vuepress 项目到 Github Pages</id>
        <link href="https://bobo2334.github.io/blog/deploy-vuepress-project-to-github-pages-with-github-actions"/>
        <updated>2021-08-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>Vuepress<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 是一个基于 Vue 的静态网站生成器；Github Pages<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 是 Github 提供的免费的静态网站托管服务；Github Actions<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup> 是 Github 仓库中集成的 CI/CD<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup> 服务。</p><p>Vuepress 是一个 Node.js 项目，它可以根据配置将 Markdown 文件转为 HTML 文件。你可以将输出的静态文件托管在 Github Pages 中，这样你就得到了一个可以访问的域名来展示这些静态的 HTML 文件。</p><p>传统的做法是在本地安装好 Noed.js 环境，自己手动构建项目之后将构建产物上传到 Github 仓库，从而触发 Github Pages 的构建。现在可以利用 Github Actions 来代替手工劳动，Github Actions 可以自动被触发，它运行在 Github 提供的虚拟环境中，可以执行一系列任务从而代替重复枯燥的手动构建和部署的步骤。</p><h2>创建 Github 仓库</h2><p>在创建的 Github 仓库时要注意仓库名称，假如你的用户名是 foo。</p><p>如果你创建了一个名为<code>foo.github.io</code>的仓库，你将可以通过<code>https://foo.github.io</code>来访问此仓库的 Github Pages 内容；</p><p>如果你创建其他名称的仓库如<code>bar</code>，你可以通过<code>https://foo.github.io/bar/</code>来访问此仓库的 Github Pages 内容。</p><p>你可以根据你期望的访问方式来选择仓库名称。</p><h2>配置 Github Actions</h2><p>Github Actions 的配置文件应该放在项目根目录下的<code>.github/workflows/</code>文件夹中，你可以在一个项目中配置多个 Actions。配置文件是 YAML 格式，文件名形如<code>*.yml</code>。</p><p>每一个 Action 中可以包括多个 job，每个 job 可以包括多个 step。在 step 中你可以直接运行命令，或者引用其他人编写好的 Action 脚本。在本文的配置文件中，我们引用了 github-pages-deploy-action<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup> 来完成 Github Pages 部署，而不用关系其实现细节。</p><p>完成本文目标的 Github Actions 配置文件内容如下。</p><pre><code class="language-yaml">name: &quot;github actions build and deploy gh-pages&quot;
on:
  push:
    branches:
      - master
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2.3.1
        with:
          persist-credentials: false
      - name: install and build
        run: |
          npm install
          npm run build
      - name: Deploy
        uses: JamesIves/github-pages-deploy-action@4.1.4
        with:
          BRANCH: gh-pages
          FOLDER: docs/.vuepress/dist
</code></pre><p>其中的一些关键配置解释如下。</p><ul><li><code>on.push.branches</code>，在推送到<code>master</code>分支时触发此 Action；</li><li><code>jobs.build-and-deploy</code>，在一个 Action 中可以有多个 job，这是其中的一个，名称是自己取的；每个任务可以有多个 step；</li><li><code>jobs.build-and-deploy.steps[0]</code>，用<code>actions/checkout</code>检出仓库内容；</li><li><code>jobs.build-and-deploy.steps[1]</code>，执行<code>npm</code>命令安装开发环境；</li><li><code>jobs.build-and-deploy.steps[2]</code>，用<code>JamesIves/github-pages-deploy-action</code>部署<code>docs/.vuepress/dist</code>文件夹中的内容到<code>gh-pages</code>分支中。</li></ul><p>在编写好配置文件后可以提交并推送文件至 master 分支，这会自动触发 Action 的执行，并且你可以在 Actions 栏目中查看执行日志。</p><p><img src="./deploy-vuepress-project-to-github-pages-with-github-actions.assets/image-20210824225724791.png" alt="image-20210824225724791"/></p><h2>配置 Github Pages</h2><p>我们的构建产物放在 gh-pages 分支，我们需要告诉 Github Pages 源文件位置。</p><p>在 Github 仓库的 Settings 栏目中，从左侧的设置导航栏找到 Pages 设置。在这里你可以设置 gh-pages 为数据源。</p><p><img src="./deploy-vuepress-project-to-github-pages-with-github-actions.assets/image-20210824230246146.png" alt="image-20210824230246146"/></p><p>如果没出错的话，在配置完成之后你就可以通过 Github Pages 给你提供的域名来访问你的静态网站了。</p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://v2.vuepress.vuejs.org/zh/">首页 | VuePress</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://pages.github.com/">GitHub Pages | Websites for you and your projects, hosted directly from your GitHub repository. Just edit, push, and your changes are live.</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://docs.github.com/en/actions/learn-github-actions">Learn GitHub Actions - GitHub Docs</a><a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-4"><a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd">什么是 CI/CD？一文带你理解 CI 持续集成和 CD 持续交付/部署 - 红帽</a><a href="#fnref-4" class="footnote-backref">↩</a></li><li id="fn-5"><a href="https://github.com/JamesIves/github-pages-deploy-action">JamesIves/github-pages-deploy-action: Automatically deploy your project to GitHub Pages using GitHub Actions. This action can be configured to push your production-ready code into any branch you&#x27;d like.</a><a href="#fnref-5" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Vant Weapp 自定义微信小程序 TabBar]]></title>
        <id>使用 Vant Weapp 自定义微信小程序 TabBar</id>
        <link href="https://bobo2334.github.io/blog/customize-wechat-mini-program-tabbar-with-vant-weapp"/>
        <updated>2020-12-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>微信小程序原生的 TabBar 虽然设置简单，但是样式不好看，也不能使用字体图标，但是微信小程序有自定义 TabBar 的机制。</p><p>Vant WeApp<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 是有赞出品的针对微信小程序的一套开源组件库，结合 van-tabbar<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 和微信的自定义 TabBar 机制 <sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup> 可以实现一套比较好看的 TabBar。</p><h2>新建 custom-tab-bar 组件</h2><p>如图所示，在微信小程序工程文件夹根目录下新建一个名为 <code>custom-tab-bar</code> 的组件。</p><p><img src="./customize-wechat-mini-program-tabbar-with-vant-weapp.assets/image-5.png" alt="img"/></p><p>其中各个文件中的代码如下：</p><pre><code class="language-json">{
  &quot;component&quot;: true,
  &quot;usingComponents&quot;: {
    &quot;van-tabbar&quot;: &quot;@vant/weapp/tabbar/index&quot;,
    &quot;van-tabbar-item&quot;: &quot;@vant/weapp/tabbar-item/index&quot;
  }
}
</code></pre><pre><code class="language-javascript">// custom-tab-bar/index.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {},

  /**
   * 组件的初始数据
   */
  data: {
    active: -1,
    list: [{
        icon: &quot;search&quot;,
        text: &quot;搜索&quot;,
        url: &quot;/pages/index/index&quot;,
      },
      {
        icon: &quot;question-o&quot;,
        text: &quot;答题&quot;,
        url: &quot;/pages/question/index&quot;,
      },
      {
        icon: &quot;ellipsis&quot;,
        text: &quot;关于&quot;,
        url: &quot;/pages/user/index&quot;,
      },
    ],
  },

  /**
   * 组件的方法列表
   */
  methods: {
    onChange(event) {
      wx.switchTab({
        url: this.data.list[event.detail].url,
      });
    },

    init() {
      const {
        route
      } = getCurrentPages().pop();
      const active = this.data.list.findIndex(
        (item) =&gt; item.url === `/${route}`
      );
      console.log(&quot;active:&quot;, active);
      this.setData({
        active,
      });
    },
  },
});
</code></pre><pre><code class="language-xml">&lt;!-- custom-tab-bar/index.wxml --&gt;
&lt;van-tabbar active=&quot;{{ active }}&quot; bind:change=&quot;onChange&quot;&gt;
    &lt;van-tabbar-item wx:for=&quot;{{list}}&quot; wx:key=&quot;index&quot; icon=&quot;{{item.icon}}&quot;&gt;
        {{item.text}}
    &lt;/van-tabbar-item&gt;
&lt;/van-tabbar&gt;
</code></pre><h2>启用自定义 TabBar 设置</h2><p>修改 <code>app.js</code> 中 <code>tabBar</code> 设置，设置 <code>custom</code> 为 <code>true</code>。其中 <code>list</code> 中的对象只需保留 <code>path</code> 属性。</p><p><img src="./customize-wechat-mini-program-tabbar-with-vant-weapp.assets/image-6-668x1024.png" alt="img"/></p><h2>在每个 Tab 页中配置</h2><p>在开启了自定义 TabBar 设置后，可以在每个页面中通过 <code>getTabBar()</code> 获取 TabBar 组件实例。</p><p>现在需要在每个 Tab 页中设置当前 Tab 页图标高亮。</p><p>可以在每个 Tab 页的 <code>onShow()</code> 生命周期方法中调用 TabBar 的 <code>init()</code> 方法，修改当前激活页，来高亮当前 Tab 页的图标。</p><pre><code class="language-javascript">/**
* 生命周期函数--监听页面显示
*/
onShow: function () {
  this.getTabBar().init();
},
</code></pre><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://vant-contrib.gitee.io/vant/#/zh-CN/">Vant - 轻量、可靠的移动端组件库 (gitee.io)</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://vant-contrib.gitee.io/vant-weapp/#/tabbar">Tabbar 标签栏 - Vant Weapp</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html">自定义 tabBar | 微信开放文档</a><a href="#fnref-3" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题]]></title>
        <id>解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题</id>
        <link href="https://bobo2334.github.io/blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea"/>
        <updated>2020-12-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>在用 IntelliJ IDEA 运行 Java Web 项目时，在 Tomcat 的日志输出区域会出现乱码，效果如下图所示。</p><p>在网络上查了一些资料 <sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>，记录下解决办法。</p><p><img src="./solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea.assets/image-1024x475.png" alt="Tomcat 日志出现乱码"/></p><h2>原因分析</h2><p>可能是因为 IDEA 控制台中所采用的字符编码与 Tomcat 输出所采用的字符编码不一致，导致了出现乱码。</p><p>IDEA 控制台输出采用的是 GBK 编码，Tomcat 输出采用的是 UTF-8 编码。</p><h2>解决办法</h2><h3>法一：修改 IDEA 控制台输出编码为 UTF-8</h3><p>在 IDEA 的上方工具栏中，依次选择<code>Help</code>-&gt;<code>Edit Custome VM Options...</code>。</p><p><img src="./solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea.assets/image-1.png" alt="img"/></p><p>在<code>vmoptions</code>中添加如下一行参数，之后重启 IDEA。</p><pre><code class="language-bash">-Dfile.encoding=UTF-8
</code></pre><p>该文件实际位于<code>C:\Users\&lt;用户名&gt;\AppData\Roaming\JetBrains\IntelliJIdea2020.3\idea64.exe.vmoptions</code>，所以直接修改此文件应该也可行。</p><p><img src="./solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea.assets/image-2.png" alt="img"/></p><h3>法二：修改 Tomcat 输出编码为 GBK</h3><p>在 Tomcat 安装位置下的 conf 文件中存在<code>logging.properties</code>配置文件。</p><p>修改其中的配置，将<code>java.util.logging.ConsoleHandler.encoding</code>的属性由<code>UTF-8</code>改为<code>GBK</code>。</p><p>保存之后重启 Tomcat 即可。</p><p><img src="./solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea.assets/image-4-1024x907.png" alt="img"/></p><h2>结果</h2><p>两种方法均可以解决问题。</p><p><img src="./solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea.assets/image-3-1024x491.png" alt="img"/></p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://www.cnblogs.com/shej123/p/10312806.html">idea tomcat 乱码问题的解决及相关设置 - 行而思 - 博客园</a><a href="#fnref-1" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用 Windows Terminal 和 oh-my-posh 打造一个好用的终端]]></title>
        <id>用 Windows Terminal 和 oh-my-posh 打造一个好用的终端</id>
        <link href="https://bobo2334.github.io/blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh"/>
        <updated>2020-02-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[2021-11-14 备注]]></summary>
        <content type="html"><![CDATA[<blockquote><p>2021-11-14 备注</p><p>oh-my-posh 项目已被重构，现在由 Go 语言实现，详情见 <a href="https://github.com/JanDeDobbeleer/oh-my-posh">Github</a>。</p><p>文章中所使用的版本现已被重命名为 oh-my-posh2，由 PowerShell 实现，详情见 <a href="https://github.com/JanDeDobbeleer/oh-my-posh2">Github</a>。</p></blockquote><blockquote><p>2021-11-24 备注</p><p>oh-my-posh3 的安装请参考 <a href="use-pwsh-and-oh-my-posh3-on-windows.md">Windows Terminal + PWSH + oh my posh3 + PSReadLine 打造一个好用的终端</a>，下面的内容已过时。</p></blockquote><h2>前言</h2><p>Windows 中自带的终端使用体验确实说不上好，尝试了许多组合也感觉都不顺手。这次试试微软亲自出的 Windows Terminal<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>，再加上 oh-my-posh<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 插件。</p><h2>正文</h2><h3>安装 Windows Terminal</h3><p>Windows Terminal 提供多种安装方式，你可以在 Microsoft Store 中安装；可以自行在该项目的 Github 仓库 <sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 中上下载安装程序；虽然官方文档未提及，但是你也可以用 Scoop<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup> 安装：</p><pre><code class="language-powershell">scoop install windows-terminal
</code></pre><h3>安装 oh-my-posh</h3><p>oh-my-posh 是针对 Windows PowerShell 设计的主题引擎，类似于 zsh 和 Oh My Zsh 的关系。它可以让你的命令行更强大。</p><p>打开 PowerShell，输入以下命令安装：</p><pre><code class="language-powershell">Install-Module posh-git -Scope CurrentUser
Install-Module oh-my-posh -Scope CurrentUser
</code></pre><p>安装完成之后还更改 PowerShell 的用户配置，让它每次启动的时候自动加载 oh-my-posh 插件；执行以下命令：</p><pre><code class="language-powershell">if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }
notepad $PROFILE
</code></pre><p>不出意外的话接下来会出现记事本，你需要在里面写上以下内容：</p><pre><code class="language-powershell">Import-Module posh-git
Import-Module oh-my-posh
Set-Theme Paradox
</code></pre><p>保存该文件，重新打开 PowerShell 你就能看到一个发生改变了的 PowerShell 。</p><p><img src="./build-a-decent-terminal-with-windows-terminal-and-oh-my-posh.assets/vMcBOyiREC-1024x523.png" alt="img"/></p><p>oh-my-posh 提供了几组预设的主题供你选择，你可以通过 <code>Set-Theme</code> 命令来更改当前主题，可选的值有 <code>Agnoster</code>/<code>Paradox</code>/<code>Sorin</code>/<code>Darkblood</code>/<code>Avit</code>/<code>Honukai</code>/<code>Fish</code>/<code>Robbyrussell</code>。</p><p><img src="./build-a-decent-terminal-with-windows-terminal-and-oh-my-posh.assets/sA8iXJPC2j.png" alt="img"/></p><p>这个主题设置只在当前会话生效，为了每次启动 PowerShell 的时候都能加载你想要的主题，你还需要修改以下用户配置文件，就像上一个步骤中做的一样，只需要修改 <code>Set-Theme</code> 命令的部分即可。</p><h3>用上微软的 Cascadia Code 字体</h3><p>或许你已经发现了有些字符显示不正常，那是因为默认的字体没有内嵌这些字符的形状，你还需要换一个字体。</p><p>微软的另一个开源项目，Cascadia Code<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup> 就是一款适用于终端和代码展示的字体，你可以使用 Scoop 来安装它；安装字体的时候需要使用到管理员权限，你可以使用 <code>sudo</code> 命令，或者用管理员权限重新打开 PowerShell，再执行安装。</p><p>在安装之前，你可能需要添加一下 <code>nerd-fonts</code> 仓库，因为字体软件的元信息都存放于这个仓库中。</p><pre><code class="language-powershell">scoop bucket add nerd-fonts
</code></pre><p>在 Scoop 的仓库中存在着好几个版本的 Cascadia Code，其中：</p><ul><li><code>Cascadia-Code</code>是原版不带 Powerline 字符的；</li><li><code>Cascadia-PL</code>是微软出品的，自带 Powerline 字符的；</li><li><code>CascadiaCode-NF</code>是 Nerd Fonts<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup> 项目出品的，后期补丁了大量 Powerline 字符。</li></ul><p>没有特殊需求的话可以选择官方出的轻量级的 <code>Cascadia-PL</code>，执行以下命令：</p><pre><code class="language-powershell">sudo scoop install Cascadia-PL
</code></pre><p>安装完成之后还需设置以下，指定 Windows Terminal 使用该字体。</p><p>目前 Windows Terminal 没有专门的设置界面，所有的配置项都在 <code>profiles.json</code> 配置文件里；在配置文件的对应地方设置 <code>fontFace</code> 的值为 <code>Cascadia Code PL</code>：</p><pre><code class="language-json">// ...
&quot;defaults&quot;:
{
    // Put settings here that you want to apply to all profiles
    &quot;fontFace&quot;: &quot;Cascadia Code PL&quot;
},
// ...
</code></pre><p>保存配置文件后就能使配置文件生效；此时所有字符应该能正常显示了。</p><p><img src="./build-a-decent-terminal-with-windows-terminal-and-oh-my-posh.assets/vjPXgPO7AB-1024x523.png" alt="img"/></p><h3>集成 Git Bash</h3><p>首先将 Git 安装目录下的 <code>bin</code> 目录加入 <code>Path</code> 环境变量，如果你是用 Scoop 安装的 Git，则可以忽略此步骤，因为 Scoop 已经帮你完成了这个工作；然后修改 Windows Terminal 的配置文件，在 <code>profiles</code>-&gt;<code>list</code> 中新增一条配置：</p><pre><code class="language-json">// ...
&quot;list&quot;:
[

    {
        &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff4411}&quot;,
        &quot;name&quot;: &quot;Git Bash&quot;,
        &quot;commandline&quot;: &quot;bash.exe&quot;,
        &quot;hidden&quot;: false,
        &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot;
    }
]
// ...
</code></pre><p>注意 JSON 的语法格式，在列表中不要少加或者多加逗号。保存配置文件之后就能在 Windows Terminal 中快捷启动 Git Bash 了。</p><p><img src="./build-a-decent-terminal-with-windows-terminal-and-oh-my-posh.assets/SI7S9fkaKG-1024x523.png" alt="img"/></p><h2>后记</h2><p>新的 Windows Terminal 使用体验还是挺不错的，颜值也 OK，折腾一下也挺好用的。</p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://github.com/microsoft/terminal">microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place!</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://github.com/JanDeDobbeleer/oh-my-posh2">JanDeDobbeleer/oh-my-posh2: A prompt theming engine for Powershell</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://github.com/lukesampson/scoop">lukesampson/scoop: A command-line installer for Windows.</a><a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-4"><a href="https://github.com/microsoft/cascadia-code">microsoft/cascadia-code: This is a fun, new monospaced font that includes programming ligatures and is designed to enhance the modern look and feel of the Windows Terminal.</a><a href="#fnref-4" class="footnote-backref">↩</a></li><li id="fn-5"><a href="https://github.com/ryanoasis/nerd-fonts">ryanoasis/nerd-fonts: Iconic font aggregator, collection, &amp; patcher. 3,600+ icons, 50+ patched fonts: Hack, Source Code Pro, more. Glyph collections: Font Awesome, Material Design Icons, Octicons, &amp; more</a><a href="#fnref-5" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《求生之路 2》制作动态喷漆]]></title>
        <id>《求生之路 2》制作动态喷漆</id>
        <link href="https://bobo2334.github.io/blog/making-dynamic-spray-paint-for-left-4-dead-2"/>
        <updated>2017-08-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/kana.gif" alt="img"/></p><p>动态的喷漆也是这个游戏的乐趣之一，尝试自己制作一下动态喷漆，将 GIF 图片转换为可以在游戏中使用的动态喷涂文件。</p><p>文中使用的工具和成品可以从 <a href="https://zfile.iuok.me/directlink/1/articles/making-dynamic-spray-paint-for-left-4-dead-2/tools.zip">这里</a> 下载。</p><h2>准备工作</h2><ol><li>一张 GIF 图片；</li><li>GIF 图片分解工具，用于把动态图的每一帧分解出来，文中使用的是 GifSplitter<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>；</li><li>VTFEdit<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>，核心工具，用于制作 VTF 格式的动态图。</li></ol><h2>分解 GIF</h2><p>这里使用的是 GifSplitter，目的是将 GIF 图片的每一帧都分解出来；其他功能类似的软件和在线工具都可以。</p><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/gifsplitter.png" alt="img"/></p><h2>制作 VTF</h2><p>打开 VTFEdit，点击左上角的 “导入” 按钮，选择并导入上一步中分离出来的所有图片。</p><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/import.png" alt="img"/></p><p>接下来设置贴图尺寸，选中 “限定贴图尺寸”，高度和宽度都设置为 128，其他设置保持默认。</p><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/options.png" alt="img"/></p><p>再切换到 “信息” 页中，查看文件大小；<strong>要确保其小于 512KB，否则无法喷出</strong>。如果文件太大的话，就把要导入的图片删除一些，再重复这些步骤，直至满足条件。</p><p>再满足条件之后就可以保存了，保存的时候注意<strong>不要使用中文文件名</strong>，不然在游戏里浏览文件的时候中文名会乱码。</p><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/save.png" alt="img"/></p><h2>在游戏中导入</h2><p>打开游戏，在游戏设置中依次找到 “导入喷漆图案”，选择上一步中制作好的 VTF 文件。</p><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/import-to-game.png" alt="img"/></p><h2>后记</h2><p>整个制作过程也不复杂，核心工具是 VTFEdit；至于分解 GIF 的工具就很多了，可以很灵活地选择其他软件来完成这个任务。</p><p>最重要的是控制文件大小，不能超过限制，不然在游戏中无法使用。如果文件大小太大的话可以考虑在分解出的图片中删除一些图片，来达到减小文件大小的目的。比如可以隔帧删除，每隔一张图片就删除一张图片，应该会很有效。</p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://www.xoyosoft.com/gs/">GifSplitter - Break GIF animation down into individual image frames</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://developer.valvesoftware.com/wiki/VTFEdit">VTFEdit - Valve Developer Community</a><a href="#fnref-2" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
</feed>