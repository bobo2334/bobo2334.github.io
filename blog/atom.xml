<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://iuok.me/blog</id>
    <title>我的学习笔记 Blog</title>
    <updated>2022-01-02T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://iuok.me/blog"/>
    <subtitle>我的学习笔记 Blog</subtitle>
    <icon>https://iuok.me/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[用 KMS 激活 Windows 和 Office]]></title>
        <id>用 KMS 激活 Windows 和 Office</id>
        <link href="https://iuok.me/blog/activate-windows-and-office-with-kms"/>
        <updated>2022-01-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[激活 Windows]]></summary>
        <content type="html"><![CDATA[<h2>激活 Windows</h2><p>只能激活 VL 版本的系统，零售版不能通过这种方式激活。</p><p>使用管理员权限运行<code>cmd</code>。</p><pre><code class="language-cmd">slmgr /skms kms.03k.org
slmgr /ato
</code></pre><h2>激活 Office</h2><p>进入 Office 安装目录，用管理员权限执行命令。</p><pre><code class="language-cmd"># C:\Program Files (x86)\Microsoft Office\Office16
cscript ospp.vbs /sethst:kms.03k.org
cscript ospp.vbs /act
</code></pre><h2>KMS 服务器收集</h2><p>在上面命令中的 KMS 服务器失效的时候可以尝试下面列表中的其它 KMS 服务器。</p><ul><li><code>kms.03k.org</code></li><li><code>kms.v0v.bid</code></li></ul><h2>自建 KMS 服务器</h2><p>或者也可以自己搭建 KMS 服务器，难度不高，通过 Docker 可以快速部署。</p><ul><li><a href="https://hub.docker.com/r/teddysun/kms">teddysun/kms - Docker Image | Docker Hub</a></li></ul><h2>其它激活方式</h2><ul><li><a href="https://cmwtat.cloudmoe.com/cn.html">云萌 Windows 10 激活工具 - 首页</a></li></ul><h2>参考资料</h2><ul><li><a href="https://03k.org/kms.html">本站上线 KMS 服务~一句命令激活 windows/office | 零散坑知识分享</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自建 Zerotier 行星节点]]></title>
        <id>自建 Zerotier 行星节点</id>
        <link href="https://iuok.me/blog/self-hosted-zerotier-controller"/>
        <updated>2021-12-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><blockquote><p>自建 ZeroTier Planet 行星服务器可以解决两个问题：</p><ol><li>官方免费版本有 50 个设备连接数的限制</li><li>提升网络稳定性</li></ol></blockquote><h2>运行项目</h2><p>使用<code>docker-compose</code>可以快速运行项目。<code>docker-compose.yml</code>的内容如下。</p><pre><code class="language-yaml">version: &#x27;3&#x27;
services:
  ztncui:
    image: keynetworks/ztncui
    restart: unless-stopped
    ports:
      - &#x27;3000:3000&#x27;
    environment:
      MYADDR: 172.38.38.38
      HTTP_ALL_INTERFACES: &quot;yes&quot;
      ZTNCUI_PASSWD: PASS
      TZ: Asia/Shanghai
    volumes:
      - ztncui:/opt/key-networks/ztncui/etc/
      - zerotier-one:/var/lib/zerotier-one/
volumes:
  ztncui: null
  zerotier-one: null
</code></pre><p>其中一些环境变量需要设置。</p><ul><li><code>MYADDR</code>：机器的公网 IP 地址</li><li><code>HTTP_ALL_INTERFACES</code>：监听所有网络接口</li><li><code>ZTNCUI_PASSWD</code>：设置<code>admin</code>用户的密码。</li></ul><p><code>ztncui</code>和<code>zerotier-one</code>两个 Volume 持久化配置信息，防止重新创建容器后丢失配置。</p><p>在当前目录下用<code>docker-compose up -d</code>启动容器。</p><p>防火墙需要放行<code>3000</code>端口。</p><h2>网络配置</h2><p>访问<code>IP:3000</code>可以进入网页管理 UI，也可以用反响代理服务器来转发此端口的流量，并用域名和 HTTPS 访问。用户名是<code>admin</code>，密码是你之前配置的环境变量<code>ZTNCUI_PASSWD</code>的值。</p><p>控制面板的使用方法和操作逻辑和官方控制面板差不多。</p><p>在底部的导航栏中点击「Networks」，再点击<code>Add network</code>创建一个网络。给网络起一个名字之后你就能在「Networks」中看见你刚刚创建的网络了。</p><p><img src="self-hosted-zerotier-controller.assets/image-20211231150656489.png" alt="image-20211231150656489"/></p><p>点击该网络名就能进入该网络设置的设置页面。</p><p><img src="self-hosted-zerotier-controller.assets/image-20211231152132452.png" alt="image-20211231152132452"/></p><p>点击「Easy setup」按钮为网络设置网段。在该页面中点击「Generate network address」按钮可以随机生成网段，点击「Submit」按钮保存信息。</p><p><img src="self-hosted-zerotier-controller.assets/image-20211231152152226.png" alt="image-20211231152152226"/></p><p>点击「Private」按钮设置私有网络/公开网络。</p><p><img src="self-hosted-zerotier-controller.assets/image-20211231152400238.png" alt="image-20211231152400238"/></p><p>点击「Routes」按钮设置静态路由。</p><p><img src="self-hosted-zerotier-controller.assets/image-20211231152422204.png" alt="image-20211231152422204"/></p><h2>客户端</h2><p>使用各个平台的原生客户端直接可以连接到自建网络。Network ID 填自己的就行了。</p><p>客户端在加入私有网络的时候需要在网络管理页面手动批准认证；勾选对应的「Authorized」列选框即可。</p><p><img src="self-hosted-zerotier-controller.assets/image-20211231152823640.png" alt="image-20211231152823640"/></p><h2>参考资料</h2><ul><li><a href="https://www.appinn.com/zerotier-planet-server-docker-install/">ZeroTier Planet 行星服务器，一键私有部署，可突破 50 台设备限制 - 小众软件</a></li><li><a href="https://github.com/Jonnyan404/zerotier-planet">Jonnyan404/zerotier-planet: 一分钟自建 zerotier-planet</a></li><li><a href="https://github.com/key-networks/ztncui">key-networks/ztncui: ZeroTier network controller UI</a></li><li><a href="https://github.com/key-networks/ztncui-containerized">key-networks/ztncui-containerized: A Docker image that contains ZeroTier One and ztncui to set up a standalone ZeroTier network controller with a web user interface in a container.</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UFW：简单易上手的防火墙规则管理工具]]></title>
        <id>UFW：简单易上手的防火墙规则管理工具</id>
        <link href="https://iuok.me/blog/ufw"/>
        <updated>2021-12-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>UFW 是一款在 Debian 系系统中可用的防火墙规则管理工具，可以帮助你快速配置各种服务的端口访问权限，而不用书写冗长的 iptables 规则命令。</p><h2>安装</h2><p>可以使用<code>apt</code>快速安装。</p><pre><code class="language-bash">apt install ufw
</code></pre><h2>启用/禁用</h2><p>使用以下命令来启用 UFW，并且会随着系统开启而启动。</p><pre><code class="language-bash">ufw enable
</code></pre><p>使用以下命令来停止 UFW。</p><pre><code class="language-bash">ufw disable
</code></pre><h2>默认行为</h2><p>使用<code>ufw default</code>命令来配置默认行为，以下两条是 UFW 初始化的默认行为；默认拒绝所有入流量，允许所有出流量。</p><pre><code class="language-bash">ufw default deny incoming
ufw default allow outgoing
</code></pre><p>你可以使用<code>ufw default</code>命令来覆盖默认行为，使用<code>allow</code>/<code>deny</code>和<code>incoming</code>/<code>outgoing</code>/<code>routed</code>组合。</p><p>使用下面的命令来查看当前的默认行为。</p><pre><code class="language-bash">ufw status verbose
</code></pre><p><img src="ufw.assets/image-20211231173659554.png" alt="image-20211231173659554"/></p><h2>添加规则</h2><h3>放行/禁止端口</h3><p>以下命令用于放行 53 端口的 TCP 和 UDP 流量。</p><pre><code class="language-bash">ufw allow 53
</code></pre><p>以下命令用于仅放行 53 端口的 TCP 流量。</p><pre><code class="language-bash">ufw allow 53/tcp
</code></pre><p>以下命令用于仅放行 53 端口的 UDP 流量。</p><pre><code class="language-bash">ufw allow 53/udp
</code></pre><p>还可以一次放行一个范围内的端口。</p><pre><code class="language-bash">ufw allow 1000:2000/tcp
</code></pre><p>禁止命令就是用<code>deny</code>替代<code>allow</code>。</p><pre><code class="language-bash">ufw deny 53
ufw deny 53/tcp
ufw deny 53/udp
ufw deny 1000:2000/tcp
</code></pre><h3>放行/禁止 IP</h3><pre><code class="language-bash">ufw allow from 1.2.3.4
ufw deny from 1.2.3.4
</code></pre><h2>删除规则</h2><p>使用<code>ufw delete</code>命令来删除一条之前添加的规则。</p><pre><code class="language-bash">ufw delete allow 53
ufw delete deny from 1.2.3.4
</code></pre><p>或者使用下面的命令列出添加的规则并编号，通过编号删除规则。</p><pre><code class="language-bash">ufw status numbered
ufw delete 2
</code></pre><p><img src="ufw.assets/image-20211231173743883.png" alt="image-20211231173743883"/></p><h2>常用服务端口</h2><p>在添加或删除关于端口的规则时，除了手动指出端口号之外，还可以通过服务名称来放行/禁止端口。</p><pre><code class="language-bash">ufw allow ssh
ufw deny ssh
ufw delete allow ssh
ufw delete deny ssh
</code></pre><p>服务名和端口号定义在<code>/etc/services</code>文件中。在其中有关<code>ssh</code>服务的部分是这样写的。</p><pre><code>ssh     22/tcp              # SSH Remote Login Protocol
</code></pre><p>UFW 会根据此文件内容管理端口。</p><p>常用的服务名称有<code>ssh</code>、<code>http</code>和<code>https</code>等。</p><h2>参考资料</h2><ul><li><a href="https://wiki.debian.org/Uncomplicated%20Firewall%20%28ufw%29">Uncomplicated Firewall (ufw) - Debian Wiki</a></li><li><a href="https://help.ubuntu.com/community/UFW">UFW - Community Help Wiki</a></li><li><a href="https://en.wikipedia.org/wiki/Uncomplicated_Firewall">Uncomplicated Firewall - Wikipedia</a></li><li><a href="https://www.linux.com/training-tutorials/introduction-uncomplicated-firewall-ufw/">An Introduction to Uncomplicated Firewall (UFW) - Linux.com</a></li><li><a href="https://www.arubacloud.com/tutorial/how-to-set-up-and-configure-ufw-firewall-on-ubuntu-20-04.aspx">UFW Tutorial: How To Set Up a Firewall with UFW on Ubuntu 20.04 | ArubaCloud.com</a></li><li><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-20-04">How To Set Up a Firewall with UFW on Ubuntu 20.04 | DigitalOcean</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Debian 配置备份]]></title>
        <id>Debian 配置备份</id>
        <link href="https://iuok.me/blog/debian-environment-backup"/>
        <updated>2021-12-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[软件源]]></summary>
        <content type="html"><![CDATA[<h2>软件源</h2><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">debian | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></li></ul><pre><code class="language-bash">apt edit-sources
</code></pre><pre><code class="language-bash"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free

deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free

deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free

deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free
# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free
</code></pre><pre><code class="language-bash">apt update
</code></pre><h2>小工具</h2><pre><code class="language-bash">apt install curl wget tmux bat htop exa neofetch trash-cli
</code></pre><h2>alias</h2><pre><code class="language-bash">alias bat=&#x27;batcat&#x27;
alias ll=&#x27;exa -lha --modified --created --time-style long-iso --group-directories-first&#x27;
alias dc=&#x27;docker-compose&#x27;
alias lzd=&#x27;lazydocker&#x27;
alias rm=&#x27;echo &quot;please use trash-put&quot;&#x27;
</code></pre><h2>docker</h2><pre><code class="language-bash">wget https://get.docker.com/ -O get-docker.sh
# sh get-docker.sh --mirror Aliyun
sh get-docker.sh
systemctl enable docker
</code></pre><h2>docker-compose</h2><ul><li><a href="https://github.com/docker/compose/releases">Releases · docker/compose</a></li></ul><pre><code class="language-bash"># wget https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-linux-x86_64 -O /opt/docker-compose
wget https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-linux-x86_64 -O /opt/docker-compose
chmod u+x /opt/docker-compose
ln -s /opt/docker-compose /usr/local/sbin/docker-compose
</code></pre><h2>lazydocker</h2><ul><li><a href="https://github.com/jesseduffield/lazydocker/releases">Releases · jesseduffield/lazydocker</a></li></ul><pre><code class="language-bash"># wget https://ghproxy.com/https://github.com/jesseduffield/lazydocker/releases/download/v0.12/lazydocker_0.12_Linux_x86_64.tar.gz
wget https://github.com/jesseduffield/lazydocker/releases/download/v0.12/lazydocker_0.12_Linux_x86_64.tar.gz
mkdir ~/lazydocker
tar -zxvf lazydocker_0.12_Linux_x86_64.tar.gz -C ~/lazydocker
mv ~/lazydocker/lazydocker /opt/lazydocker
chmod u+x /opt/lazydocker
ln -s /opt/lazydocker /usr/local/sbin/lazydocker
trash-put ~/lazydocker
# rm -rf ~/lazydocker
</code></pre><pre><code class="language-yaml"># ~/.config/jesseduffield/lazydocker/config.yml
reporting: &quot;off&quot;
gui:
  returnImmediately: true
commandTemplates:
  serviceLogs: &#x27;{{ .DockerCompose }} logs --timestamps --follow --tail 500 {{ .Service.Name }}&#x27;
  viewServiceLogs: &#x27;{{ .DockerCompose }} logs --tail 500 --follow {{ .Service.Name }}&#x27;
  containerLogs: docker logs --timestamps --follow --tail 500 {{ .Container.ID }}
  viewContainerLogs: docker logs --timestamps --follow --tail 500 {{ .Container.ID}}
</code></pre><h2>croc</h2><ul><li><a href="https://github.com/schollz/croc/releases">Releases · schollz/croc</a></li></ul><pre><code class="language-bash"># wget https://ghproxy.com/https://github.com/schollz/croc/releases/download/v9.5.0/croc_9.5.0_Linux-64bit.deb
wget https://github.com/schollz/croc/releases/download/v9.5.0/croc_9.5.0_Linux-64bit.deb
dpkg -i croc_9.5.0_Linux-64bit.deb
</code></pre><h2>bat</h2><ul><li><a href="https://github.com/sharkdp/bat/releases">Releases · sharkdp/bat</a></li></ul><pre><code class="language-bash"># wget https://ghproxy.com/https://github.com/sharkdp/bat/releases/download/v0.18.3/bat_0.18.3_amd64.deb
wget https://github.com/sharkdp/bat/releases/download/v0.18.3/bat_0.18.3_amd64.deb
dpkg -i bat_0.18.3_amd64.deb
</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker 穿透防火墙的问题]]></title>
        <id>Docker 穿透防火墙的问题</id>
        <link href="https://iuok.me/blog/docker-and-system-firewall"/>
        <updated>2021-12-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>有些服务只需要在本地访问，不需要向外暴露端口，不然会有安全隐患，总有一大堆机器扫描你的端口，尝试接入你的服务。</p><p>通过 Docker 暴露的端口，即使没有在防火墙中手动放行，在外部还是可以访问到。</p><h2>解决办法</h2><p>在进行端口映射的时候指定监听地址为<code>127.0.0.1</code>，如<code>127.0.0.1:3000:80</code>。在没指定的情况下，如<code>3000:80</code>，监听地址为<code>0.0.0.0</code>。</p><p>这在使用<code>docker run</code>命令和<code>docker-compose</code>命令的时候都可以生效。</p><p><code>docker run</code>命令示例如下。</p><pre><code class="language-bash">docker run -p 127.0.0.1:80:80 nginx
</code></pre><p>使用<code>docker-compose</code>命令时，<code>docker-compose.yml</code>内容示例如下。</p><pre><code class="language-yml">version: &#x27;3.3&#x27;
services:
    nginx:
        ports:
            - &#x27;127.0.0.1:80:80&#x27;
        image: nginx
</code></pre><h2>参考资料</h2><ul><li><a href="https://www.binss.me/blog/docker-pass-through-system-firewall/">无视系统防火墙的 docker - 博客 - binsite</a></li><li><a href="https://icharle.com/dockeriptables.html">docker 无视防火墙问题总结 - Icharle | Don&#x27;t forget your first thoughts</a></li><li><a href="https://www.zhihu.com/question/64616650">docker 开放的端口是如何实现绕过防火墙的？ - 知乎</a></li><li><a href="https://www.jianshu.com/p/69d3ab177655">Docker 与 IPtables - 简书</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过代理连接 SSH 服务器]]></title>
        <id>通过代理连接 SSH 服务器</id>
        <link href="https://iuok.me/blog/ssh-under-proxy"/>
        <updated>2021-12-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[正文]]></summary>
        <content type="html"><![CDATA[<h2>正文</h2><p>下面的命令用于通过 SOCKS5 代理连接到 SSH 服务器。其中<code>127.0.0.1:7890</code>是本地 SOCKS5 代理的地址和端口号。</p><pre><code class="language-bash">ssh -oProxyCommand=&quot;nc -x 127.0.0.1:7890 %h %p&quot; root@198.198.198.198
</code></pre><h2>参考资料</h2><ul><li><a href="https://www.lainme.com/doku.php/blog/2011/01/%E9%80%8F%E8%BF%87%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5ssh">透过代理连接 SSH [Lainme&#x27;s Blog]</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iterm2 对 tmux 的特殊支持]]></title>
        <id>iterm2 对 tmux 的特殊支持</id>
        <link href="https://iuok.me/blog/tmux-integration-in-iterm2"/>
        <updated>2021-12-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>tmux<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 是一款非常好用的终端复用工具，它可以帮助你快速地保存和恢复工作现场。</p><p>使用 tmux 的时候有许多快捷键需要记忆，并且窗格切换和窗格的上下滚动并不方便；tmux 的快捷键还可能和其它软件的快捷键有冲突。</p><p>iterm2<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 是 macOS 中的一个终端模拟器软件，它对 tmux 有独家支持，可以在控制模式下运行 tmux。在这个模式中，tmux 会话表现和本地终端一样，可以使用 iterm2 的快捷键来进行多窗口和多窗格分隔，用鼠标切换窗口和窗格，并且用鼠标滚轮上下滚动窗格也能正常工作，不需要进 tmux 的复制模式来滚动窗格。</p><h2>使用</h2><p>不论是在本地使用 tmux，还是通过 ssh 使用远端的 tmux，iterm2 都支持使用 tmux 的控制模式。</p><p>tmux 的控制模式通过附加<code>-CC</code>参数来开启。</p><p>如<code>tmux -CC</code>命令会开启一个新的 tmux 会话，并启用控制模式，之后你的 iterm 会打开一个新的窗口，用于展示 tmux 会话；该窗口的表现和没使用 tmux 时一样，你不需要通过快捷键或 tmux 命令来新建多窗口和多窗格。使用 iterm2 的快捷键<kbd>Command+D</kbd>和<kbd>Command+Shift+D</kbd>来分隔窗格，使用<kbd>Command+N</kbd>来新建 Tab，使用<kbd>Command+N</kbd>来新建窗口。</p><p>使用如下命令来附加到一个已存在的 tmux 会话。</p><pre><code class="language-bash">tmux ls
tmux -CC attach -t 0
</code></pre><p>下面的命令用于创建一个名为<code>main</code>的会话，如果该会话存在的话则直接恢复该会话。</p><pre><code class="language-bash">tmux -CC new -A -s main
</code></pre><p>或者在通过 SSH 连接到服务器的时候直接执行此命令，直接打开一个 tmux 会话。</p><pre><code class="language-bash">ssh -t root@1.1.1.1 &#x27;tmux -CC new -A -s main&#x27;
</code></pre><h2>参考资料</h2><ul><li><a href="https://gitlab.com/gnachman/iterm2/-/wikis/tmux-Integration-Best-Practices">tmux Integration Best Practices · Wiki · George Nachman / iterm2 · GitLab</a></li></ul><div class="footnotes"><hr/><ol><li id="fn-1"><a href="../docs/notes/utility/tmux">tmux | 我的学习笔记</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://iterm2.com/documentation-tmux-integration.html">tmux Integration - Documentation - iTerm2 - macOS Terminal Replacement</a><a href="#fnref-2" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zerotier 异地组网]]></title>
        <id>Zerotier 异地组网</id>
        <link href="https://iuok.me/blog/zerotier"/>
        <updated>2021-12-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>Zerotier<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 是一个优秀的异地组网解决方案。其优点是组网灵活、不需要更改现有网络结构，支持 P2P 和转发。</p><p>Zerotier 使用也不是没有限制，免费版本的最多加入 50 个客户端，不过对于个人来说肯定够用了。</p><h2>控制台</h2><p>在控制台 <sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 注册并登陆。</p><p>在创建网络后会得到一个 Network ID，此 ID 是唯一的，是客户端加入此网络所需的唯一参数。</p><p><img src="zerotier.assets/image-20211223012353090.png" alt="image-20211223012353090"/></p><p>在网络管理页面中，Access Control 控制客户端认证方式，如果选择<code>PRIVATE</code>则每个客户端的加入都需要在此页面经由你允许。</p><p><img src="zerotier.assets/image-20211223012418452.png" alt="image-20211223012418452"/></p><p>在 IPv4 Auto-Assign 中，可以对客户端的 IP 段进行配置，不和你原来的网络地址冲突即可。</p><p><img src="zerotier.assets/image-20211223012631035.png" alt="image-20211223012631035"/></p><p>在 Members 中你可以管理该网络下的所有客户端，勾选客户端对应的<code>Auth?</code>选框即可让客户端加入此网络。每个客户端在加入的时候会自动分配一个 IP 地址，你还可以手动分配客户端的 IP 地址。</p><p><img src="zerotier.assets/image-20211223012842109.png" alt="image-20211223012842109"/></p><p>在多个客户端加入网络后，即使处于不同的网络环境下，客户端都可以通过分配到的 IP 互相访问。</p><h2>客户端</h2><p>Zerotier 在常用平台上都有客户端，有图形化的有命令行的。</p><p><img src="zerotier.assets/image-20211223011629303.png" alt="image-20211223011629303"/></p><h2>自动 NAT</h2><p>在前面的方案中， 如果多个机器互相访问就需要每个机器都安装 Zerotier 客户端并加入同一个网络。</p><p>借助 OpenWrt 和 Zerotier 可以暴露整个局域网到 Zerotier 网络中，只需要 OpenWrt 中的 Zerotier 加入网络即可。</p><p>勾选「自动允许客户端 NAT」即可。</p><p><img src="zerotier.assets/image-20211223014114997.png" alt="image-20211223014114997"/></p><p>许多 OpenWrt 的发行版都集成了此软件包。可以参考如下 Telegram 频道：</p><ul><li><a href="https://t.me/OpenWRTcn">Telegram: Contact @OpenWRTcn</a></li><li><a href="https://t.me/aixiaoshao">Telegram: Contact @aixiaoshao</a></li><li><a href="https://t.me/passwallOpenWRT233">Telegram: Contact @passwallOpenWRT233</a></li></ul><p>OpenWrt 不需要作为你的主路由，它可以通过 LAN 口接入你现有的局域网，关闭 LAN 口的 DHCP 服务，作为旁路由使用。</p><p>你还需要在 Zerotier 控制台中配置静态路由。</p><p><img src="zerotier.assets/image-20211223014932675.png" alt="image-20211223014932675"/></p><p>在添加静态路由的时候<code>Destination</code>填局域网的网络地址，<code>(Via)</code>为下一跳地址，即 OpenWrt 路由器的 Zerotier 地址。</p><p>上面的静态路由配置将<code>192.168.10.0/24</code>局域网和<code>192.168.11.0/24</code>局域网暴露在 Zerotier 网络中。<code>172.22.39.15</code>和<code>172.22.105.60</code>分别是两个 OpenWrt 路由器在 Zerotier 网络中的地址，这两个路由器均配置了自动允许客户端 NAT。</p><p>这样做的优点是管理方便，不需要在每个机器上安装客户端并且加入网络。并且即使你在使用移动网络的时候可以直接访问到家里局域网的 IP，并且还是通过局域网 IP 访问，并不需要修改软件配置。</p><p>大致的网络拓扑图如下。在外使用移动网络的情况下，你可以使用<code>192.168.10.0/24</code>或<code>192.168.11.0/24</code>网段的内网地址访问局域网 A 或局域网 B 内的资源。</p><p>如果局域网 A 中的某台设备需要访问局域网 B 中的资源，还是需要在该设备上安装 Zerotier 客户端，并且加入统一 Zerotier 网络，然后就可以通过<code>192.168.11.0/24</code>的内网  IP 地址来访问局域网 B 中的资源了。</p><p><img src="zerotier.assets/image-20211223022539047.png" alt="image-20211223022539047"/></p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://www.zerotier.com/">ZeroTier – Global Area Networking</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://my.zerotier.com/network">ZeroTier Central</a><a href="#fnref-2" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 HTML 中使用 Unicode 代码]]></title>
        <id>在 HTML 中使用 Unicode 代码</id>
        <link href="https://iuok.me/blog/use-unicode-in-html"/>
        <updated>2021-11-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>在某些情况下需要在 HTML 中嵌入特殊符号，但是 HTML 实体中并不包含这些符号，或是该实体符号不能被浏览器正确渲染，可以通过 Unicode 代码代替这些字符，以达到在网页中正确渲染该字符的目的。HTML 实体代码和字符对应的 Unicode 代码可以参考 HTML Standard<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>。</p><h2>声明网页编码</h2><p>为了能在网页中正常显示 Unicode 字符，该网页必须使用 Unicode 编码，如 UTF-8。可在<code>meta</code>标签里声明网页编码，并确保 HTTP 头也使用此编码。</p><pre><code class="language-html">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
</code></pre><h2>使用 HTML 实体</h2><p>在 HTML Standard<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 中可以看到该符号的名字是<code>Aacute;</code>，可以在其前方加上<code>&amp;</code>来表示 HTML 命名字符。</p><p>Á</p><pre><code class="language-html">&lt;p&gt;&amp;Aacute;&lt;/p&gt;
</code></pre><p>但是并不是所有的命名字符都能被渲染出来，比如字符<code>{</code>。</p><p>&amp;lbrace;</p><pre><code class="language-html">&lt;p&gt;&amp;lbrace;&lt;/p&gt;
</code></pre><h2>使用 Unicode 代码</h2><p>可以使用十六进制编码。</p><p>{</p><pre><code class="language-html">&lt;p&gt;&amp;#x0007B;&lt;/p&gt;
</code></pre><p>也可以使用十进制编码。</p><p>{</p><pre><code class="language-html">&lt;p&gt;&amp;#123;&lt;/p&gt;
</code></pre><h2>参考资料</h2><ul><li><a href="https://www.cnblogs.com/liuxianan/p/display-unicode-character-in-html-css-and-js.html">HTML、CSS、JS 对 unicode 字符的不同处理 - 我是小茗同学 - 博客园</a></li><li><a href="https://www.w3schools.com/charsets/ref_utf_symbols.asp">HTML Unicode UTF-8</a></li></ul><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references">HTML Standard</a><a href="#fnref-1" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[配置 oh-my-zsh]]></title>
        <id>配置 oh-my-zsh</id>
        <link href="https://iuok.me/blog/oh-my-zsh"/>
        <updated>2021-11-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>oh-my-zsh<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 是 zsh<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 的一款插件管理器，提供了很多 zsh 的插件和主题。</p><p>zsh 的优点是兼容 bash 语法，可以在日常工作中替换掉 bash，并且可以享受 zsh 的很多特性。</p><h2>安装</h2><p>安装 oh-my-zsh 之前需要先安装 zsh 和 git，oh-my-zsh 依赖它们在能正常工作。</p><p>在 zsh 中执行以下命令安装 oh-my-zsh。</p><pre><code class="language-bash">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
</code></pre><p>安装脚本就是帮你克隆了 oh-my-zsh 的仓库到<code>~/.oh-my-zsh</code>，并且给你新建了一个<code>~/.zshrc</code>文件模板，用于在 zsh 启动时加载 oh-my-zsh。</p><p>你之前的<code>.zshrc</code>文件内容被转移到<code>.zshrc.pre-oh-my-zsh</code>，现在的<code>.zshrc</code>的内容是全新的，如果你之前在用户配置文件里做了重要配置，你需要将<code>.zshrc.pre-oh-my-zsh</code>里的内容附加到现在的<code>.zshrc</code>之后，以确保之前的功能正常使用。</p><h2>主题</h2><p>oh-my-zsh 默认自带了许多主题，这些主题文件存放在<code>~/.oh-my-zsh/themes/</code>文件夹下。你可以在 oh-my-zsh 主题 wiki<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup> 中参考这些主题的预览图。</p><p>编辑<code>.zshrc</code>文件，修改<code>ZSH_THEME</code>配置，执行<code>exec zsh</code>命令或重启终端即可看到新主题的效果。</p><pre><code class="language-bash">ZSH_THEME=&quot;robbyrussell&quot;
</code></pre><h2>第三方主题</h2><p>除了默认自带的主题外，你还可以使用第三方主题，如 Dracula<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup> 主题。</p><p>下面的命令用于克隆 Dracula 主题的仓库到本地的<code>~/zsh-dracula</code>文件夹。</p><pre><code class="language-bash">git clone https://github.com/dracula/zsh.git ~/zsh-dracula
</code></pre><p>你可以手动复制<code>~/zsh-dracula</code>下的<code>dracula.zsh-theme</code>文件和<code>lib</code>文件夹至<code>~/.oh-my-zsh/custome/themes/</code>文件夹下来完成主题的安装。</p><p>也可以使用以下命令创建一个主题的软连接到主题文件夹，来完成主题的安装。</p><pre><code class="language-bash">ln -s ~/zsh-dracula/dracula.zsh-theme $ZSH_CUSTOM/themes/dracula.zsh-theme
</code></pre><p>在安装完成之后编辑<code>.zshrc</code>文件，修改<code>ZSH_THEME</code>配置，执行<code>exec zsh</code>命令或重启终端即可看到新主题的效果。</p><pre><code class="language-bash">ZSH_THEME=&quot;dracula&quot;
</code></pre><h2>插件</h2><p>oh-my-zsh 默认自带了许多插件，这些插件文件存放在<code>~/.oh-my-zsh/plugins/</code>文件夹下。你可以在 oh-my-zsh 插件 wiki<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup> 中查阅默认插件的目录和文档。</p><p>编辑<code>.zshrc</code>文件，修改<code>plugins</code>配置，把插件名称写入其中即可启用插件，每个插件名称之间用空格或换行分隔，不要用逗号。注意过多的插件会影响启动时间。执行<code>exec zsh</code>命令或重启终端即可让配置文件生效。</p><pre><code class="language-bash">plugins=(git theme)
</code></pre><p>下面记录一些自用的插件。</p><h3>git<sup id="fnref-6"><a href="#fn-6" class="footnote-ref">6</a></sup></h3><p>默认启用的插件，提供了一些 Git 命令的别名和 Git 相关的常用命令，详情可参考其文档 <sup id="fnref-6"><a href="#fn-6" class="footnote-ref">6</a></sup>。</p><h3>theme<sup id="fnref-7"><a href="#fn-7" class="footnote-ref">7</a></sup></h3><p>用命令预览主题，不需要修改配置文件。</p><ul><li><code>theme</code>，随机加载主题</li><li><code>lstheme</code>，列出所有主题</li><li><code>theme &lt;name&gt;</code>，预览指定主题</li></ul><h3>z<sup id="fnref-8"><a href="#fn-8" class="footnote-ref">8</a></sup></h3><p>提供一个<code>z</code>命令用于常用目录快速跳转，日常中可以替换掉<code>cd</code>，在通过<code>z</code>命令切换目录后下次切换只需要输入部分文件名。</p><p>下面的命令演示了<code>z plug</code>命令切换到<code>~/.oh-my-zsh/plugins</code>目录。</p><pre><code class="language-bash">/usr/bin$ z plug  # Even &#x27;z p&#x27; might suffice
~/.oh-my-zsh/plugins$
</code></pre><h3>safe-paste<sup id="fnref-9"><a href="#fn-9" class="footnote-ref">9</a></sup></h3><p>防止粘贴进终端的多行代码直接执行。</p><h3>sudo<sup id="fnref-10"><a href="#fn-10" class="footnote-ref">10</a></sup></h3><p>按两次<kbd>ESC</kbd>为你当前的命令或前一次命令加上<code>sudo</code>前缀。</p><h2>第三方插件</h2><h3>zsh-syntax-highlighting<sup id="fnref-11"><a href="#fn-11" class="footnote-ref">11</a></sup></h3><p>命令语法高亮。</p><p>克隆仓库。</p><pre><code class="language-bash">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting
</code></pre><p>编辑<code>.zshrc</code>文件，修改<code>plugins</code>配置，加上<code>zsh-syntax-highlighting</code>。</p><pre><code class="language-bash">plugins=(git theme zsh-syntax-highl3ighting)
</code></pre><h3>zsh-autosuggestions<sup id="fnref-12"><a href="#fn-12" class="footnote-ref">12</a></sup></h3><p>根据历史命令和命令提示插件来给你输入建议。</p><p>克隆仓库。</p><pre><code class="language-bash">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions
</code></pre><p>编辑<code>.zshrc</code>文件，修改<code>plugins</code>配置，加上<code>zsh-autosuggestions</code>。</p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://github.com/ohmyzsh/ohmyzsh">ohmyzsh/ohmyzsh: 🙃 A delightful community-driven (with 1900+ contributors) framework for managing your zsh configuration. Includes 300+ optional plugins (rails, git, macOS, hub, docker, homebrew, node, php, python, etc), 140+ themes to spice up your morning, and an auto-update tool so that makes it easy to keep up with the latest updates from the community.</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH">Installing ZSH · ohmyzsh/ohmyzsh Wiki</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">Themes · ohmyzsh/ohmyzsh Wiki</a><a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-4"><a href="https://draculatheme.com/zsh">Dark theme for Zsh and 223+ apps — Dracula</a><a href="#fnref-4" class="footnote-backref">↩</a></li><li id="fn-5"><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">Plugins · ohmyzsh/ohmyzsh Wiki (github.com)</a><a href="#fnref-5" class="footnote-backref">↩</a></li><li id="fn-6"><a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git">ohmyzsh/plugins/git at master · ohmyzsh/ohmyzsh</a><a href="#fnref-6" class="footnote-backref">↩</a></li><li id="fn-7"><a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/themes">ohmyzsh/plugins/themes at master · ohmyzsh/ohmyzsh</a><a href="#fnref-7" class="footnote-backref">↩</a></li><li id="fn-8"><a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/z">ohmyzsh/plugins/z at master · ohmyzsh/ohmyzsh</a><a href="#fnref-8" class="footnote-backref">↩</a></li><li id="fn-9"><a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/safe-paste">ohmyzsh/plugins/safe-paste at master · ohmyzsh/ohmyzsh</a><a href="#fnref-9" class="footnote-backref">↩</a></li><li id="fn-10"><a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/sudo">ohmyzsh/plugins/sudo at master · ohmyzsh/ohmyzsh</a><a href="#fnref-10" class="footnote-backref">↩</a></li><li id="fn-11"><a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-users/zsh-syntax-highlighting: Fish shell like syntax highlighting for Zsh.</a><a href="#fnref-11" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scoop：最好用的 Windows 包管理器（或许是）]]></title>
        <id>Scoop：最好用的 Windows 包管理器（或许是）</id>
        <link href="https://iuok.me/blog/scoop-the-windows-package-manager"/>
        <updated>2021-11-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[引入 Scoop]]></summary>
        <content type="html"><![CDATA[<h2>引入 Scoop</h2><p>包管理器用于管理软件的生命周期：安装软件及其依赖，配置软件环境变量、更新软件和卸载软件。</p><p>Scoop<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 是 Windows 上的一款包管理器，它是用 PowerShell 编写的，它可以帮助使用者特别是开发人员管理软件环境，快速构建开发环境。常用的开发工具都可以通过 Scoop 安装和管理。</p><p>Scoop 的本质是一系列 PowerShell 脚本的集合，所以运行 Scoop 需要 PowerShell 环境。并且它是针对 Windows 系统设计的，不具有跨平台性。</p><p>Scoop 对软件的管理功能依赖于提前定义好的针对每个软件包的配置文件，这些文件为 JSON 格式，称为 <strong>Manifest</strong>，由众多开发者维护，并托管在 Github。一个 Manifest 对应一个软件，其中包含了该软件的下载地址、安装/卸载脚本和其它必要信息。存放 Manifest 的仓库被称为 <strong>Bucket</strong>，对应一个 Git 仓库。Manifest 和 Bucket 是 Scoop 中的核心概念。</p><p>Scoop 对 Manifest 和 Bucket 的管理依赖于 Git。目前 Scoop 的官方 Bucket 托管在 GitHub。</p><p>Scoop 安装软件的过程依赖于 7-zip 和其它类型的解包软件如 innounp，Scoop 会将安装包里的文件解压至软件安装目录。<code>.zip</code>、<code>.7z</code>、<code>.msi</code>和大部分的<code>.exe</code>文件都能解包，软件的安装过程都是自动的，并不是传统的可视化界面方式，不需要人工干预，都由 Scoop 自动管理，程序文件放在统一的位置。软件开发者并不需要专门为 Scoop 制作专门的安装包，通用的软件安装程序都可以通过 Scoop 安装。</p><p>通过 Scoop 安装的软件大多是「绿色软件」，即不会写入注册表、不会创建桌面快捷方式，软件单独运行，不会有过多的依赖。Scoop 会根据 Manifest 中的信息为软件创建开始菜单中的快捷方式、创建命令链接、配置环境变量，通过 Scoop 安装软件不会污染系统环境。</p><h2>安装前准备</h2><p>Scoop 的安装和使用都需要访问到 Github，考虑到国内网络情况的特殊性，请你自备代理软件以确保能正常访问 GitHub。</p><p>大部分的命令行应用不会读取系统代理设置，所以有些情况下及时你启动了代理软件命令行应用也不会通过代理软件访问网络，你可能需要手动设置命令行环境的代理。</p><p>在 PowerShell 中，你可以执行以下命令来设置代理，请酌情替换其中的地址和端口号。</p><pre><code class="language-powershell">$Env:http_proxy=&quot;http://127.0.0.1:11223&quot;
$Env:https_proxy=&quot;http://127.0.0.1:11223&quot;
</code></pre><p>该命令只在当前会话生效，当你关闭了 PowerShell 再次打开一个新的会话时则你需要再次执行该命令才能让代理设置生效。</p><p>你可以将这些命令写入<code>$PROFILE</code>文件来避免在每次新会话中重复执行命令的工作。PowerShell 在每次会话启动之后都会执行一次<code>$PROFILE</code>配置文件中的命令。</p><p>以下命令用于创建并用记事本打开<code>$PROFILE</code>文件。</p><pre><code class="language-powershell">if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }
notepad $PROFILE
</code></pre><p>在打开的记事本中写入设置代理的命令，保存该文件，并重新打开 PowerShell 即可生效。</p><pre><code class="language-powershell">$Env:http_proxy=&quot;http://127.0.0.1:11223&quot;
$Env:https_proxy=&quot;http://127.0.0.1:11223&quot;
</code></pre><h2>前提</h2><p>Scoop 依赖以下系统环境才能正常工作。</p><ol><li>PowerShell 5+</li><li>.NET Framework 4.5+</li></ol><p>对于现代的 Windows 10 系统来说，这些条件已自动满足，对于较为古老的 Windows 7 系统用户来说，你可能需要手动升级 PowerShell 到<code>PowerShell 5</code>，并安装<code>.NET Framework 4.5</code>。</p><p>Scoop 依赖 Git 和 7-zip 来完成基本的工作，但是你不需要手动安装这些软件。你只需要确保良好的网络环境。</p><h2>设置安装位置</h2><p>// TODO 补充此章节，还有各个步骤的截图</p><h2>安装 Scoop</h2><p>接下来的命令都在 PowerShell 中执行。</p><p>下面的命令用于允许执行外部 PowerShell 脚本。你可能看到提示信息，请输入「Y」并按下回车键。</p><pre><code class="language-powershell">Set-ExecutionPolicy RemoteSigned -scope CurrentUser
</code></pre><p>下面的命令用于安装 Scoop。</p><pre><code class="language-powershell">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&#x27;https://get.scoop.sh&#x27;)
</code></pre><p>在安装完成之后你将得到一个新的可执行命令<code>scoop</code>。下面的命令用于安装 7-zip 和 Git。</p><pre><code class="language-powershell">scoop install 7-zip git
</code></pre><p>等待命令执行完毕之后你就可以在命令行中使用<code>7z</code>和<code>git</code>命令，Scoop 已经为你配置好了环境变量和命令链接。</p><p>在安装好 Git 之后你需要为 Git 设置代理，以下命令用来为 Git 设置代理，请酌情替换其中的地址和端口号。</p><pre><code class="language-bash">git config --global http.proxy http://127.0.0.1:11223
git config --global https.proxy https://127.0.0.1:11223
</code></pre><p>对 Git 的设置是永久性的，以下命令用于取消为 Git 设置代理，使用时请去掉注释前缀。</p><pre><code class="language-bash"># git config --global --unset http.proxy
# git config --global --unset https.proxy
</code></pre><p>下面的命令用于添加<code>extras</code>软件仓库。</p><pre><code class="language-powershell">scoop bucket add extras
</code></pre><h2>Scoop 的目录结构</h2><p>// TODO 补充此章节，还有各个步骤的截图</p><h2>Scoop 软件管理命令</h2><table><thead><tr><th>命令</th><th>示例</th><th>备注</th></tr></thead><tbody><tr><td><code>scoop search &lt;关键词&gt;</code></td><td><code>scoop search firefox</code></td><td>搜索和关键词相关的软件包</td></tr><tr><td><code>scoop info &lt;包名&gt;</code></td><td><code>scoop info firefox</code></td><td>查看软件包信息</td></tr><tr><td><code>scoop install &lt;包名&gt;</code></td><td><code>scoop install nodejs-lts adopt8-hotspot</code></td><td>安装指定软件，可以一次性安装多个软件，用空格分割这些软件名</td></tr><tr><td><code>scoop uninstall &lt;包名&gt;</code></td><td><code>scoop uninstall nodejs-lts</code></td><td>卸载指定软件</td></tr><tr><td><code>scoop reinstall &lt;包名&gt;</code></td><td><code>scoop reinstall nodejs-lts</code></td><td>重新安装指定软件</td></tr><tr><td><code>scoop reset &lt;包名&gt;</code></td><td><code>scoop reset python</code></td><td>重新执行软件安装后脚本，以解决冲突</td></tr><tr><td><code>scoop list</code></td><td></td><td>列出所有已安装软件</td></tr><tr><td><code>scoop list &lt;关键词&gt;</code></td><td><code>scoop list node</code></td><td>列出和关键词相关的已安装软件</td></tr><tr><td><code>scoop status</code></td><td></td><td>查询更新信息</td></tr><tr><td><code>scoop update &lt;包名&gt;</code></td><td><code>scoop update vscode</code></td><td>更新指定的软件</td></tr><tr><td><code>scoop update</code></td><td></td><td>更新 Scoop 和所有仓库信息</td></tr></tbody></table><h2>Scoop 仓库管理命令</h2><p>仓库相关命令均以<code>scoop bucket</code>开始。</p><table><thead><tr><th>命令</th><th>示例</th><th>备注</th></tr></thead><tbody><tr><td><code>scoop bucket known</code></td><td></td><td>列出知名软件仓库</td></tr><tr><td><code>scoop bucket add &lt;知名仓库名&gt;</code></td><td><code>scoop bucket add jetbrains</code></td><td>添加知名软件仓库，不用输入仓库地址</td></tr><tr><td><code>scoop bucket add &lt;别名&gt; &lt;仓库地址&gt;</code></td><td><code>scoop bucket add bobo2334 https://github.com/bobo2334/scoop-bucket.git</code></td><td>添加第三方软件仓库</td></tr><tr><td><code>scoop bucket rm &lt;别名&gt;</code></td><td><code>scoop bucket rm nerd-fonts</code></td><td>移除软件仓库</td></tr><tr><td><code>scoop bucket list</code></td><td></td><td>列出所有已添加的软件仓库</td></tr></tbody></table><h2>卸载 Scoop</h2><p>如果 Scoop 不能让你满意的话，你可以用下面的命令来移除 Scoop。这将会删除所有你用 Scoop 安装的软件，最后删除 Scoop 它自身。</p><pre><code class="language-powershell">scoop uninstall scoop
</code></pre><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://scoop.sh/">Scoop</a><a href="#fnref-1" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端]]></title>
        <id>Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端</id>
        <link href="https://iuok.me/blog/use-pwsh-and-oh-my-posh3-on-windows"/>
        <updated>2021-11-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>在 macOS 中用 zsh 配合 oh-my-zsh 可以打造出一个用的很舒服的终端，其实在 Windows 中也可以。</p><p>在 Windows 中可以用 pwsh<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 和 oh-my-posh<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 打造出一个好用的终端。</p><p>Windows 自带的 PowerShell 版本低，所以需要额外安装一个新版本的 pwsh，而不是用系统提供的。</p><p>oh-my-posh3 现在已基于 Go 语言重构，是一个跨平台的命令行工具，安装和配置方式和 oh-my-posh2 相比有些变化。</p><p>终端软件用的是 Windows Terminal<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup>，这是一个现代化的、可自定义的好看的终端模拟器。</p><p>历史命令提示是通过 PowerShell 的 PSReadLine<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup> 模组实现的。</p><h2>前置条件</h2><p>Scoop<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup> 是 Windows 上的一款基于 PowerShell 的包管理器，接下来的软件都是用 Scoop 安装的，因为它能很方便地管理软件和配置环境变量。Scoop 的安装及使用不在本文的讨论范围内。</p><p>由于多数软件来源于 Github，在网络不好的情况下可能会安装失败，请自行配置网络代理。</p><p>以下命令用于在 PowerShell 中配置代理，请自行替换地址和端口号。</p><pre><code class="language-powershell">$Env:http_proxy=&quot;http://127.0.0.1:11223&quot;;
$Env:https_proxy=&quot;http://127.0.0.1:11223&quot;
</code></pre><p>Scoop 基于 Git，为了让 Scoop 能正常工作，请参考以下命令用于配置 Git 的代理。</p><pre><code class="language-bash">git config --global http.proxy http://127.0.0.1:11223
git config --global https.proxy https://127.0.0.1:11223
</code></pre><h2>安装 pwsh</h2><pre><code class="language-powershell">scoop install pwsh
</code></pre><h2>安装 Windows Terminal</h2><pre><code class="language-powershell">scoop install windows-terminal
</code></pre><h2>安装 Cascadia Code 字体</h2><p>部分命令行字符需要正确配置字体才能正常显示，安装字体需要管理员权限，注意授权提示。</p><p>更多命令行字符字体可参考 nerd-fonts<sup id="fnref-6"><a href="#fn-6" class="footnote-ref">6</a></sup> 项目。</p><pre><code class="language-powershell">scoop install sudo
scoop bucket add nerd-fonts
sudo scoop install CascadiaCode-NF-Mono
</code></pre><h2>在 Windows Terminal 中集成 pwsh</h2><p>在 Window Terminal 中添加一个新的终端配置。命名为「PWSH」，命令为<code>pwsh</code>。设置字体为「CaskaydiaCove NF」。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184401253.png" alt="image-20211124184401253"/></p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184424643.png" alt="image-20211124184424643"/></p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184447256.png" alt="image-20211124184447256"/></p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184503221.png" alt="image-20211124184503221"/></p><p>保存此配置，在「启动」选项卡中把刚刚新增的「PWSH」配置文件设置为默认配置文件。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184748158.png" alt="image-20211124184748158"/></p><p>打开 PWSH，配置完成。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124184925333.png" alt="image-20211124184925333"/></p><h2>安装 oh-my-posh3</h2><p>目前，在 oh-my-posh 的官方文档中使用的安装命令为<code>scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json</code>，请不要使用该命令。</p><p>oh-my-posh3 已存在于 Scoop 的 main 仓库中，请安装此软件包，后面的配置命令跟包名有关。</p><pre><code class="language-powershell">scoop install oh-my-posh3
</code></pre><p>接下来编写 PWSH 的用户配置，以下命令用于创建一个配置文件并用记事本打开。该配置文件的作用是在每次 pwsh 初始化的时候自动执行其中的命令。</p><pre><code class="language-powershell">if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }
notepad $PROFILE
</code></pre><p>在弹出的记事本里写入 oh-my-posh 的初始化命令，该命令会在每次 pwsh 初始化的时候执行。</p><pre><code class="language-powershell">$env:POSH_GIT_ENABLED = $true
oh-my-posh --init --shell pwsh --config &quot;$(scoop prefix oh-my-posh3)\themes\wopian.omp.json&quot; | Invoke-Expression
</code></pre><p>重新打开终端就能看到一个带主题的 PowerShell，如果有些字符显示不出来就是字体没有配置好。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124185954914.png" alt="image-20211124185954914"/></p><h2>配置历史命令提示</h2><p>在 PWSH 中执行命令，安装 PSReadLine 模组。在安装时请输入「Y」来确认安装。以下命令用于安装 PSReadLine，请在 PWSH 中执行而不是在 PowerShell 中。</p><pre><code class="language-powershell">Install-Module PSReadLine
</code></pre><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124194613000.png" alt="image-20211124194613000"/></p><p>然后编辑<code>$PROFILE</code>文件，在每次终端打开的时候对<code>PSReadLine</code>进行初始化。</p><pre><code class="language-powershell">notepad $PROFILE
</code></pre><p>在配置文件中附加上以下内容。</p><pre><code class="language-powershell">Set-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录
Set-PSReadlineKeyHandler -Key Tab -Function Complete # 设置 Tab 键补全
Set-PSReadLineKeyHandler -Key &quot;Ctrl+d&quot; -Function MenuComplete # 设置 Ctrl+d 为菜单补全和 Intellisense
Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo # 设置 Ctrl+z 为撤销
Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向上键为后向搜索历史记录
Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward # 设置向下键为前向搜索历史纪录
</code></pre><p>保存配置文件，重启终端，就能看到一个带历史命令提示的终端了。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124190601792.png" alt="image-20211124190601792"/></p><h2>更改 oh-my-posh 的主题</h2><p>oh-my-posh 提供了多套主题可供选择，在 PWSH 中执行以下命令对所有主题进行预览。</p><pre><code class="language-powershell">Get-ChildItem -Path &quot;$(scoop prefix oh-my-posh3)\themes\*&quot; -Include &#x27;*.omp.json&#x27; | Sort-Object Name | ForEach-Object -Process {
    $esc = [char]27
    Write-Host &quot;&quot;
    Write-Host &quot;$esc[1m$($_.BaseName)$esc[0m&quot;
    Write-Host &quot;&quot;
    oh-my-posh --config $($_.FullName) --pwd $PWD
    Write-Host &quot;&quot;
}
</code></pre><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124195044478.png" alt="image-20211124195044478"/></p><p>其中以<code>.omp</code>结尾的是主题文件的名称，如果需要使用某个主题就替换掉<code>$PROFILE</code>文件中初始化命令中的配置文件名就可以了。</p><p>以下命令用于用记事本打开<code>$PROFILE</code>文件。</p><pre><code class="language-powershell">notepad $PROFILE
</code></pre><p>在打开的记事本中你会看到 oh-my-posh 的初始化命令。</p><pre><code class="language-powershell">oh-my-posh --init --shell pwsh --config &quot;$(scoop prefix oh-my-posh3)\themes\wopian.omp.json&quot; | Invoke-Expression
</code></pre><p>将你中意的主题名称替换命令中的<code>wopian.omp</code>，保存该配置文件然后重启终端就可以看到新主题的效果了。</p><h2>更改 Windows Terminal 的配色</h2><p>在 Windows Terminal 中默认有多套配色方案可选，这里推荐一套自定义的配色方案，来自于 Dracula<sup id="fnref-7"><a href="#fn-7" class="footnote-ref">7</a></sup>。</p><p>在 Windows Terminal 的设置页面中，点击「打开 JSON 文件」，在该文件的<code>schemes</code>数组中添加一个配色方案对象。</p><pre><code class="language-json">&quot;schemes&quot;: [
    {
        &quot;name&quot;: &quot;Dracula&quot;,
        &quot;cursorColor&quot;: &quot;#F8F8F2&quot;,
        &quot;selectionBackground&quot;: &quot;#44475A&quot;,
        &quot;background&quot;: &quot;#282A36&quot;,
        &quot;foreground&quot;: &quot;#F8F8F2&quot;,
        &quot;black&quot;: &quot;#21222C&quot;,
        &quot;blue&quot;: &quot;#BD93F9&quot;,
        &quot;cyan&quot;: &quot;#8BE9FD&quot;,
        &quot;green&quot;: &quot;#50FA7B&quot;,
        &quot;purple&quot;: &quot;#FF79C6&quot;,
        &quot;red&quot;: &quot;#FF5555&quot;,
        &quot;white&quot;: &quot;#F8F8F2&quot;,
        &quot;yellow&quot;: &quot;#F1FA8C&quot;,
        &quot;brightBlack&quot;: &quot;#6272A4&quot;,
        &quot;brightBlue&quot;: &quot;#D6ACFF&quot;,
        &quot;brightCyan&quot;: &quot;#A4FFFF&quot;,
        &quot;brightGreen&quot;: &quot;#69FF94&quot;,
        &quot;brightPurple&quot;: &quot;#FF92DF&quot;,
        &quot;brightRed&quot;: &quot;#FF6E6E&quot;,
        &quot;brightWhite&quot;: &quot;#FFFFFF&quot;,
        &quot;brightYellow&quot;: &quot;#FFFFA5&quot;
    }
]
</code></pre><p>保存该 JSON 文件，重启 Windows Terminal，在 PWSH 的外观配置中选择新添加的 Dracula 配色方案。前文中我用的配色方案就是 Dracula。</p><p><img src="use-pwsh-and-oh-my-posh3-on-windows.assets/image-20211124202122113.png" alt="image-20211124202122113"/></p><h2>在 VS Code 里使用</h2><p>在 VS Code 的配置文件<code>settings.json</code>中加入以下配置。</p><pre><code class="language-json">&quot;terminal.integrated.profiles.windows&quot;: {
  &quot;Windows PowerShell&quot;: {
    &quot;path&quot;: &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot;
  },
  &quot;PWSH&quot;: {
    &quot;path&quot;: &quot;pwsh&quot;
  }
},
&quot;terminal.integrated.defaultProfile.windows&quot;: &quot;PWSH&quot;,
&quot;terminal.integrated.fontFamily&quot;: &quot;&#x27;CaskaydiaCove NF&#x27;&quot;
</code></pre><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://github.com/PowerShell/PowerShell">PowerShell/PowerShell: PowerShell for every system!</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://ohmyposh.dev/">Home | Oh My Posh</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://github.com/microsoft/terminal">microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place!</a><a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-4"><a href="https://github.com/PowerShell/PSReadLine">PowerShell/PSReadLine: A bash inspired readline implementation for PowerShell</a><a href="#fnref-4" class="footnote-backref">↩</a></li><li id="fn-5"><a href="https://scoop.sh/">Scoop</a><a href="#fnref-5" class="footnote-backref">↩</a></li><li id="fn-6"><a href="https://www.nerdfonts.com/">Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher</a><a href="#fnref-6" class="footnote-backref">↩</a></li><li id="fn-7"><a href="https://draculatheme.com/windows-terminal">Dark theme for Windows Terminal and 218+ apps — Dracula</a><a href="#fnref-7" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以容器的方式暴露 Docker Remote API 并启用 TLS]]></title>
        <id>以容器的方式暴露 Docker Remote API 并启用 TLS</id>
        <link href="https://iuok.me/blog/enable-docker-remote-api-with-tls-protection-via-container"/>
        <updated>2021-09-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>之前在「开启 Docker Remote API 并启用 TLS」<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 中记录过 Docker 暴露 Remote API 并配置 TLS 支持，虽然其中引用了别人的脚本来简化证书的签发步骤，但是在证书签发完成之后还是需要对 Docker 的启动命令进行修改，还是一个比较繁琐的步骤。</p><p>后来我发现了 docker-remote-api-tls<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 项目，它提供了一个 Docker 镜像，在运行镜像之后它会自动完成证书签发和 API 转发步骤。</p><h2>部署</h2><p>可以通过 Docker Compose 方便地启动这个容器，下面是<code>docker-compose.yml</code>文件的内容。</p><pre><code class="language-yaml">version: &quot;3&quot;
services:
  api:
    image: kekru/docker-remote-api-tls:v0.3.0
    ports:
      - 2376:443
    environment:
      - CREATE_CERTS_WITH_PW=dockercompose
      - CERT_EXPIRATION_DAYS=3650
      - CA_EXPIRATION_DAYS=36500
      - CERT_HOSTNAME=192.168.229.129.nip.io
    volumes:
      - /root/compose/docker-remote-api-with-tls/certs:/data/certs
      - /var/run/docker.sock:/var/run/docker.sock:ro
    restart: unless-stopped
</code></pre><p>有以下几点需要注意：</p><ol><li>第 6 行，容器内的端口是 443，需要映射到容器外 2376 端口；</li><li>第 8 行，<code>CREATE_CERTS_WITH_PW</code>设置证书密码；</li><li>第 9 行，<code>CERT_EXPIRATION_DAYS</code>设置证书过期时间，默认 365 天；</li><li>第 10 行，<code>CA_EXPIRATION_DAYS</code>设置 CA 证书过期时间，默认 900 天；</li><li>第 11 行，<code>CERT_HOSTNAME</code>设置域名，如果没有域名可以用 nip.io<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup> 来得到一个可以解析到任意 IP 的域名。形如<code>192.168.229.129.nip.io</code>的域名会被解析至<code>192.168.229.129</code>；还有其他形式的域名可以在 nip.io 网站中查看；</li><li>第 13 行，挂载证书目录，首次启动时证书会被自动创建并存放在此目录中；</li><li>第 14 行，挂载<code>docker.sock</code>。</li></ol><p>通过<code>docker compose up -d</code>启动容器。根据配置，证书会被自动创建在<code>/root/compose/docker-remote-api-with-tls/certs</code>目录中。</p><p>该目录的结构如下：</p><pre><code>certs/
├── ca-cert.pem
├── ca-key.pem
├── client
│   ├── ca.pem
│   ├── cert.pem
│   └── key.pem
├── server-cert.pem
└── server-key.pem
</code></pre><p>其中，客户端需要的证书文件存放在<code>client</code>目录中。此时 Docker Remote API 已经暴露在 2376 端口，客户端可以使用证书文件来通过认证。</p><p>如果需要重新签发证书文件，只需要清空<code>certs</code>文件夹并重启容器即可。</p><h2>补充</h2><p>国内的 IP 请使用已备案域名，不然可能会被阻断，导致连接不上。</p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="./enable-docker-remote-api-with-tls-protection.md">开启 Docker Remote API 并启用 TLS</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://github.com/kekru/docker-remote-api-tls">kekru/docker-remote-api-tls: Docker Image that forwards to the Docker API Socket and requires TLS Client authentication</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://nip.io/">nip.io - wildcard DNS for any IP Address</a><a href="#fnref-3" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开启 Docker Remote API 并启用 TLS]]></title>
        <id>开启 Docker Remote API 并启用 TLS</id>
        <link href="https://iuok.me/blog/enable-docker-remote-api-with-tls-protection"/>
        <updated>2021-09-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>Portainer<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 是一款 Docker 可视化管理面板，它不仅可以管理本地的 Docker 实例，还可以通过 Docker Remote API 访问管理远程 Docker 资源。Docker Remote API 就是通过 HTTP 协议暴露 Docker 资源，启用 TLS 可以实现远程访问鉴权。</p><p>Docker 的官方文档提供了详细的开启 Docker Remote API 和开启 TLS 的教程 <sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>。但是在签发证书的过程中涉及到的命令比较多，且繁琐，我就从网络上寻找到了别人写好的签发证书的脚本 <sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup>，可以很方便地替代纯手工操作。</p><p>本文中的操作都在 CentOS 7 中完成。</p><h2>签发证书</h2><p>将脚本命名为<code>auto-tls-certs.sh</code>。其中需要配置的内容有：</p><ol><li><code>CODE</code>，作为文件名的后缀，用于区分文件；</li><li><code>IP</code>，机器的公网 IP 地址；</li><li><code>PASSWORD</code>，证书密码。</li></ol><p>脚本内容如下：</p><pre><code class="language-bash">#!/bin/bash
#
# -------------------------------------------------------------
# 自动创建 Docker TLS 证书
# -------------------------------------------------------------

# 以下是配置信息
# --[BEGIN]------------------------------

CODE=&quot;tx&quot;
IP=&quot;1.1.1.1&quot;
PASSWORD=&quot;pass&quot;

COUNTRY=&quot;CN&quot;
STATE=&quot;BEIJING&quot;
CITY=&quot;BEIJING&quot;
ORGANIZATION=&quot;Org&quot;
ORGANIZATIONAL_UNIT=&quot;Dev&quot;
COMMON_NAME=&quot;$IP&quot;
EMAIL=&quot;.&quot;

# --[END]--

# Generate CA key
openssl genrsa -aes256 -passout &quot;pass:$PASSWORD&quot; -out &quot;ca-key-$CODE.pem&quot; 4096
# Generate CA
openssl req -new -x509 -days 365 -key &quot;ca-key-$CODE.pem&quot; -sha256 -out &quot;ca-$CODE.pem&quot; -passin &quot;pass:$PASSWORD&quot; -subj &quot;/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$COMMON_NAME/emailAddress=$EMAIL&quot;
# Generate Server key
openssl genrsa -out &quot;server-key-$CODE.pem&quot; 4096

# Generate Server Certs.
openssl req -subj &quot;/CN=$COMMON_NAME&quot; -sha256 -new -key &quot;server-key-$CODE.pem&quot; -out server.csr

echo &quot;subjectAltName = IP:$IP,IP:127.0.0.1&quot; &gt;&gt; extfile.cnf
echo &quot;extendedKeyUsage = serverAuth&quot; &gt;&gt; extfile.cnf

openssl x509 -req -days 365 -sha256 -in server.csr -passin &quot;pass:$PASSWORD&quot; -CA &quot;ca-$CODE.pem&quot; -CAkey &quot;ca-key-$CODE.pem&quot; -CAcreateserial -out &quot;server-cert-$CODE.pem&quot; -extfile extfile.cnf

# Generate Client Certs.
rm -f extfile.cnf

openssl genrsa -out &quot;key-$CODE.pem&quot; 4096
openssl req -subj &#x27;/CN=client&#x27; -new -key &quot;key-$CODE.pem&quot; -out client.csr
echo extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf
openssl x509 -req -days 365 -sha256 -in client.csr -passin &quot;pass:$PASSWORD&quot; -CA &quot;ca-$CODE.pem&quot; -CAkey &quot;ca-key-$CODE.pem&quot; -CAcreateserial -out &quot;cert-$CODE.pem&quot; -extfile extfile.cnf

rm -vf client.csr server.csr

chmod -v 0400 &quot;ca-key-$CODE.pem&quot; &quot;key-$CODE.pem&quot; &quot;server-key-$CODE.pem&quot;
chmod -v 0444 &quot;ca-$CODE.pem&quot; &quot;server-cert-$CODE.pem&quot; &quot;cert-$CODE.pem&quot;

# 打包客户端证书
mkdir -p &quot;tls-client-certs-$CODE&quot;
cp -f &quot;ca-$CODE.pem&quot; &quot;cert-$CODE.pem&quot; &quot;key-$CODE.pem&quot; &quot;tls-client-certs-$CODE/&quot;
cd &quot;tls-client-certs-$CODE&quot;
tar zcf &quot;tls-client-certs-$CODE.tar.gz&quot; *
mv &quot;tls-client-certs-$CODE.tar.gz&quot; ../
cd ..
rm -rf &quot;tls-client-certs-$CODE&quot;

# 拷贝服务端证书
mkdir -p /etc/docker/certs.d
cp &quot;ca-$CODE.pem&quot; &quot;server-cert-$CODE.pem&quot; &quot;server-key-$CODE.pem&quot; /etc/docker/certs.d/
</code></pre><p>使用<code>sh auto-tls-certs.sh</code>命令来生成证书，并且生成好的证书会被自动打包为<code>.tar.gz</code>归档，非常方便。下面的图片展示了执行脚本后生成的文件列表。</p><p><img src="./enable-docker-remote-api-with-tls-protection.assets/image-20210816222131111-16291236956091.png" alt="image-20210816222131111-16291236956091"/></p><h2>配置 Docker</h2><p>只需关注<code>.pem</code>文件，把证书找个专门的位置存放。</p><pre><code class="language-bash">mkdir /etc/.docker
cp ~/docker-cert/*.pem /etc/.docker/
</code></pre><p>修改 Docker 启动文件。</p><pre><code class="language-bash">nano /lib/systemd/system/docker.service
</code></pre><p>修改<code>Service</code>下的<code>ExecStart</code>配置。</p><pre><code class="language-systemd">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -D -H tcp://0.0.0.0:2376 --tlsverify --tlscacert=/etc/.docker/ca-tx.pem --tlscert=/etc/.docker/server-cert-tx.pem --tlskey=/etc/.docker/server-key-tx.pem
</code></pre><p><img src="./enable-docker-remote-api-with-tls-protection.assets/image-20210816222434122-16291238760702.png" alt="image-20210816222434122-16291238760702"/></p><p>重启 Docker。</p><pre><code class="language-bash">systemctl daemon-reloadservice docker restart
</code></pre><h2>开放端口</h2><p>在防火墙、安全组中放行 2376 端口。</p><h2>测试</h2><p>把证书的压缩包<code>tls-client-certs-tx.tar.gz</code>下载到本机，解压得到证书文件。</p><p><img src="./enable-docker-remote-api-with-tls-protection.assets/image-20210816222527037.png" alt="image-20210816222527037"/></p><p>用<code>curl</code>命令测试，如果有 JSON 格式的信息输出则配置成功。</p><pre><code class="language-bash">curl https://你的 IP/info --cert cert-tx.pem --key key-tx.pem --cacert ca-tx.pem
</code></pre><p><img src="./enable-docker-remote-api-with-tls-protection.assets/image-20210816222600935-16291239626163.png" alt="image-20210816222600935-16291239626163"/></p><h2>用 Portainer 连接</h2><p>Portainer 是一款非常好用的 Docker 可视化管理工具，通过暴露 Docker Remote API 可以远程连接并管理 Docker 资源。</p><p>在<code>Endpoints</code>页面中点击<code>Add endpoint</code>，<code>Environment type</code>选择<code>Docker</code>。</p><p>在对应的输入框中填写 IP 地址和端口号，开启 TLS，选择三个对应的证书文件。</p><p><img src="./enable-docker-remote-api-with-tls-protection.assets/image-20210816222733033-16291240547284.png" alt="image-20210816222733033-16291240547284"/></p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://documentation.portainer.io/">Documentation</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://docs.docker.com/engine/security/protect-access/">Protect the Docker daemon socket | Docker Documentation</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://www.gaoyaxuan.net/blog/324.html">Docker 开启 TLS 访问，更加安全 - 实用教程 - 高亚轩的 BLOG</a><a href="#fnref-3" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSH 密钥登录]]></title>
        <id>SSH 密钥登录</id>
        <link href="https://iuok.me/blog/ssh-certificate-authentication"/>
        <updated>2021-09-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><blockquote><p>SSH 默认采用密码登录，这种方法有很多缺点，简单的密码不安全，复杂的密码不容易记忆，每次手动输入也很麻烦。密钥登录是比密码登录更好的解决方案。<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup></p></blockquote><h2>生成秘钥</h2><p>可以用 OpenSSH 中的<code>ssh-keygen</code>命令行工具来生成秘钥。<code>-t</code>参数指定了加密方式，通常为<code>rsa</code>或<code>dsa</code>。</p><pre><code class="language-bash">ssh-keygen -t rsa
</code></pre><p>生成的密钥文件默认就会是<code>~/.ssh/id_rsa</code>（私钥）和<code>~/.ssh/id_rsa.pub</code>（公钥）。</p><p>也可以用 PuTTY 中提供的 PuTTY Key Generator（puttygen.exe）<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 来用可视化用户界面来生成秘钥文件。</p><p><img src="./ssh-certificate-authentication.assets/image-20210816230720070.png" alt="image-20210816230720070"/></p><h2>把公钥放在服务器上</h2><p>用户公钥保存在<code>~/.ssh/authorized_keys</code>文件中，如果该文件不存在，你可以手动创建一个。</p><p>然后将公钥的文本内容放入其中，每行一个。</p><h2>关闭密码登录</h2><p>编辑<code>/etc/ssh/sshd_config</code>文件，找到对应的配置项并修改。</p><pre><code class="language-ini"># 不允许密码直接登录
PasswordAuthentication no
# 不允许空密码登录
PermitEmptyPasswords no
# 不允许交互式密码登录
ChallengeResponseAuthentication no
# 不允许 root 用户使用密码登录
PermitRootLogin prohibit-password
# 使用秘钥登录
PubkeyAuthentication yes
</code></pre><p>重启<code>sshd</code>，让配置生效。</p><pre><code class="language-bash">sudo systemctl restart sshd
</code></pre><h2>测试配置是否生效</h2><p>使用<code>ssh</code>命令连接远程服务器，使用<code>-i</code>参数传递私钥文件。</p><pre><code class="language-bash">ssh -i .\centos7\.vagrant\machines\default\virtualbox\private_key vagrant@192.168.33.12
</code></pre><h2>参考资料</h2><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server">How To Configure SSH Key-Based Authentication on a Linux Server | DigitalOcean</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-using_openssh_certificate_authentication">14.3. Using OpenSSH Certificate Authentication Red Hat Enterprise Linux 6 | Red Hat Customer Portal</a></li></ul><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://wangdoc.com/ssh/key.html">SSH 密钥登录 - SSH 教程 - 网道</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">Download PuTTY: latest release (0.76)</a><a href="#fnref-2" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用 Github Actions 部署 Vuepress 项目到 Github Pages]]></title>
        <id>利用 Github Actions 部署 Vuepress 项目到 Github Pages</id>
        <link href="https://iuok.me/blog/deploy-vuepress-project-to-github-pages-with-github-actions"/>
        <updated>2021-08-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>Vuepress<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 是一个基于 Vue 的静态网站生成器；Github Pages<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 是 Github 提供的免费的静态网站托管服务；Github Actions<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup> 是 Github 仓库中集成的 CI/CD<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup> 服务。</p><p>Vuepress 是一个 Node.js 项目，它可以根据配置将 Markdown 文件转为 HTML 文件。你可以将输出的静态文件托管在 Github Pages 中，这样你就得到了一个可以访问的域名来展示这些静态的 HTML 文件。</p><p>传统的做法是在本地安装好 Noed.js 环境，自己手动构建项目之后将构建产物上传到 Github 仓库，从而触发 Github Pages 的构建。现在可以利用 Github Actions 来代替手工劳动，Github Actions 可以自动被触发，它运行在 Github 提供的虚拟环境中，可以执行一系列任务从而代替重复枯燥的手动构建和部署的步骤。</p><h2>创建 Github 仓库</h2><p>在创建的 Github 仓库时要注意仓库名称，假如你的用户名是 foo。</p><p>如果你创建了一个名为<code>foo.github.io</code>的仓库，你将可以通过<code>https://foo.github.io</code>来访问此仓库的 Github Pages 内容；</p><p>如果你创建其他名称的仓库如<code>bar</code>，你可以通过<code>https://foo.github.io/bar/</code>来访问此仓库的 Github Pages 内容。</p><p>你可以根据你期望的访问方式来选择仓库名称。</p><h2>配置 Github Actions</h2><p>Github Actions 的配置文件应该放在项目根目录下的<code>.github/workflows/</code>文件夹中，你可以在一个项目中配置多个 Actions。配置文件是 YAML 格式，文件名形如<code>*.yml</code>。</p><p>每一个 Action 中可以包括多个 job，每个 job 可以包括多个 step。在 step 中你可以直接运行命令，或者引用其他人编写好的 Action 脚本。在本文的配置文件中，我们引用了 github-pages-deploy-action<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup> 来完成 Github Pages 部署，而不用关系其实现细节。</p><p>完成本文目标的 Github Actions 配置文件内容如下。</p><pre><code class="language-yaml">name: &quot;github actions build and deploy gh-pages&quot;
on:
  push:
    branches:
      - master
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2.3.1
        with:
          persist-credentials: false
      - name: install and build
        run: |
          npm install
          npm run build
      - name: Deploy
        uses: JamesIves/github-pages-deploy-action@4.1.4
        with:
          BRANCH: gh-pages
          FOLDER: docs/.vuepress/dist
</code></pre><p>其中的一些关键配置解释如下。</p><ul><li><code>on.push.branches</code>，在推送到<code>master</code>分支时触发此 Action；</li><li><code>jobs.build-and-deploy</code>，在一个 Action 中可以有多个 job，这是其中的一个，名称是自己取的；每个任务可以有多个 step；</li><li><code>jobs.build-and-deploy.steps[0]</code>，用<code>actions/checkout</code>检出仓库内容；</li><li><code>jobs.build-and-deploy.steps[1]</code>，执行<code>npm</code>命令安装开发环境；</li><li><code>jobs.build-and-deploy.steps[2]</code>，用<code>JamesIves/github-pages-deploy-action</code>部署<code>docs/.vuepress/dist</code>文件夹中的内容到<code>gh-pages</code>分支中。</li></ul><p>在编写好配置文件后可以提交并推送文件至 master 分支，这会自动触发 Action 的执行，并且你可以在 Actions 栏目中查看执行日志。</p><p><img src="./deploy-vuepress-project-to-github-pages-with-github-actions.assets/image-20210824225724791.png" alt="image-20210824225724791"/></p><h2>配置 Github Pages</h2><p>我们的构建产物放在 gh-pages 分支，我们需要告诉 Github Pages 源文件位置。</p><p>在 Github 仓库的 Settings 栏目中，从左侧的设置导航栏找到 Pages 设置。在这里你可以设置 gh-pages 为数据源。</p><p><img src="./deploy-vuepress-project-to-github-pages-with-github-actions.assets/image-20210824230246146.png" alt="image-20210824230246146"/></p><p>如果没出错的话，在配置完成之后你就可以通过 Github Pages 给你提供的域名来访问你的静态网站了。</p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://v2.vuepress.vuejs.org/zh/">首页 | VuePress</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://pages.github.com/">GitHub Pages | Websites for you and your projects, hosted directly from your GitHub repository. Just edit, push, and your changes are live.</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://docs.github.com/en/actions/learn-github-actions">Learn GitHub Actions - GitHub Docs</a><a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-4"><a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd">什么是 CI/CD？一文带你理解 CI 持续集成和 CD 持续交付/部署 - 红帽</a><a href="#fnref-4" class="footnote-backref">↩</a></li><li id="fn-5"><a href="https://github.com/JamesIves/github-pages-deploy-action">JamesIves/github-pages-deploy-action: Automatically deploy your project to GitHub Pages using GitHub Actions. This action can be configured to push your production-ready code into any branch you&#x27;d like.</a><a href="#fnref-5" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Vant Weapp 自定义微信小程序 TabBar]]></title>
        <id>使用 Vant Weapp 自定义微信小程序 TabBar</id>
        <link href="https://iuok.me/blog/customize-wechat-mini-program-tabbar-with-vant-weapp"/>
        <updated>2020-12-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>微信小程序原生的 TabBar 虽然设置简单，但是样式不好看，也不能使用字体图标，但是微信小程序有自定义 TabBar 的机制。</p><p>Vant WeApp<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 是有赞出品的针对微信小程序的一套开源组件库，结合 van-tabbar<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 和微信的自定义 TabBar 机制 <sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup> 可以实现一套比较好看的 TabBar。</p><h2>新建 custom-tab-bar 组件</h2><p>如图所示，在微信小程序工程文件夹根目录下新建一个名为 <code>custom-tab-bar</code> 的组件。</p><p><img src="./customize-wechat-mini-program-tabbar-with-vant-weapp.assets/image-5.png" alt="img"/></p><p>其中各个文件中的代码如下：</p><pre><code class="language-json">{
  &quot;component&quot;: true,
  &quot;usingComponents&quot;: {
    &quot;van-tabbar&quot;: &quot;@vant/weapp/tabbar/index&quot;,
    &quot;van-tabbar-item&quot;: &quot;@vant/weapp/tabbar-item/index&quot;
  }
}
</code></pre><pre><code class="language-javascript">// custom-tab-bar/index.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {},

  /**
   * 组件的初始数据
   */
  data: {
    active: -1,
    list: [{
        icon: &quot;search&quot;,
        text: &quot;搜索&quot;,
        url: &quot;/pages/index/index&quot;,
      },
      {
        icon: &quot;question-o&quot;,
        text: &quot;答题&quot;,
        url: &quot;/pages/question/index&quot;,
      },
      {
        icon: &quot;ellipsis&quot;,
        text: &quot;关于&quot;,
        url: &quot;/pages/user/index&quot;,
      },
    ],
  },

  /**
   * 组件的方法列表
   */
  methods: {
    onChange(event) {
      wx.switchTab({
        url: this.data.list[event.detail].url,
      });
    },

    init() {
      const {
        route
      } = getCurrentPages().pop();
      const active = this.data.list.findIndex(
        (item) =&gt; item.url === `/${route}`
      );
      console.log(&quot;active:&quot;, active);
      this.setData({
        active,
      });
    },
  },
});
</code></pre><pre><code class="language-xml">&lt;!-- custom-tab-bar/index.wxml --&gt;
&lt;van-tabbar active=&quot;{{ active }}&quot; bind:change=&quot;onChange&quot;&gt;
    &lt;van-tabbar-item wx:for=&quot;{{list}}&quot; wx:key=&quot;index&quot; icon=&quot;{{item.icon}}&quot;&gt;
        {{item.text}}
    &lt;/van-tabbar-item&gt;
&lt;/van-tabbar&gt;
</code></pre><h2>启用自定义 TabBar 设置</h2><p>修改 <code>app.js</code> 中 <code>tabBar</code> 设置，设置 <code>custom</code> 为 <code>true</code>。其中 <code>list</code> 中的对象只需保留 <code>path</code> 属性。</p><p><img src="./customize-wechat-mini-program-tabbar-with-vant-weapp.assets/image-6-668x1024.png" alt="img"/></p><h2>在每个 Tab 页中配置</h2><p>在开启了自定义 TabBar 设置后，可以在每个页面中通过 <code>getTabBar()</code> 获取 TabBar 组件实例。</p><p>现在需要在每个 Tab 页中设置当前 Tab 页图标高亮。</p><p>可以在每个 Tab 页的 <code>onShow()</code> 生命周期方法中调用 TabBar 的 <code>init()</code> 方法，修改当前激活页，来高亮当前 Tab 页的图标。</p><pre><code class="language-javascript">/**
* 生命周期函数--监听页面显示
*/
onShow: function () {
  this.getTabBar().init();
},
</code></pre><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://vant-contrib.gitee.io/vant/#/zh-CN/">Vant - 轻量、可靠的移动端组件库 (gitee.io)</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://vant-contrib.gitee.io/vant-weapp/#/tabbar">Tabbar 标签栏 - Vant Weapp</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html">自定义 tabBar | 微信开放文档</a><a href="#fnref-3" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题]]></title>
        <id>解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题</id>
        <link href="https://iuok.me/blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea"/>
        <updated>2020-12-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>在用 IntelliJ IDEA 运行 Java Web 项目时，在 Tomcat 的日志输出区域会出现乱码，效果如下图所示。</p><p>在网络上查了一些资料 <sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>，记录下解决办法。</p><p><img src="./solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea.assets/image-1024x475.png" alt="Tomcat 日志出现乱码"/></p><h2>原因分析</h2><p>可能是因为 IDEA 控制台中所采用的字符编码与 Tomcat 输出所采用的字符编码不一致，导致了出现乱码。</p><p>IDEA 控制台输出采用的是 GBK 编码，Tomcat 输出采用的是 UTF-8 编码。</p><h2>解决办法</h2><h3>法一：修改 IDEA 控制台输出编码为 UTF-8</h3><p>在 IDEA 的上方工具栏中，依次选择<code>Help</code>-&gt;<code>Edit Custome VM Options...</code>。</p><p><img src="./solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea.assets/image-1.png" alt="img"/></p><p>在<code>vmoptions</code>中添加如下一行参数，之后重启 IDEA。</p><pre><code class="language-bash">-Dfile.encoding=UTF-8
</code></pre><p>该文件实际位于<code>C:\Users\&lt;用户名&gt;\AppData\Roaming\JetBrains\IntelliJIdea2020.3\idea64.exe.vmoptions</code>，所以直接修改此文件应该也可行。</p><p><img src="./solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea.assets/image-2.png" alt="img"/></p><h3>法二：修改 Tomcat 输出编码为 GBK</h3><p>在 Tomcat 安装位置下的 conf 文件中存在<code>logging.properties</code>配置文件。</p><p>修改其中的配置，将<code>java.util.logging.ConsoleHandler.encoding</code>的属性由<code>UTF-8</code>改为<code>GBK</code>。</p><p>保存之后重启 Tomcat 即可。</p><p><img src="./solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea.assets/image-4-1024x907.png" alt="img"/></p><h2>结果</h2><p>两种方法均可以解决问题。</p><p><img src="./solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea.assets/image-3-1024x491.png" alt="img"/></p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://www.cnblogs.com/shej123/p/10312806.html">idea tomcat 乱码问题的解决及相关设置 - 行而思 - 博客园</a><a href="#fnref-1" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用 Windows Terminal 和 oh-my-posh 打造一个好用的终端]]></title>
        <id>用 Windows Terminal 和 oh-my-posh 打造一个好用的终端</id>
        <link href="https://iuok.me/blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh"/>
        <updated>2020-02-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[补充]]></summary>
        <content type="html"><![CDATA[<h2>补充</h2><p>oh-my-posh 项目已被重构，现在由 Go 语言实现，详情见 <a href="https://github.com/JanDeDobbeleer/oh-my-posh">Github</a>。</p><p>文章中所使用的版本现已被重命名为 oh-my-posh2，由 PowerShell 实现，详情见 <a href="https://github.com/JanDeDobbeleer/oh-my-posh2">Github</a>。</p><p>oh-my-posh3 的安装请参考 <a href="use-pwsh-and-oh-my-posh3-on-windows.md">Windows Terminal + PWSH + oh my posh3 + PSReadLine 打造一个好用的终端</a>，<strong>下面的内容已过时</strong>。</p><h2>前言</h2><p>Windows 中自带的终端使用体验确实说不上好，尝试了许多组合也感觉都不顺手。这次试试微软亲自出的 Windows Terminal<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>，再加上 oh-my-posh<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 插件。</p><h2>正文</h2><h3>安装 Windows Terminal</h3><p>Windows Terminal 提供多种安装方式，你可以在 Microsoft Store 中安装；可以自行在该项目的 Github 仓库 <sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 中上下载安装程序；虽然官方文档未提及，但是你也可以用 Scoop<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup> 安装：</p><pre><code class="language-powershell">scoop install windows-terminal
</code></pre><h3>安装 oh-my-posh</h3><p>oh-my-posh 是针对 Windows PowerShell 设计的主题引擎，类似于 zsh 和 Oh My Zsh 的关系。它可以让你的命令行更强大。</p><p>打开 PowerShell，输入以下命令安装：</p><pre><code class="language-powershell">Install-Module posh-git -Scope CurrentUser
Install-Module oh-my-posh -Scope CurrentUser
</code></pre><p>安装完成之后还更改 PowerShell 的用户配置，让它每次启动的时候自动加载 oh-my-posh 插件；执行以下命令：</p><pre><code class="language-powershell">if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }
notepad $PROFILE
</code></pre><p>不出意外的话接下来会出现记事本，你需要在里面写上以下内容：</p><pre><code class="language-powershell">Import-Module posh-git
Import-Module oh-my-posh
Set-Theme Paradox
</code></pre><p>保存该文件，重新打开 PowerShell 你就能看到一个发生改变了的 PowerShell 。</p><p><img src="./build-a-decent-terminal-with-windows-terminal-and-oh-my-posh.assets/vMcBOyiREC-1024x523.png" alt="img"/></p><p>oh-my-posh 提供了几组预设的主题供你选择，你可以通过 <code>Set-Theme</code> 命令来更改当前主题，可选的值有 <code>Agnoster</code>/<code>Paradox</code>/<code>Sorin</code>/<code>Darkblood</code>/<code>Avit</code>/<code>Honukai</code>/<code>Fish</code>/<code>Robbyrussell</code>。</p><p><img src="./build-a-decent-terminal-with-windows-terminal-and-oh-my-posh.assets/sA8iXJPC2j.png" alt="img"/></p><p>这个主题设置只在当前会话生效，为了每次启动 PowerShell 的时候都能加载你想要的主题，你还需要修改以下用户配置文件，就像上一个步骤中做的一样，只需要修改 <code>Set-Theme</code> 命令的部分即可。</p><h3>用上微软的 Cascadia Code 字体</h3><p>或许你已经发现了有些字符显示不正常，那是因为默认的字体没有内嵌这些字符的形状，你还需要换一个字体。</p><p>微软的另一个开源项目，Cascadia Code<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup> 就是一款适用于终端和代码展示的字体，你可以使用 Scoop 来安装它；安装字体的时候需要使用到管理员权限，你可以使用 <code>sudo</code> 命令，或者用管理员权限重新打开 PowerShell，再执行安装。</p><p>在安装之前，你可能需要添加一下 <code>nerd-fonts</code> 仓库，因为字体软件的元信息都存放于这个仓库中。</p><pre><code class="language-powershell">scoop bucket add nerd-fonts
</code></pre><p>在 Scoop 的仓库中存在着好几个版本的 Cascadia Code，其中：</p><ul><li><code>Cascadia-Code</code>是原版不带 Powerline 字符的；</li><li><code>Cascadia-PL</code>是微软出品的，自带 Powerline 字符的；</li><li><code>CascadiaCode-NF</code>是 Nerd Fonts<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup> 项目出品的，后期补丁了大量 Powerline 字符。</li></ul><p>没有特殊需求的话可以选择官方出的轻量级的 <code>Cascadia-PL</code>，执行以下命令：</p><pre><code class="language-powershell">sudo scoop install Cascadia-PL
</code></pre><p>安装完成之后还需设置以下，指定 Windows Terminal 使用该字体。</p><p>目前 Windows Terminal 没有专门的设置界面，所有的配置项都在 <code>profiles.json</code> 配置文件里；在配置文件的对应地方设置 <code>fontFace</code> 的值为 <code>Cascadia Code PL</code>：</p><pre><code class="language-json">// ...
&quot;defaults&quot;:
{
    // Put settings here that you want to apply to all profiles
    &quot;fontFace&quot;: &quot;Cascadia Code PL&quot;
},
// ...
</code></pre><p>保存配置文件后就能使配置文件生效；此时所有字符应该能正常显示了。</p><p><img src="./build-a-decent-terminal-with-windows-terminal-and-oh-my-posh.assets/vjPXgPO7AB-1024x523.png" alt="img"/></p><h3>集成 Git Bash</h3><p>首先将 Git 安装目录下的 <code>bin</code> 目录加入 <code>Path</code> 环境变量，如果你是用 Scoop 安装的 Git，则可以忽略此步骤，因为 Scoop 已经帮你完成了这个工作；然后修改 Windows Terminal 的配置文件，在 <code>profiles</code>-&gt;<code>list</code> 中新增一条配置：</p><pre><code class="language-json">// ...
&quot;list&quot;:
[

    {
        &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff4411}&quot;,
        &quot;name&quot;: &quot;Git Bash&quot;,
        &quot;commandline&quot;: &quot;bash.exe&quot;,
        &quot;hidden&quot;: false,
        &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot;
    }
]
// ...
</code></pre><p>注意 JSON 的语法格式，在列表中不要少加或者多加逗号。保存配置文件之后就能在 Windows Terminal 中快捷启动 Git Bash 了。</p><p><img src="./build-a-decent-terminal-with-windows-terminal-and-oh-my-posh.assets/SI7S9fkaKG-1024x523.png" alt="img"/></p><h2>后记</h2><p>新的 Windows Terminal 使用体验还是挺不错的，颜值也 OK，折腾一下也挺好用的。</p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://github.com/microsoft/terminal">microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place!</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://github.com/JanDeDobbeleer/oh-my-posh2">JanDeDobbeleer/oh-my-posh2: A prompt theming engine for Powershell</a><a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://github.com/lukesampson/scoop">lukesampson/scoop: A command-line installer for Windows.</a><a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-4"><a href="https://github.com/microsoft/cascadia-code">microsoft/cascadia-code: This is a fun, new monospaced font that includes programming ligatures and is designed to enhance the modern look and feel of the Windows Terminal.</a><a href="#fnref-4" class="footnote-backref">↩</a></li><li id="fn-5"><a href="https://github.com/ryanoasis/nerd-fonts">ryanoasis/nerd-fonts: Iconic font aggregator, collection, &amp; patcher. 3,600+ icons, 50+ patched fonts: Hack, Source Code Pro, more. Glyph collections: Font Awesome, Material Design Icons, Octicons, &amp; more</a><a href="#fnref-5" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《求生之路 2》制作动态喷漆]]></title>
        <id>《求生之路 2》制作动态喷漆</id>
        <link href="https://iuok.me/blog/making-dynamic-spray-paint-for-left-4-dead-2"/>
        <updated>2017-08-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/kana.gif" alt="img"/></p><p>动态的喷漆也是这个游戏的乐趣之一，尝试自己制作一下动态喷漆，将 GIF 图片转换为可以在游戏中使用的动态喷涂文件。</p><p>文中使用的工具和成品可以从 <a href="https://zfile.iuok.me/directlink/1/articles/making-dynamic-spray-paint-for-left-4-dead-2/tools.zip">这里</a> 下载。</p><h2>准备工作</h2><ol><li>一张 GIF 图片；</li><li>GIF 图片分解工具，用于把动态图的每一帧分解出来，文中使用的是 GifSplitter<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>；</li><li>VTFEdit<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>，核心工具，用于制作 VTF 格式的动态图。</li></ol><h2>分解 GIF</h2><p>这里使用的是 GifSplitter，目的是将 GIF 图片的每一帧都分解出来；其他功能类似的软件和在线工具都可以。</p><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/gifsplitter.png" alt="img"/></p><h2>制作 VTF</h2><p>打开 VTFEdit，点击左上角的 「导入」 按钮，选择并导入上一步中分离出来的所有图片。</p><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/import.png" alt="img"/></p><p>接下来设置贴图尺寸，选中 「限定贴图尺寸」，高度和宽度都设置为 128，其他设置保持默认。</p><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/options.png" alt="img"/></p><p>再切换到 「信息」 页中，查看文件大小；<strong>要确保其小于 512KB，否则无法喷出</strong>。如果文件太大的话，就把要导入的图片删除一些，再重复这些步骤，直至满足条件。</p><p>再满足条件之后就可以保存了，保存的时候注意<strong>不要使用中文文件名</strong>，不然在游戏里浏览文件的时候中文名会乱码。</p><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/save.png" alt="img"/></p><h2>在游戏中导入</h2><p>打开游戏，在游戏设置中依次找到 「导入喷漆图案」，选择上一步中制作好的 VTF 文件。</p><p><img src="./making-dynamic-spray-paint-for-left-4-dead-2.assets/import-to-game.png" alt="img"/></p><h2>后记</h2><p>整个制作过程也不复杂，核心工具是 VTFEdit；至于分解 GIF 的工具就很多了，可以很灵活地选择其他软件来完成这个任务。</p><p>最重要的是控制文件大小，不能超过限制，不然在游戏中无法使用。如果文件大小太大的话可以考虑在分解出的图片中删除一些图片，来达到减小文件大小的目的。比如可以隔帧删除，每隔一张图片就删除一张图片，应该会很有效。</p><div class="footnotes"><hr/><ol><li id="fn-1"><a href="https://www.xoyosoft.com/gs/">GifSplitter - Break GIF animation down into individual image frames</a><a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2"><a href="https://developer.valvesoftware.com/wiki/VTFEdit">VTFEdit - Valve Developer Community</a><a href="#fnref-2" class="footnote-backref">↩</a></li></ol></div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[获取天翼光猫 F412 超级管理员帐号密码]]></title>
        <id>获取天翼光猫 F412 超级管理员帐号密码</id>
        <link href="https://iuok.me/blog/get-super-admin-password-of-f412"/>
        <updated>2017-06-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[开启 telnet 服务]]></summary>
        <content type="html"><![CDATA[<h2>开启 telnet 服务</h2><p>控制面板 -&gt; 所有控制面板项 -&gt; 程序和功能 -&gt; 启用或关闭 Windows 功能。</p><h2>获取帐号密码</h2><ol><li>打开 cmd，输入命令：<code>telnet 192.168.1.1</code></li><li>登录帐号：<code>root</code></li><li>登录密码：<code>Zte521</code></li><li>输入命令：<code>sendcmd 1 DB p UserInfo</code></li></ol>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重置 MySQL root 密码]]></title>
        <id>重置 MySQL root 密码</id>
        <link href="https://iuok.me/blog/reset-mysql-root-password"/>
        <updated>2017-01-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>注意：如果你的数据库中存有重要数据，请在保证机器离线的情况下进行以下的操作，最稳妥的办法就是拔掉网线！</p><h2>方法一：修改配置文件</h2><h3>开启安全模式</h3><p>修改 MySQL 的配置文件。</p><pre><code class="language-bash">vi /etc/my.cnf
</code></pre><p>在<code>[mysqld]</code>段里加上一行<code>skip-grant-tables</code>，保存并退出。</p><h3>重新启动 MySQL</h3><pre><code class="language-bash">service mysqld restart
</code></pre><h3>修改密码</h3><pre><code class="language-bash">mysql -uroot
use mysql;
update user set Password=password(&#x27;newpass&#x27;) where User=&#x27;root&#x27;;
flush privileges;
exit;
</code></pre><h3>关闭安全模式</h3><p>将第一步在 MySQL 配置文件里加入的<code>skip-grant-tables</code>删掉。</p><h3>完成</h3><p>重启 MySQL 之后就可以用新密码登录了。</p><pre><code class="language-bash">service mysqld restart
</code></pre><h2>方法二：通过命令行传递参数</h2><h3>停止 MySQL</h3><pre><code class="language-bash">service mysqld stop
</code></pre><h3>以不检查权限的方式启动 MySQL</h3><pre><code class="language-bash">mysqld --skip-grant-tables &amp;
</code></pre><h3>修改密码</h3><pre><code class="language-bash">mysql -uroot
</code></pre><pre><code class="language-sql">use mysql;
update user set Password=password(&#x27;newpass&#x27;) where User=&#x27;root&#x27;;
flush privileges;
exit;
</code></pre><h3>完成</h3><p>用正常的方式重启 MySQL 之后就可以用新密码登录了。</p><pre><code class="language-bash">service mysqld restart
</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS 网络配置]]></title>
        <id>CentOS 网络配置</id>
        <link href="https://iuok.me/blog/configuring-centos-network"/>
        <updated>2016-12-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h2>前言</h2><p>每次装 CentOS 后无法上网都要去搜教程，现在记下来以后就不用到处去搜了（滑稽）。</p><h2>启用网卡</h2><pre><code class="language-bash">ifconfig eth0 up
</code></pre><p>顺便一提，关闭网卡的命令是<code>ifconfig eth0 down</code>。</p><h2>编辑网络配置文件</h2><pre><code class="language-bash">vi /etc/sysconfig/network-scripts/ifcfg-eth0
</code></pre><p>按<kbd>i</kbd>进入编辑模式，按<kbd>ESC</kbd>进入命令模式。命令模式中输入<code>:w</code>保存，<code>:q</code>退出，<code>:wq</code>即为退出并保存。</p><p>打开应该是下面这个样子。</p><pre><code class="language-ini">DEVICE=eth0
HWADDR=08:00:27:A6:5D:89
TYPE=Ethernet
UUID=db391271-1cdf-4df2-b040-12f259d5e361
ONBOOT=no
NM_CONTROLLED=yes
BOOTPROTO=dhcp
</code></pre><ul><li><code>ONBOOT</code>为是否开机启动，值可为 <code>yse</code>/<code>no</code>；</li><li><code>BOOTPROTO</code>为获取 IP 地址的方式，值可为 <code>dhcp</code>/<code>static</code>/<code>bootp</code>；</li></ul><p><code>ONBOOT</code>修改为<code>yes</code>，<code>BOOTPROTO</code>按需修改，其他的不需要修改，下面是示例。</p><h2>两种获取 IP 的方式</h2><h3>动态获取 IP（dhcp）</h3><pre><code class="language-ini">DEVICE=eth0
HWADDR=08:00:27:A6:5D:89
TYPE=Ethernet
UUID=db391271-1cdf-4df2-b040-12f259d5e361
ONBOOT=yes #开机启动
NM_CONTROLLED=yes
BOOTPROTO=dhcp #动态
</code></pre><h3>静态获取 IP（static）</h3><pre><code class="language-ini">DEVICE=eth0
HWADDR=08:00:27:A6:5D:89
TYPE=Ethernet
UUID=db391271-1cdf-4df2-b040-12f259d5e361
ONBOOT=yes #开机启动
NM_CONTROLLED=yes
BOOTPROTO=static #静态
IPADDR=192.168.233.234 #IP 地址
NETMASK=255.255.255.0 #子网掩码
GATEWAY=192.168.233.1 #网关
</code></pre><p>static 方式还要手动设置 DNS。</p><pre><code class="language-bash">vi /etc/resolv.conf
</code></pre><h2>重启网络服务</h2><pre><code class="language-bash">service network restart
</code></pre>]]></content>
    </entry>
</feed>