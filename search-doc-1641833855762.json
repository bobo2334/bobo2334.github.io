[{"title":"用 KMS 激活 Windows 和 Office","type":0,"sectionRef":"#","url":"blog/activate-windows-and-office-with-kms","content":"","keywords":""},{"title":"激活 Windows​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#激活-windows","content":"只能激活 VL 版本的系统，零售版不能通过这种方式激活。 使用管理员权限运行cmd。 slmgr /skms kms.03k.org slmgr /ato Copy "},{"title":"激活 Office​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#激活-office","content":"进入 Office 安装目录，用管理员权限执行命令。 # C:\\Program Files (x86)\\Microsoft Office\\Office16 cscript ospp.vbs /sethst:kms.03k.org cscript ospp.vbs /act Copy "},{"title":"KMS 服务器收集​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#kms-服务器收集","content":"在上面命令中的 KMS 服务器失效的时候可以尝试下面列表中的其它 KMS 服务器。 kms.03k.orgkms.v0v.bid "},{"title":"自建 KMS 服务器​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#自建-kms-服务器","content":"或者也可以自己搭建 KMS 服务器，难度不高，通过 Docker 可以快速部署。 teddysun/kms - Docker Image | Docker Hub "},{"title":"其它激活方式​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#其它激活方式","content":"云萌 Windows 10 激活工具 - 首页 "},{"title":"参考资料​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#参考资料","content":"本站上线 KMS 服务~一句命令激活 windows/office | 零散坑知识分享 "},{"title":"CentOS 网络配置","type":0,"sectionRef":"#","url":"blog/configuring-centos-network","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#前言","content":"每次装 CentOS 后无法上网都要去搜教程，现在记下来以后就不用到处去搜了（滑稽）。 "},{"title":"启用网卡​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#启用网卡","content":"ifconfig eth0 up Copy 顺便一提，关闭网卡的命令是ifconfig eth0 down。 "},{"title":"编辑网络配置文件​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#编辑网络配置文件","content":"vi /etc/sysconfig/network-scripts/ifcfg-eth0 Copy 按i进入编辑模式，按ESC进入命令模式。命令模式中输入:w保存，:q退出，:wq即为退出并保存。 打开应该是下面这个样子。 DEVICE=eth0 HWADDR=08:00:27:A6:5D:89 TYPE=Ethernet UUID=db391271-1cdf-4df2-b040-12f259d5e361 ONBOOT=no NM_CONTROLLED=yes BOOTPROTO=dhcp Copy ONBOOT为是否开机启动，值可为 yse/no；BOOTPROTO为获取 IP 地址的方式，值可为 dhcp/static/bootp； ONBOOT修改为yes，BOOTPROTO按需修改，其他的不需要修改，下面是示例。 "},{"title":"两种获取 IP 的方式​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#两种获取-ip-的方式","content":""},{"title":"动态获取 IP（dhcp）​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#动态获取-ipdhcp","content":"DEVICE=eth0 HWADDR=08:00:27:A6:5D:89 TYPE=Ethernet UUID=db391271-1cdf-4df2-b040-12f259d5e361 ONBOOT=yes #开机启动 NM_CONTROLLED=yes BOOTPROTO=dhcp #动态 Copy "},{"title":"静态获取 IP（static）​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#静态获取-ipstatic","content":"DEVICE=eth0 HWADDR=08:00:27:A6:5D:89 TYPE=Ethernet UUID=db391271-1cdf-4df2-b040-12f259d5e361 ONBOOT=yes #开机启动 NM_CONTROLLED=yes BOOTPROTO=static #静态 IPADDR=192.168.233.234 #IP 地址 NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.233.1 #网关 Copy static 方式还要手动设置 DNS。 vi /etc/resolv.conf Copy "},{"title":"重启网络服务​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#重启网络服务","content":"service network restart Copy "},{"title":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","type":0,"sectionRef":"#","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh","content":"","keywords":""},{"title":"补充​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#补充","content":"oh-my-posh 项目已被重构，现在由 Go 语言实现，详情见 Github。 文章中所使用的版本现已被重命名为 oh-my-posh2，由 PowerShell 实现，详情见 Github。 oh-my-posh3 的安装请参考 Windows Terminal + PWSH + oh my posh3 + PSReadLine 打造一个好用的终端，下面的内容已过时。 "},{"title":"前言​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#前言","content":"Windows 中自带的终端使用体验确实说不上好，尝试了许多组合也感觉都不顺手。这次试试微软亲自出的 Windows Terminal1，再加上 oh-my-posh2 插件。 "},{"title":"正文​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#正文","content":""},{"title":"安装 Windows Terminal​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#安装-windows-terminal","content":"Windows Terminal 提供多种安装方式，你可以在 Microsoft Store 中安装；可以自行在该项目的 Github 仓库 1 中上下载安装程序；虽然官方文档未提及，但是你也可以用 Scoop3 安装： scoop install windows-terminal Copy "},{"title":"安装 oh-my-posh​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#安装-oh-my-posh","content":"oh-my-posh 是针对 Windows PowerShell 设计的主题引擎，类似于 zsh 和 Oh My Zsh 的关系。它可以让你的命令行更强大。 打开 PowerShell，输入以下命令安装： Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser Copy 安装完成之后还更改 PowerShell 的用户配置，让它每次启动的时候自动加载 oh-my-posh 插件；执行以下命令： if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE Copy 不出意外的话接下来会出现记事本，你需要在里面写上以下内容： Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradox Copy 保存该文件，重新打开 PowerShell 你就能看到一个发生改变了的 PowerShell 。  oh-my-posh 提供了几组预设的主题供你选择，你可以通过 Set-Theme 命令来更改当前主题，可选的值有 Agnoster/Paradox/Sorin/Darkblood/Avit/Honukai/Fish/Robbyrussell。  这个主题设置只在当前会话生效，为了每次启动 PowerShell 的时候都能加载你想要的主题，你还需要修改以下用户配置文件，就像上一个步骤中做的一样，只需要修改 Set-Theme 命令的部分即可。 "},{"title":"用上微软的 Cascadia Code 字体​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#用上微软的-cascadia-code-字体","content":"或许你已经发现了有些字符显示不正常，那是因为默认的字体没有内嵌这些字符的形状，你还需要换一个字体。 微软的另一个开源项目，Cascadia Code4 就是一款适用于终端和代码展示的字体，你可以使用 Scoop 来安装它；安装字体的时候需要使用到管理员权限，你可以使用 sudo 命令，或者用管理员权限重新打开 PowerShell，再执行安装。 在安装之前，你可能需要添加一下 nerd-fonts 仓库，因为字体软件的元信息都存放于这个仓库中。 scoop bucket add nerd-fonts Copy 在 Scoop 的仓库中存在着好几个版本的 Cascadia Code，其中： Cascadia-Code是原版不带 Powerline 字符的；Cascadia-PL是微软出品的，自带 Powerline 字符的；CascadiaCode-NF是 Nerd Fonts5 项目出品的，后期补丁了大量 Powerline 字符。 没有特殊需求的话可以选择官方出的轻量级的 Cascadia-PL，执行以下命令： sudo scoop install Cascadia-PL Copy 安装完成之后还需设置以下，指定 Windows Terminal 使用该字体。 目前 Windows Terminal 没有专门的设置界面，所有的配置项都在 profiles.json 配置文件里；在配置文件的对应地方设置 fontFace 的值为 Cascadia Code PL： // ... &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles &quot;fontFace&quot;: &quot;Cascadia Code PL&quot; }, // ... Copy 保存配置文件后就能使配置文件生效；此时所有字符应该能正常显示了。  "},{"title":"集成 Git Bash​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#集成-git-bash","content":"首先将 Git 安装目录下的 bin 目录加入 Path 环境变量，如果你是用 Scoop 安装的 Git，则可以忽略此步骤，因为 Scoop 已经帮你完成了这个工作；然后修改 Windows Terminal 的配置文件，在 profiles-&gt;list 中新增一条配置： // ... &quot;list&quot;: [ { &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff4411}&quot;, &quot;name&quot;: &quot;Git Bash&quot;, &quot;commandline&quot;: &quot;bash.exe&quot;, &quot;hidden&quot;: false, &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot; } ] // ... Copy 注意 JSON 的语法格式，在列表中不要少加或者多加逗号。保存配置文件之后就能在 Windows Terminal 中快捷启动 Git Bash 了。  "},{"title":"后记​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#后记","content":"新的 Windows Terminal 使用体验还是挺不错的，颜值也 OK，折腾一下也挺好用的。 microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place!↩JanDeDobbeleer/oh-my-posh2: A prompt theming engine for Powershell↩lukesampson/scoop: A command-line installer for Windows.↩microsoft/cascadia-code: This is a fun, new monospaced font that includes programming ligatures and is designed to enhance the modern look and feel of the Windows Terminal.↩ryanoasis/nerd-fonts: Iconic font aggregator, collection, &amp; patcher. 3,600+ icons, 50+ patched fonts: Hack, Source Code Pro, more. Glyph collections: Font Awesome, Material Design Icons, Octicons, &amp; more↩ "},{"title":"Debian 配置备份","type":0,"sectionRef":"#","url":"blog/debian-environment-backup","content":"","keywords":""},{"title":"软件源​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#软件源","content":"debian | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror apt edit-sources Copy # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free Copy apt update Copy "},{"title":"小工具​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#小工具","content":"apt install curl wget tmux bat htop exa neofetch trash-cli Copy "},{"title":"alias​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#alias","content":"alias bat='batcat' alias ll='exa -lha --modified --created --time-style long-iso --group-directories-first' alias dc='docker-compose' alias lzd='lazydocker' alias rm='echo &quot;please use trash-put&quot;' Copy "},{"title":"docker​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#docker","content":"wget https://get.docker.com/ -O get-docker.sh # sh get-docker.sh --mirror Aliyun sh get-docker.sh systemctl enable docker Copy "},{"title":"docker-compose​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#docker-compose","content":"Releases · docker/compose # wget https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-linux-x86_64 -O /opt/docker-compose wget https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-linux-x86_64 -O /opt/docker-compose chmod u+x /opt/docker-compose ln -s /opt/docker-compose /usr/local/sbin/docker-compose Copy "},{"title":"lazydocker​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#lazydocker","content":"Releases · jesseduffield/lazydocker # wget https://ghproxy.com/https://github.com/jesseduffield/lazydocker/releases/download/v0.12/lazydocker_0.12_Linux_x86_64.tar.gz wget https://github.com/jesseduffield/lazydocker/releases/download/v0.12/lazydocker_0.12_Linux_x86_64.tar.gz mkdir ~/lazydocker tar -zxvf lazydocker_0.12_Linux_x86_64.tar.gz -C ~/lazydocker mv ~/lazydocker/lazydocker /opt/lazydocker chmod u+x /opt/lazydocker ln -s /opt/lazydocker /usr/local/sbin/lazydocker trash-put ~/lazydocker # rm -rf ~/lazydocker Copy # ~/.config/jesseduffield/lazydocker/config.yml reporting: &quot;off&quot; gui: returnImmediately: true commandTemplates: serviceLogs: '{{ .DockerCompose }} logs --timestamps --follow --tail 500 {{ .Service.Name }}' viewServiceLogs: '{{ .DockerCompose }} logs --tail 500 --follow {{ .Service.Name }}' containerLogs: docker logs --timestamps --follow --tail 500 {{ .Container.ID }} viewContainerLogs: docker logs --timestamps --follow --tail 500 {{ .Container.ID}} Copy "},{"title":"croc​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#croc","content":"Releases · schollz/croc # wget https://ghproxy.com/https://github.com/schollz/croc/releases/download/v9.5.0/croc_9.5.0_Linux-64bit.deb wget https://github.com/schollz/croc/releases/download/v9.5.0/croc_9.5.0_Linux-64bit.deb dpkg -i croc_9.5.0_Linux-64bit.deb Copy "},{"title":"bat​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#bat","content":"Releases · sharkdp/bat # wget https://ghproxy.com/https://github.com/sharkdp/bat/releases/download/v0.18.3/bat_0.18.3_amd64.deb wget https://github.com/sharkdp/bat/releases/download/v0.18.3/bat_0.18.3_amd64.deb dpkg -i bat_0.18.3_amd64.deb Copy "},{"title":"使用 Vant Weapp 自定义微信小程序 TabBar","type":0,"sectionRef":"#","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#前言","content":"微信小程序原生的 TabBar 虽然设置简单，但是样式不好看，也不能使用字体图标，但是微信小程序有自定义 TabBar 的机制。 Vant WeApp1 是有赞出品的针对微信小程序的一套开源组件库，结合 van-tabbar2 和微信的自定义 TabBar 机制 3 可以实现一套比较好看的 TabBar。 "},{"title":"新建 custom-tab-bar 组件​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#新建-custom-tab-bar-组件","content":"如图所示，在微信小程序工程文件夹根目录下新建一个名为 custom-tab-bar 的组件。  其中各个文件中的代码如下： { &quot;component&quot;: true, &quot;usingComponents&quot;: { &quot;van-tabbar&quot;: &quot;@vant/weapp/tabbar/index&quot;, &quot;van-tabbar-item&quot;: &quot;@vant/weapp/tabbar-item/index&quot; } } Copy // custom-tab-bar/index.js Component({ /** * 组件的属性列表 */ properties: {}, /** * 组件的初始数据 */ data: { active: -1, list: [{ icon: &quot;search&quot;, text: &quot;搜索&quot;, url: &quot;/pages/index/index&quot;, }, { icon: &quot;question-o&quot;, text: &quot;答题&quot;, url: &quot;/pages/question/index&quot;, }, { icon: &quot;ellipsis&quot;, text: &quot;关于&quot;, url: &quot;/pages/user/index&quot;, }, ], }, /** * 组件的方法列表 */ methods: { onChange(event) { wx.switchTab({ url: this.data.list[event.detail].url, }); }, init() { const { route } = getCurrentPages().pop(); const active = this.data.list.findIndex( (item) =&gt; item.url === `/${route}` ); console.log(&quot;active:&quot;, active); this.setData({ active, }); }, }, }); Copy &lt;!-- custom-tab-bar/index.wxml --&gt; &lt;van-tabbar active=&quot;{{ active }}&quot; bind:change=&quot;onChange&quot;&gt; &lt;van-tabbar-item wx:for=&quot;{{list}}&quot; wx:key=&quot;index&quot; icon=&quot;{{item.icon}}&quot;&gt; {{item.text}} &lt;/van-tabbar-item&gt; &lt;/van-tabbar&gt; Copy "},{"title":"启用自定义 TabBar 设置​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#启用自定义-tabbar-设置","content":"修改 app.js 中 tabBar 设置，设置 custom 为 true。其中 list 中的对象只需保留 path 属性。  "},{"title":"在每个 Tab 页中配置​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#在每个-tab-页中配置","content":"在开启了自定义 TabBar 设置后，可以在每个页面中通过 getTabBar() 获取 TabBar 组件实例。 现在需要在每个 Tab 页中设置当前 Tab 页图标高亮。 可以在每个 Tab 页的 onShow() 生命周期方法中调用 TabBar 的 init() 方法，修改当前激活页，来高亮当前 Tab 页的图标。 /** * 生命周期函数--监听页面显示 */ onShow: function () { this.getTabBar().init(); }, Copy Vant - 轻量、可靠的移动端组件库 (gitee.io)↩Tabbar 标签栏 - Vant Weapp↩自定义 tabBar | 微信开放文档↩ "},{"title":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","type":0,"sectionRef":"#","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#前言","content":"Vuepress1 是一个基于 Vue 的静态网站生成器；Github Pages2 是 Github 提供的免费的静态网站托管服务；Github Actions3 是 Github 仓库中集成的 CI/CD4 服务。 Vuepress 是一个 Node.js 项目，它可以根据配置将 Markdown 文件转为 HTML 文件。你可以将输出的静态文件托管在 Github Pages 中，这样你就得到了一个可以访问的域名来展示这些静态的 HTML 文件。 传统的做法是在本地安装好 Noed.js 环境，自己手动构建项目之后将构建产物上传到 Github 仓库，从而触发 Github Pages 的构建。现在可以利用 Github Actions 来代替手工劳动，Github Actions 可以自动被触发，它运行在 Github 提供的虚拟环境中，可以执行一系列任务从而代替重复枯燥的手动构建和部署的步骤。 "},{"title":"创建 Github 仓库​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#创建-github-仓库","content":"在创建的 Github 仓库时要注意仓库名称，假如你的用户名是 foo。 如果你创建了一个名为foo.github.io的仓库，你将可以通过https://foo.github.io来访问此仓库的 Github Pages 内容； 如果你创建其他名称的仓库如bar，你可以通过https://foo.github.io/bar/来访问此仓库的 Github Pages 内容。 你可以根据你期望的访问方式来选择仓库名称。 "},{"title":"配置 Github Actions​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#配置-github-actions","content":"Github Actions 的配置文件应该放在项目根目录下的.github/workflows/文件夹中，你可以在一个项目中配置多个 Actions。配置文件是 YAML 格式，文件名形如*.yml。 每一个 Action 中可以包括多个 job，每个 job 可以包括多个 step。在 step 中你可以直接运行命令，或者引用其他人编写好的 Action 脚本。在本文的配置文件中，我们引用了 github-pages-deploy-action5 来完成 Github Pages 部署，而不用关系其实现细节。 完成本文目标的 Github Actions 配置文件内容如下。 name: &quot;github actions build and deploy gh-pages&quot; on: push: branches: - master jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2.3.1 with: persist-credentials: false - name: install and build run: | npm install npm run build - name: Deploy uses: JamesIves/github-pages-deploy-action@4.1.4 with: BRANCH: gh-pages FOLDER: docs/.vuepress/dist Copy 其中的一些关键配置解释如下。 on.push.branches，在推送到master分支时触发此 Action；jobs.build-and-deploy，在一个 Action 中可以有多个 job，这是其中的一个，名称是自己取的；每个任务可以有多个 step；jobs.build-and-deploy.steps[0]，用actions/checkout检出仓库内容；jobs.build-and-deploy.steps[1]，执行npm命令安装开发环境；jobs.build-and-deploy.steps[2]，用JamesIves/github-pages-deploy-action部署docs/.vuepress/dist文件夹中的内容到gh-pages分支中。 在编写好配置文件后可以提交并推送文件至 master 分支，这会自动触发 Action 的执行，并且你可以在 Actions 栏目中查看执行日志。  "},{"title":"配置 Github Pages​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#配置-github-pages","content":"我们的构建产物放在 gh-pages 分支，我们需要告诉 Github Pages 源文件位置。 在 Github 仓库的 Settings 栏目中，从左侧的设置导航栏找到 Pages 设置。在这里你可以设置 gh-pages 为数据源。  如果没出错的话，在配置完成之后你就可以通过 Github Pages 给你提供的域名来访问你的静态网站了。 首页 | VuePress↩GitHub Pages | Websites for you and your projects, hosted directly from your GitHub repository. Just edit, push, and your changes are live.↩Learn GitHub Actions - GitHub Docs↩什么是 CI/CD？一文带你理解 CI 持续集成和 CD 持续交付/部署 - 红帽↩JamesIves/github-pages-deploy-action: Automatically deploy your project to GitHub Pages using GitHub Actions. This action can be configured to push your production-ready code into any branch you'd like.↩ "},{"title":"Docker 穿透防火墙的问题","type":0,"sectionRef":"#","url":"blog/docker-and-system-firewall","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Docker 穿透防火墙的问题","url":"blog/docker-and-system-firewall#前言","content":"有些服务只需要在本地访问，不需要向外暴露端口，不然会有安全隐患，总有一大堆机器扫描你的端口，尝试接入你的服务。 通过 Docker 暴露的端口，即使没有在防火墙中手动放行，在外部还是可以访问到。 "},{"title":"解决办法​","type":1,"pageTitle":"Docker 穿透防火墙的问题","url":"blog/docker-and-system-firewall#解决办法","content":"在进行端口映射的时候指定监听地址为127.0.0.1，如127.0.0.1:3000:80。在没指定的情况下，如3000:80，监听地址为0.0.0.0。 这在使用docker run命令和docker-compose命令的时候都可以生效。 docker run命令示例如下。 docker run -p 127.0.0.1:80:80 nginx Copy 使用docker-compose命令时，docker-compose.yml内容示例如下。 version: '3.3' services: nginx: ports: - '127.0.0.1:80:80' image: nginx Copy "},{"title":"参考资料​","type":1,"pageTitle":"Docker 穿透防火墙的问题","url":"blog/docker-and-system-firewall#参考资料","content":"无视系统防火墙的 docker - 博客 - binsitedocker 无视防火墙问题总结 - Icharle | Don't forget your first thoughtsdocker 开放的端口是如何实现绕过防火墙的？ - 知乎Docker 与 IPtables - 简书 "},{"title":"以容器的方式暴露 Docker Remote API 并启用 TLS","type":0,"sectionRef":"#","url":"blog/enable-docker-remote-api-with-tls-protection-via-container","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"以容器的方式暴露 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection-via-container#前言","content":"之前在「开启 Docker Remote API 并启用 TLS」1 中记录过 Docker 暴露 Remote API 并配置 TLS 支持，虽然其中引用了别人的脚本来简化证书的签发步骤，但是在证书签发完成之后还是需要对 Docker 的启动命令进行修改，还是一个比较繁琐的步骤。 后来我发现了 docker-remote-api-tls2 项目，它提供了一个 Docker 镜像，在运行镜像之后它会自动完成证书签发和 API 转发步骤。 "},{"title":"部署​","type":1,"pageTitle":"以容器的方式暴露 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection-via-container#部署","content":"可以通过 Docker Compose 方便地启动这个容器，下面是docker-compose.yml文件的内容。 version: &quot;3&quot; services: api: image: kekru/docker-remote-api-tls:v0.3.0 ports: - 2376:443 environment: - CREATE_CERTS_WITH_PW=dockercompose - CERT_EXPIRATION_DAYS=3650 - CA_EXPIRATION_DAYS=36500 - CERT_HOSTNAME=192.168.229.129.nip.io volumes: - /root/compose/docker-remote-api-with-tls/certs:/data/certs - /var/run/docker.sock:/var/run/docker.sock:ro restart: unless-stopped Copy 有以下几点需要注意： 第 6 行，容器内的端口是 443，需要映射到容器外 2376 端口；第 8 行，CREATE_CERTS_WITH_PW设置证书密码；第 9 行，CERT_EXPIRATION_DAYS设置证书过期时间，默认 365 天；第 10 行，CA_EXPIRATION_DAYS设置 CA 证书过期时间，默认 900 天；第 11 行，CERT_HOSTNAME设置域名，如果没有域名可以用 nip.io3 来得到一个可以解析到任意 IP 的域名。形如192.168.229.129.nip.io的域名会被解析至192.168.229.129；还有其他形式的域名可以在 nip.io 网站中查看；第 13 行，挂载证书目录，首次启动时证书会被自动创建并存放在此目录中；第 14 行，挂载docker.sock。 通过docker compose up -d启动容器。根据配置，证书会被自动创建在/root/compose/docker-remote-api-with-tls/certs目录中。 该目录的结构如下： certs/ ├── ca-cert.pem ├── ca-key.pem ├── client │ ├── ca.pem │ ├── cert.pem │ └── key.pem ├── server-cert.pem └── server-key.pem Copy 其中，客户端需要的证书文件存放在client目录中。此时 Docker Remote API 已经暴露在 2376 端口，客户端可以使用证书文件来通过认证。 如果需要重新签发证书文件，只需要清空certs文件夹并重启容器即可。 "},{"title":"补充​","type":1,"pageTitle":"以容器的方式暴露 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection-via-container#补充","content":"国内的 IP 请使用已备案域名，不然可能会被阻断，导致连接不上。 开启 Docker Remote API 并启用 TLS↩kekru/docker-remote-api-tls: Docker Image that forwards to the Docker API Socket and requires TLS Client authentication↩nip.io - wildcard DNS for any IP Address↩ "},{"title":"获取天翼光猫 F412 超级管理员帐号密码","type":0,"sectionRef":"#","url":"blog/get-super-admin-password-of-f412","content":"","keywords":""},{"title":"开启 telnet 服务​","type":1,"pageTitle":"获取天翼光猫 F412 超级管理员帐号密码","url":"blog/get-super-admin-password-of-f412#开启-telnet-服务","content":"控制面板 -&gt; 所有控制面板项 -&gt; 程序和功能 -&gt; 启用或关闭 Windows 功能。 "},{"title":"获取帐号密码​","type":1,"pageTitle":"获取天翼光猫 F412 超级管理员帐号密码","url":"blog/get-super-admin-password-of-f412#获取帐号密码","content":"打开 cmd，输入命令：telnet 192.168.1.1登录帐号：root登录密码：Zte521输入命令：sendcmd 1 DB p UserInfo "},{"title":"开启 Docker Remote API 并启用 TLS","type":0,"sectionRef":"#","url":"blog/enable-docker-remote-api-with-tls-protection","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#前言","content":"Portainer1 是一款 Docker 可视化管理面板，它不仅可以管理本地的 Docker 实例，还可以通过 Docker Remote API 访问管理远程 Docker 资源。Docker Remote API 就是通过 HTTP 协议暴露 Docker 资源，启用 TLS 可以实现远程访问鉴权。 Docker 的官方文档提供了详细的开启 Docker Remote API 和开启 TLS 的教程 2。但是在签发证书的过程中涉及到的命令比较多，且繁琐，我就从网络上寻找到了别人写好的签发证书的脚本 3，可以很方便地替代纯手工操作。 本文中的操作都在 CentOS 7 中完成。 "},{"title":"签发证书​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#签发证书","content":"将脚本命名为auto-tls-certs.sh。其中需要配置的内容有： CODE，作为文件名的后缀，用于区分文件；IP，机器的公网 IP 地址；PASSWORD，证书密码。 脚本内容如下： #!/bin/bash # # ------------------------------------------------------------- # 自动创建 Docker TLS 证书 # ------------------------------------------------------------- # 以下是配置信息 # --[BEGIN]------------------------------ CODE=&quot;tx&quot; IP=&quot;1.1.1.1&quot; PASSWORD=&quot;pass&quot; COUNTRY=&quot;CN&quot; STATE=&quot;BEIJING&quot; CITY=&quot;BEIJING&quot; ORGANIZATION=&quot;Org&quot; ORGANIZATIONAL_UNIT=&quot;Dev&quot; COMMON_NAME=&quot;$IP&quot; EMAIL=&quot;.&quot; # --[END]-- # Generate CA key openssl genrsa -aes256 -passout &quot;pass:$PASSWORD&quot; -out &quot;ca-key-$CODE.pem&quot; 4096 # Generate CA openssl req -new -x509 -days 365 -key &quot;ca-key-$CODE.pem&quot; -sha256 -out &quot;ca-$CODE.pem&quot; -passin &quot;pass:$PASSWORD&quot; -subj &quot;/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$COMMON_NAME/emailAddress=$EMAIL&quot; # Generate Server key openssl genrsa -out &quot;server-key-$CODE.pem&quot; 4096 # Generate Server Certs. openssl req -subj &quot;/CN=$COMMON_NAME&quot; -sha256 -new -key &quot;server-key-$CODE.pem&quot; -out server.csr echo &quot;subjectAltName = IP:$IP,IP:127.0.0.1&quot; &gt;&gt; extfile.cnf echo &quot;extendedKeyUsage = serverAuth&quot; &gt;&gt; extfile.cnf openssl x509 -req -days 365 -sha256 -in server.csr -passin &quot;pass:$PASSWORD&quot; -CA &quot;ca-$CODE.pem&quot; -CAkey &quot;ca-key-$CODE.pem&quot; -CAcreateserial -out &quot;server-cert-$CODE.pem&quot; -extfile extfile.cnf # Generate Client Certs. rm -f extfile.cnf openssl genrsa -out &quot;key-$CODE.pem&quot; 4096 openssl req -subj '/CN=client' -new -key &quot;key-$CODE.pem&quot; -out client.csr echo extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf openssl x509 -req -days 365 -sha256 -in client.csr -passin &quot;pass:$PASSWORD&quot; -CA &quot;ca-$CODE.pem&quot; -CAkey &quot;ca-key-$CODE.pem&quot; -CAcreateserial -out &quot;cert-$CODE.pem&quot; -extfile extfile.cnf rm -vf client.csr server.csr chmod -v 0400 &quot;ca-key-$CODE.pem&quot; &quot;key-$CODE.pem&quot; &quot;server-key-$CODE.pem&quot; chmod -v 0444 &quot;ca-$CODE.pem&quot; &quot;server-cert-$CODE.pem&quot; &quot;cert-$CODE.pem&quot; # 打包客户端证书 mkdir -p &quot;tls-client-certs-$CODE&quot; cp -f &quot;ca-$CODE.pem&quot; &quot;cert-$CODE.pem&quot; &quot;key-$CODE.pem&quot; &quot;tls-client-certs-$CODE/&quot; cd &quot;tls-client-certs-$CODE&quot; tar zcf &quot;tls-client-certs-$CODE.tar.gz&quot; * mv &quot;tls-client-certs-$CODE.tar.gz&quot; ../ cd .. rm -rf &quot;tls-client-certs-$CODE&quot; # 拷贝服务端证书 mkdir -p /etc/docker/certs.d cp &quot;ca-$CODE.pem&quot; &quot;server-cert-$CODE.pem&quot; &quot;server-key-$CODE.pem&quot; /etc/docker/certs.d/ Copy 使用sh auto-tls-certs.sh命令来生成证书，并且生成好的证书会被自动打包为.tar.gz归档，非常方便。下面的图片展示了执行脚本后生成的文件列表。  "},{"title":"配置 Docker​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#配置-docker","content":"只需关注.pem文件，把证书找个专门的位置存放。 mkdir /etc/.docker cp ~/docker-cert/*.pem /etc/.docker/ Copy 修改 Docker 启动文件。 nano /lib/systemd/system/docker.service Copy 修改Service下的ExecStart配置。 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -D -H tcp://0.0.0.0:2376 --tlsverify --tlscacert=/etc/.docker/ca-tx.pem --tlscert=/etc/.docker/server-cert-tx.pem --tlskey=/etc/.docker/server-key-tx.pem Copy  重启 Docker。 systemctl daemon-reloadservice docker restart Copy "},{"title":"开放端口​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#开放端口","content":"在防火墙、安全组中放行 2376 端口。 "},{"title":"测试​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#测试","content":"把证书的压缩包tls-client-certs-tx.tar.gz下载到本机，解压得到证书文件。  用curl命令测试，如果有 JSON 格式的信息输出则配置成功。 curl https://你的 IP/info --cert cert-tx.pem --key key-tx.pem --cacert ca-tx.pem Copy  "},{"title":"用 Portainer 连接​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#用-portainer-连接","content":"Portainer 是一款非常好用的 Docker 可视化管理工具，通过暴露 Docker Remote API 可以远程连接并管理 Docker 资源。 在Endpoints页面中点击Add endpoint，Environment type选择Docker。 在对应的输入框中填写 IP 地址和端口号，开启 TLS，选择三个对应的证书文件。  Documentation↩Protect the Docker daemon socket | Docker Documentation↩Docker 开启 TLS 访问，更加安全 - 实用教程 - 高亚轩的 BLOG↩ "},{"title":"《求生之路 2》制作动态喷漆","type":0,"sectionRef":"#","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#前言","content":" 动态的喷漆也是这个游戏的乐趣之一，尝试自己制作一下动态喷漆，将 GIF 图片转换为可以在游戏中使用的动态喷涂文件。 文中使用的工具和成品可以从 这里 下载。 "},{"title":"准备工作​","type":1,"pageTitle":"《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#准备工作","content":"一张 GIF 图片；GIF 图片分解工具，用于把动态图的每一帧分解出来，文中使用的是 GifSplitter1；VTFEdit2，核心工具，用于制作 VTF 格式的动态图。 "},{"title":"分解 GIF​","type":1,"pageTitle":"《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#分解-gif","content":"这里使用的是 GifSplitter，目的是将 GIF 图片的每一帧都分解出来；其他功能类似的软件和在线工具都可以。  "},{"title":"制作 VTF​","type":1,"pageTitle":"《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#制作-vtf","content":"打开 VTFEdit，点击左上角的 「导入」 按钮，选择并导入上一步中分离出来的所有图片。  接下来设置贴图尺寸，选中 「限定贴图尺寸」，高度和宽度都设置为 128，其他设置保持默认。  再切换到 「信息」 页中，查看文件大小；要确保其小于 512KB，否则无法喷出。如果文件太大的话，就把要导入的图片删除一些，再重复这些步骤，直至满足条件。 再满足条件之后就可以保存了，保存的时候注意不要使用中文文件名，不然在游戏里浏览文件的时候中文名会乱码。  "},{"title":"在游戏中导入​","type":1,"pageTitle":"《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#在游戏中导入","content":"打开游戏，在游戏设置中依次找到 「导入喷漆图案」，选择上一步中制作好的 VTF 文件。  "},{"title":"后记​","type":1,"pageTitle":"《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#后记","content":"整个制作过程也不复杂，核心工具是 VTFEdit；至于分解 GIF 的工具就很多了，可以很灵活地选择其他软件来完成这个任务。 最重要的是控制文件大小，不能超过限制，不然在游戏中无法使用。如果文件大小太大的话可以考虑在分解出的图片中删除一些图片，来达到减小文件大小的目的。比如可以隔帧删除，每隔一张图片就删除一张图片，应该会很有效。 GifSplitter - Break GIF animation down into individual image frames↩VTFEdit - Valve Developer Community↩ "},{"title":"配置 oh-my-zsh","type":0,"sectionRef":"#","url":"blog/oh-my-zsh","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#前言","content":"oh-my-zsh1 是 zsh2 的一款插件管理器，提供了很多 zsh 的插件和主题。 zsh 的优点是兼容 bash 语法，可以在日常工作中替换掉 bash，并且可以享受 zsh 的很多特性。 "},{"title":"安装​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#安装","content":"安装 oh-my-zsh 之前需要先安装 zsh 和 git，oh-my-zsh 依赖它们在能正常工作。 在 zsh 中执行以下命令安装 oh-my-zsh。 sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; Copy 安装脚本就是帮你克隆了 oh-my-zsh 的仓库到~/.oh-my-zsh，并且给你新建了一个~/.zshrc文件模板，用于在 zsh 启动时加载 oh-my-zsh。 你之前的.zshrc文件内容被转移到.zshrc.pre-oh-my-zsh，现在的.zshrc的内容是全新的，如果你之前在用户配置文件里做了重要配置，你需要将.zshrc.pre-oh-my-zsh里的内容附加到现在的.zshrc之后，以确保之前的功能正常使用。 "},{"title":"主题​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#主题","content":"oh-my-zsh 默认自带了许多主题，这些主题文件存放在~/.oh-my-zsh/themes/文件夹下。你可以在 oh-my-zsh 主题 wiki3 中参考这些主题的预览图。 编辑.zshrc文件，修改ZSH_THEME配置，执行exec zsh命令或重启终端即可看到新主题的效果。 ZSH_THEME=&quot;robbyrussell&quot; Copy "},{"title":"第三方主题​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#第三方主题","content":"除了默认自带的主题外，你还可以使用第三方主题，如 Dracula4 主题。 下面的命令用于克隆 Dracula 主题的仓库到本地的~/zsh-dracula文件夹。 git clone https://github.com/dracula/zsh.git ~/zsh-dracula Copy 你可以手动复制~/zsh-dracula下的dracula.zsh-theme文件和lib文件夹至~/.oh-my-zsh/custome/themes/文件夹下来完成主题的安装。 也可以使用以下命令创建一个主题的软连接到主题文件夹，来完成主题的安装。 ln -s ~/zsh-dracula/dracula.zsh-theme $ZSH_CUSTOM/themes/dracula.zsh-theme Copy 在安装完成之后编辑.zshrc文件，修改ZSH_THEME配置，执行exec zsh命令或重启终端即可看到新主题的效果。 ZSH_THEME=&quot;dracula&quot; Copy "},{"title":"插件​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#插件","content":"oh-my-zsh 默认自带了许多插件，这些插件文件存放在~/.oh-my-zsh/plugins/文件夹下。你可以在 oh-my-zsh 插件 wiki5 中查阅默认插件的目录和文档。 编辑.zshrc文件，修改plugins配置，把插件名称写入其中即可启用插件，每个插件名称之间用空格或换行分隔，不要用逗号。注意过多的插件会影响启动时间。执行exec zsh命令或重启终端即可让配置文件生效。 plugins=(git theme) Copy 下面记录一些自用的插件。 "},{"title":"git6​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#git","content":"默认启用的插件，提供了一些 Git 命令的别名和 Git 相关的常用命令，详情可参考其文档 6。 "},{"title":"theme7​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#theme","content":"用命令预览主题，不需要修改配置文件。 theme，随机加载主题lstheme，列出所有主题theme &lt;name&gt;，预览指定主题 "},{"title":"z8​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#z","content":"提供一个z命令用于常用目录快速跳转，日常中可以替换掉cd，在通过z命令切换目录后下次切换只需要输入部分文件名。 下面的命令演示了z plug命令切换到~/.oh-my-zsh/plugins目录。 /usr/bin$ z plug # Even 'z p' might suffice ~/.oh-my-zsh/plugins$ Copy "},{"title":"safe-paste9​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#safe-paste","content":"防止粘贴进终端的多行代码直接执行。 "},{"title":"sudo10​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#sudo","content":"按两次ESC为你当前的命令或前一次命令加上sudo前缀。 "},{"title":"第三方插件​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#第三方插件","content":""},{"title":"zsh-syntax-highlighting11​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#zsh-syntax-highlighting","content":"命令语法高亮。 克隆仓库。 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting Copy 编辑.zshrc文件，修改plugins配置，加上zsh-syntax-highlighting。 plugins=(git theme zsh-syntax-highl3ighting) Copy "},{"title":"zsh-autosuggestions12​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#zsh-autosuggestions","content":"根据历史命令和命令提示插件来给你输入建议。 克隆仓库。 git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions Copy 编辑.zshrc文件，修改plugins配置，加上zsh-autosuggestions。 ohmyzsh/ohmyzsh: 🙃 A delightful community-driven (with 1900+ contributors) framework for managing your zsh configuration. Includes 300+ optional plugins (rails, git, macOS, hub, docker, homebrew, node, php, python, etc), 140+ themes to spice up your morning, and an auto-update tool so that makes it easy to keep up with the latest updates from the community.↩Installing ZSH · ohmyzsh/ohmyzsh Wiki↩Themes · ohmyzsh/ohmyzsh Wiki↩Dark theme for Zsh and 223+ apps — Dracula↩Plugins · ohmyzsh/ohmyzsh Wiki (github.com)↩ohmyzsh/plugins/git at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/themes at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/z at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/safe-paste at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/sudo at master · ohmyzsh/ohmyzsh↩zsh-users/zsh-syntax-highlighting: Fish shell like syntax highlighting for Zsh.↩ "},{"title":"挂载腾讯云 COS 到本地文件夹","type":0,"sectionRef":"#","url":"blog/mount-tencent-cos-on-local-file-system","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#前言","content":"腾讯云提供了一个软件 cosfs1 用于挂载 COS 到本地，可以使用标准的文件操作命令来操作 COS 中的内容。由于后端是云存储而不是真正的本地存储，所以有些操作的性能比较低。不推荐通过此种方式在其中修改文件内容或文件名称，仅仅下载文件和上传新文件的操作还是可以的。 腾讯云内网访问 COS 的下载流量不计费，可以通过腾讯云服务器把 COS 内容挂载到服务器，然后通过别的途径在外网下载，例如用 Rclone 通过 SFTP 把 COS 的内容复制到外网的机器，这样就不计下载流量的费用了，但是 API 调用次数还是要收费的。 文中所涉及的操作系统是 Debian，Debian 系的系统操作应该都差不多。 "},{"title":"安装软件​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#安装软件","content":"cosfs 的挂载依赖 fuse，先安装 fuse。 apt install fuse Copy 安装 cosfs，官方提供了deb和rpm格式的安装包，Debian 系统用deb格式的，下载安装包之前可以先去发布页面 2 检查一下是否有新版本。 # wget https://ghproxy.com/https://github.com/tencentyun/cosfs/releases/download/v1.0.19/cosfs_1.0.19-ubuntu20.04_amd64.deb wget https://github.com/tencentyun/cosfs/releases/download/v1.0.19/cosfs_1.0.19-ubuntu20.04_amd64.deb dpkg -i cosfs_1.0.19-ubuntu20.04_amd64.deb Copy "},{"title":"编写配置文件​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#编写配置文件","content":"配置文件应该存放在/etc/passwd-cosfs中。其中可以有多行，每行的格式如下。 &lt;BucketName-APPID&gt;:&lt;SecretId&gt;:&lt;SecretKey&gt; Copy 例如你可以这样写。 examplebucket-1250000000:AKIDHTVVaVR6e3****:PdkhT9e2rZCfy6**** Copy 同时需要更改该文件的权限。 chmod 640 /etc/passwd-cosfs Copy "},{"title":"挂载​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#挂载","content":"先创建一个挂载点。 mkdir /mnt/cos Copy 挂载，其中ourl指定了地域链接。 cosfs examplebucket-1250000000 /mnt/cos -ourl=http://cos.shanghai.myqcloud.com Copy 挂载之后就可以像对待普通文件系统的方式来操作 COS 中的文件了。 "},{"title":"取消挂载​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#取消挂载","content":"umount /mnt/cos Copy "},{"title":"开机自动挂载​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#开机自动挂载","content":"// TODO 对象存储 COSFS 工具 - 工具指南 - 文档中心 - 腾讯云↩Releases · tencentyun/cosfs↩ "},{"title":"重置 MySQL root 密码","type":0,"sectionRef":"#","url":"blog/reset-mysql-root-password","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#前言","content":"注意：如果你的数据库中存有重要数据，请在保证机器离线的情况下进行以下的操作，最稳妥的办法就是拔掉网线！ "},{"title":"方法一：修改配置文件​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#方法一修改配置文件","content":""},{"title":"开启安全模式​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#开启安全模式","content":"修改 MySQL 的配置文件。 vi /etc/my.cnf Copy 在[mysqld]段里加上一行skip-grant-tables，保存并退出。 "},{"title":"重新启动 MySQL​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#重新启动-mysql","content":"service mysqld restart Copy "},{"title":"修改密码​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#修改密码","content":"mysql -uroot use mysql; update user set Password=password('newpass') where User='root'; flush privileges; exit; Copy "},{"title":"关闭安全模式​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#关闭安全模式","content":"将第一步在 MySQL 配置文件里加入的skip-grant-tables删掉。 "},{"title":"完成​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#完成","content":"重启 MySQL 之后就可以用新密码登录了。 service mysqld restart Copy "},{"title":"方法二：通过命令行传递参数​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#方法二通过命令行传递参数","content":""},{"title":"停止 MySQL​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#停止-mysql","content":"service mysqld stop Copy "},{"title":"以不检查权限的方式启动 MySQL​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#以不检查权限的方式启动-mysql","content":"mysqld --skip-grant-tables &amp; Copy "},{"title":"修改密码​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#修改密码-1","content":"mysql -uroot Copy use mysql; update user set Password=password('newpass') where User='root'; flush privileges; exit; Copy "},{"title":"完成​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#完成-1","content":"用正常的方式重启 MySQL 之后就可以用新密码登录了。 service mysqld restart Copy "},{"title":"Scoop：最好用的 Windows 包管理器（或许是）","type":0,"sectionRef":"#","url":"blog/scoop-the-windows-package-manager","content":"","keywords":""},{"title":"引入 Scoop​","type":1,"pageTitle":"Scoop：最好用的 Windows 包管理器（或许是）","url":"blog/scoop-the-windows-package-manager#引入-scoop","content":"包管理器用于管理软件的生命周期：安装软件及其依赖，配置软件环境变量、更新软件和卸载软件。 Scoop1 是 Windows 上的一款包管理器，它是用 PowerShell 编写的，它可以帮助使用者特别是开发人员管理软件环境，快速构建开发环境。常用的开发工具都可以通过 Scoop 安装和管理。 Scoop 的本质是一系列 PowerShell 脚本的集合，所以运行 Scoop 需要 PowerShell 环境。并且它是针对 Windows 系统设计的，不具有跨平台性。 Scoop 对软件的管理功能依赖于提前定义好的针对每个软件包的配置文件，这些文件为 JSON 格式，称为 Manifest，由众多开发者维护，并托管在 Github。一个 Manifest 对应一个软件，其中包含了该软件的下载地址、安装/卸载脚本和其它必要信息。存放 Manifest 的仓库被称为 Bucket，对应一个 Git 仓库。Manifest 和 Bucket 是 Scoop 中的核心概念。 Scoop 对 Manifest 和 Bucket 的管理依赖于 Git。目前 Scoop 的官方 Bucket 托管在 GitHub。 Scoop 安装软件的过程依赖于 7-zip 和其它类型的解包软件如 innounp，Scoop 会将安装包里的文件解压至软件安装目录。.zip、.7z、.msi和大部分的.exe文件都能解包，软件的安装过程都是自动的，并不是传统的可视化界面方式，不需要人工干预，都由 Scoop 自动管理，程序文件放在统一的位置。软件开发者并不需要专门为 Scoop 制作专门的安装包，通用的软件安装程序都可以通过 Scoop 安装。 通过 Scoop 安装的软件大多是「绿色软件」，即不会写入注册表、不会创建桌面快捷方式，软件单独运行，不会有过多的依赖。Scoop 会根据 Manifest 中的信息为软件创建开始菜单中的快捷方式、创建命令链接、配置环境变量，通过 Scoop 安装软件不会污染系统环境。 "},{"title":"安装前准备​","type":1,"pageTitle":"Scoop：最好用的 Windows 包管理器（或许是）","url":"blog/scoop-the-windows-package-manager#安装前准备","content":"Scoop 的安装和使用都需要访问到 Github，考虑到国内网络情况的特殊性，请你自备代理软件以确保能正常访问 GitHub。 大部分的命令行应用不会读取系统代理设置，所以有些情况下及时你启动了代理软件命令行应用也不会通过代理软件访问网络，你可能需要手动设置命令行环境的代理。 在 PowerShell 中，你可以执行以下命令来设置代理，请酌情替换其中的地址和端口号。 $Env:http_proxy=&quot;http://127.0.0.1:11223&quot; $Env:https_proxy=&quot;http://127.0.0.1:11223&quot; Copy 该命令只在当前会话生效，当你关闭了 PowerShell 再次打开一个新的会话时则你需要再次执行该命令才能让代理设置生效。 你可以将这些命令写入$PROFILE文件来避免在每次新会话中重复执行命令的工作。PowerShell 在每次会话启动之后都会执行一次$PROFILE配置文件中的命令。 以下命令用于创建并用记事本打开$PROFILE文件。 if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE Copy 在打开的记事本中写入设置代理的命令，保存该文件，并重新打开 PowerShell 即可生效。 $Env:http_proxy=&quot;http://127.0.0.1:11223&quot; $Env:https_proxy=&quot;http://127.0.0.1:11223&quot; Copy "},{"title":"前提​","type":1,"pageTitle":"Scoop：最好用的 Windows 包管理器（或许是）","url":"blog/scoop-the-windows-package-manager#前提","content":"Scoop 依赖以下系统环境才能正常工作。 PowerShell 5+.NET Framework 4.5+ 对于现代的 Windows 10 系统来说，这些条件已自动满足，对于较为古老的 Windows 7 系统用户来说，你可能需要手动升级 PowerShell 到PowerShell 5，并安装.NET Framework 4.5。 Scoop 依赖 Git 和 7-zip 来完成基本的工作，但是你不需要手动安装这些软件。你只需要确保良好的网络环境。 "},{"title":"设置安装位置​","type":1,"pageTitle":"Scoop：最好用的 Windows 包管理器（或许是）","url":"blog/scoop-the-windows-package-manager#设置安装位置","content":"// TODO 补充此章节，还有各个步骤的截图 "},{"title":"安装 Scoop​","type":1,"pageTitle":"Scoop：最好用的 Windows 包管理器（或许是）","url":"blog/scoop-the-windows-package-manager#安装-scoop","content":"接下来的命令都在 PowerShell 中执行。 下面的命令用于允许执行外部 PowerShell 脚本。你可能看到提示信息，请输入「Y」并按下回车键。 Set-ExecutionPolicy RemoteSigned -scope CurrentUser Copy 下面的命令用于安装 Scoop。 Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh') Copy 在安装完成之后你将得到一个新的可执行命令scoop。下面的命令用于安装 7-zip 和 Git。 scoop install 7-zip git Copy 等待命令执行完毕之后你就可以在命令行中使用7z和git命令，Scoop 已经为你配置好了环境变量和命令链接。 在安装好 Git 之后你需要为 Git 设置代理，以下命令用来为 Git 设置代理，请酌情替换其中的地址和端口号。 git config --global http.proxy http://127.0.0.1:11223 git config --global https.proxy https://127.0.0.1:11223 Copy 对 Git 的设置是永久性的，以下命令用于取消为 Git 设置代理，使用时请去掉注释前缀。 # git config --global --unset http.proxy # git config --global --unset https.proxy Copy 下面的命令用于添加extras软件仓库。 scoop bucket add extras Copy "},{"title":"Scoop 的目录结构​","type":1,"pageTitle":"Scoop：最好用的 Windows 包管理器（或许是）","url":"blog/scoop-the-windows-package-manager#scoop-的目录结构","content":"// TODO 补充此章节，还有各个步骤的截图 "},{"title":"Scoop 软件管理命令​","type":1,"pageTitle":"Scoop：最好用的 Windows 包管理器（或许是）","url":"blog/scoop-the-windows-package-manager#scoop-软件管理命令","content":"命令\t示例\t备注scoop search &lt;关键词&gt;\tscoop search firefox\t搜索和关键词相关的软件包 scoop info &lt;包名&gt;\tscoop info firefox\t查看软件包信息 scoop install &lt;包名&gt;\tscoop install nodejs-lts adopt8-hotspot\t安装指定软件，可以一次性安装多个软件，用空格分割这些软件名 scoop uninstall &lt;包名&gt;\tscoop uninstall nodejs-lts\t卸载指定软件 scoop reinstall &lt;包名&gt;\tscoop reinstall nodejs-lts\t重新安装指定软件 scoop reset &lt;包名&gt;\tscoop reset python\t重新执行软件安装后脚本，以解决冲突 scoop list 列出所有已安装软件 scoop list &lt;关键词&gt;\tscoop list node\t列出和关键词相关的已安装软件 scoop status 查询更新信息 scoop update &lt;包名&gt;\tscoop update vscode\t更新指定的软件 scoop update 更新 Scoop 和所有仓库信息 "},{"title":"Scoop 仓库管理命令​","type":1,"pageTitle":"Scoop：最好用的 Windows 包管理器（或许是）","url":"blog/scoop-the-windows-package-manager#scoop-仓库管理命令","content":"仓库相关命令均以scoop bucket开始。 命令\t示例\t备注scoop bucket known 列出知名软件仓库 scoop bucket add &lt;知名仓库名&gt;\tscoop bucket add jetbrains\t添加知名软件仓库，不用输入仓库地址 scoop bucket add &lt;别名&gt; &lt;仓库地址&gt;\tscoop bucket add bobo2334 https://github.com/bobo2334/scoop-bucket.git\t添加第三方软件仓库 scoop bucket rm &lt;别名&gt;\tscoop bucket rm nerd-fonts\t移除软件仓库 scoop bucket list 列出所有已添加的软件仓库 "},{"title":"卸载 Scoop​","type":1,"pageTitle":"Scoop：最好用的 Windows 包管理器（或许是）","url":"blog/scoop-the-windows-package-manager#卸载-scoop","content":"如果 Scoop 不能让你满意的话，你可以用下面的命令来移除 Scoop。这将会删除所有你用 Scoop 安装的软件，最后删除 Scoop 它自身。 scoop uninstall scoop Copy Scoop↩ "},{"title":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","type":0,"sectionRef":"#","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#前言","content":"在用 IntelliJ IDEA 运行 Java Web 项目时，在 Tomcat 的日志输出区域会出现乱码，效果如下图所示。 在网络上查了一些资料 1，记录下解决办法。  "},{"title":"原因分析​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#原因分析","content":"可能是因为 IDEA 控制台中所采用的字符编码与 Tomcat 输出所采用的字符编码不一致，导致了出现乱码。 IDEA 控制台输出采用的是 GBK 编码，Tomcat 输出采用的是 UTF-8 编码。 "},{"title":"解决办法​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#解决办法","content":""},{"title":"法一：修改 IDEA 控制台输出编码为 UTF-8​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#法一修改-idea-控制台输出编码为-utf-8","content":"在 IDEA 的上方工具栏中，依次选择Help-&gt;Edit Custome VM Options...。  在vmoptions中添加如下一行参数，之后重启 IDEA。 -Dfile.encoding=UTF-8 Copy 该文件实际位于C:\\Users\\&lt;用户名&gt;\\AppData\\Roaming\\JetBrains\\IntelliJIdea2020.3\\idea64.exe.vmoptions，所以直接修改此文件应该也可行。  "},{"title":"法二：修改 Tomcat 输出编码为 GBK​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#法二修改-tomcat-输出编码为-gbk","content":"在 Tomcat 安装位置下的 conf 文件中存在logging.properties配置文件。 修改其中的配置，将java.util.logging.ConsoleHandler.encoding的属性由UTF-8改为GBK。 保存之后重启 Tomcat 即可。  "},{"title":"结果​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#结果","content":"两种方法均可以解决问题。  idea tomcat 乱码问题的解决及相关设置 - 行而思 - 博客园↩ "},{"title":"自建 Zerotier 行星节点","type":0,"sectionRef":"#","url":"blog/self-hosted-zerotier-controller","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"自建 Zerotier 行星节点","url":"blog/self-hosted-zerotier-controller#前言","content":"自建 ZeroTier Planet 行星服务器可以解决两个问题： 官方免费版本有 50 个设备连接数的限制提升网络稳定性 "},{"title":"运行项目​","type":1,"pageTitle":"自建 Zerotier 行星节点","url":"blog/self-hosted-zerotier-controller#运行项目","content":"使用docker-compose可以快速运行项目。docker-compose.yml的内容如下。 version: '3' services: ztncui: image: keynetworks/ztncui restart: unless-stopped ports: - '3000:3000' environment: MYADDR: 172.38.38.38 HTTP_ALL_INTERFACES: &quot;yes&quot; ZTNCUI_PASSWD: PASS TZ: Asia/Shanghai volumes: - ztncui:/opt/key-networks/ztncui/etc/ - zerotier-one:/var/lib/zerotier-one/ volumes: ztncui: null zerotier-one: null Copy 其中一些环境变量需要设置。 MYADDR：机器的公网 IP 地址HTTP_ALL_INTERFACES：监听所有网络接口ZTNCUI_PASSWD：设置admin用户的密码。 ztncui和zerotier-one两个 Volume 持久化配置信息，防止重新创建容器后丢失配置。 在当前目录下用docker-compose up -d启动容器。 防火墙需要放行3000端口。 "},{"title":"网络配置​","type":1,"pageTitle":"自建 Zerotier 行星节点","url":"blog/self-hosted-zerotier-controller#网络配置","content":"访问IP:3000可以进入网页管理 UI，也可以用反响代理服务器来转发此端口的流量，并用域名和 HTTPS 访问。用户名是admin，密码是你之前配置的环境变量ZTNCUI_PASSWD的值。 控制面板的使用方法和操作逻辑和官方控制面板差不多。 在底部的导航栏中点击「Networks」，再点击Add network创建一个网络。给网络起一个名字之后你就能在「Networks」中看见你刚刚创建的网络了。  点击该网络名就能进入该网络设置的设置页面。  点击「Easy setup」按钮为网络设置网段。在该页面中点击「Generate network address」按钮可以随机生成网段，点击「Submit」按钮保存信息。  点击「Private」按钮设置私有网络/公开网络。  点击「Routes」按钮设置静态路由。  "},{"title":"客户端​","type":1,"pageTitle":"自建 Zerotier 行星节点","url":"blog/self-hosted-zerotier-controller#客户端","content":"使用各个平台的原生客户端直接可以连接到自建网络。Network ID 填自己的就行了。 客户端在加入私有网络的时候需要在网络管理页面手动批准认证；勾选对应的「Authorized」列选框即可。  "},{"title":"参考资料​","type":1,"pageTitle":"自建 Zerotier 行星节点","url":"blog/self-hosted-zerotier-controller#参考资料","content":"ZeroTier Planet 行星服务器，一键私有部署，可突破 50 台设备限制 - 小众软件Jonnyan404/zerotier-planet: 一分钟自建 zerotier-planetkey-networks/ztncui: ZeroTier network controller UIkey-networks/ztncui-containerized: A Docker image that contains ZeroTier One and ztncui to set up a standalone ZeroTier network controller with a web user interface in a container. "},{"title":"SSH 密钥登录","type":0,"sectionRef":"#","url":"blog/ssh-certificate-authentication","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#前言","content":"SSH 默认采用密码登录，这种方法有很多缺点，简单的密码不安全，复杂的密码不容易记忆，每次手动输入也很麻烦。密钥登录是比密码登录更好的解决方案。1 "},{"title":"生成秘钥​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#生成秘钥","content":"可以用 OpenSSH 中的ssh-keygen命令行工具来生成秘钥。-t参数指定了加密方式，通常为rsa或dsa。 ssh-keygen -t rsa Copy 生成的密钥文件默认就会是~/.ssh/id_rsa（私钥）和~/.ssh/id_rsa.pub（公钥）。 也可以用 PuTTY 中提供的 PuTTY Key Generator（puttygen.exe）2 来用可视化用户界面来生成秘钥文件。  "},{"title":"把公钥放在服务器上​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#把公钥放在服务器上","content":"用户公钥保存在~/.ssh/authorized_keys文件中，如果该文件不存在，你可以手动创建一个。 然后将公钥的文本内容放入其中，每行一个。 "},{"title":"关闭密码登录​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#关闭密码登录","content":"编辑/etc/ssh/sshd_config文件，找到对应的配置项并修改。 # 不允许密码直接登录 PasswordAuthentication no # 不允许空密码登录 PermitEmptyPasswords no # 不允许交互式密码登录 ChallengeResponseAuthentication no # 不允许 root 用户使用密码登录 PermitRootLogin prohibit-password # 使用秘钥登录 PubkeyAuthentication yes Copy 重启sshd，让配置生效。 sudo systemctl restart sshd Copy "},{"title":"测试配置是否生效​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#测试配置是否生效","content":"使用ssh命令连接远程服务器，使用-i参数传递私钥文件。 ssh -i .\\centos7\\.vagrant\\machines\\default\\virtualbox\\private_key vagrant@192.168.33.12 Copy "},{"title":"参考资料​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#参考资料","content":"How To Configure SSH Key-Based Authentication on a Linux Server | DigitalOcean14.3. Using OpenSSH Certificate Authentication Red Hat Enterprise Linux 6 | Red Hat Customer Portal SSH 密钥登录 - SSH 教程 - 网道↩Download PuTTY: latest release (0.76)↩ "},{"title":"通过代理连接 SSH 服务器","type":0,"sectionRef":"#","url":"blog/ssh-under-proxy","content":"","keywords":""},{"title":"正文​","type":1,"pageTitle":"通过代理连接 SSH 服务器","url":"blog/ssh-under-proxy#正文","content":"下面的命令用于通过 SOCKS5 代理连接到 SSH 服务器。其中127.0.0.1:7890是本地 SOCKS5 代理的地址和端口号。 ssh -oProxyCommand=&quot;nc -x 127.0.0.1:7890 %h %p&quot; root@198.198.198.198 Copy "},{"title":"参考资料​","type":1,"pageTitle":"通过代理连接 SSH 服务器","url":"blog/ssh-under-proxy#参考资料","content":"透过代理连接 SSH [Lainme's Blog] "},{"title":"UFW：简单易上手的防火墙规则管理工具","type":0,"sectionRef":"#","url":"blog/ufw","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#前言","content":"UFW 是一款在 Debian 系系统中可用的防火墙规则管理工具，可以帮助你快速配置各种服务的端口访问权限，而不用书写冗长的 iptables 规则命令。 "},{"title":"安装​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#安装","content":"可以使用apt快速安装。 apt install ufw Copy "},{"title":"启用/禁用​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#启用禁用","content":"使用以下命令来启用 UFW，并且会随着系统开启而启动。 ufw enable Copy 使用以下命令来停止 UFW。 ufw disable Copy "},{"title":"默认行为​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#默认行为","content":"使用ufw default命令来配置默认行为，以下两条是 UFW 初始化的默认行为；默认拒绝所有入流量，允许所有出流量。 ufw default deny incoming ufw default allow outgoing Copy 你可以使用ufw default命令来覆盖默认行为，使用allow/deny和incoming/outgoing/routed组合。 使用下面的命令来查看当前的默认行为。 ufw status verbose Copy  "},{"title":"添加规则​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#添加规则","content":""},{"title":"放行/禁止端口​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#放行禁止端口","content":"以下命令用于放行 53 端口的 TCP 和 UDP 流量。 ufw allow 53 Copy 以下命令用于仅放行 53 端口的 TCP 流量。 ufw allow 53/tcp Copy 以下命令用于仅放行 53 端口的 UDP 流量。 ufw allow 53/udp Copy 还可以一次放行一个范围内的端口。 ufw allow 1000:2000/tcp Copy 禁止命令就是用deny替代allow。 ufw deny 53 ufw deny 53/tcp ufw deny 53/udp ufw deny 1000:2000/tcp Copy "},{"title":"放行/禁止 IP​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#放行禁止-ip","content":"ufw allow from 1.2.3.4 ufw deny from 1.2.3.4 Copy "},{"title":"删除规则​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#删除规则","content":"使用ufw delete命令来删除一条之前添加的规则。 ufw delete allow 53 ufw delete deny from 1.2.3.4 Copy 或者使用下面的命令列出添加的规则并编号，通过编号删除规则。 ufw status numbered ufw delete 2 Copy  "},{"title":"常用服务端口​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#常用服务端口","content":"在添加或删除关于端口的规则时，除了手动指出端口号之外，还可以通过服务名称来放行/禁止端口。 ufw allow ssh ufw deny ssh ufw delete allow ssh ufw delete deny ssh Copy 服务名和端口号定义在/etc/services文件中。在其中有关ssh服务的部分是这样写的。 ssh 22/tcp # SSH Remote Login Protocol Copy UFW 会根据此文件内容管理端口。 常用的服务名称有ssh、http和https等。 "},{"title":"参考资料​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#参考资料","content":"Uncomplicated Firewall (ufw) - Debian WikiUFW - Community Help WikiUncomplicated Firewall - WikipediaAn Introduction to Uncomplicated Firewall (UFW) - Linux.comUFW Tutorial: How To Set Up a Firewall with UFW on Ubuntu 20.04 | ArubaCloud.comHow To Set Up a Firewall with UFW on Ubuntu 20.04 | DigitalOcean "},{"title":"iterm2 对 tmux 的特殊支持","type":0,"sectionRef":"#","url":"blog/tmux-integration-in-iterm2","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"iterm2 对 tmux 的特殊支持","url":"blog/tmux-integration-in-iterm2#前言","content":"tmux1 是一款非常好用的终端复用工具，它可以帮助你快速地保存和恢复工作现场。 使用 tmux 的时候有许多快捷键需要记忆，并且窗格切换和窗格的上下滚动并不方便；tmux 的快捷键还可能和其它软件的快捷键有冲突。 iterm22 是 macOS 中的一个终端模拟器软件，它对 tmux 有独家支持，可以在控制模式下运行 tmux。在这个模式中，tmux 会话表现和本地终端一样，可以使用 iterm2 的快捷键来进行多窗口和多窗格分隔，用鼠标切换窗口和窗格，并且用鼠标滚轮上下滚动窗格也能正常工作，不需要进 tmux 的复制模式来滚动窗格。 "},{"title":"使用​","type":1,"pageTitle":"iterm2 对 tmux 的特殊支持","url":"blog/tmux-integration-in-iterm2#使用","content":"不论是在本地使用 tmux，还是通过 ssh 使用远端的 tmux，iterm2 都支持使用 tmux 的控制模式。 tmux 的控制模式通过附加-CC参数来开启。 如tmux -CC命令会开启一个新的 tmux 会话，并启用控制模式，之后你的 iterm 会打开一个新的窗口，用于展示 tmux 会话；该窗口的表现和没使用 tmux 时一样，你不需要通过快捷键或 tmux 命令来新建多窗口和多窗格。使用 iterm2 的快捷键Command+D和Command+Shift+D来分隔窗格，使用Command+N来新建 Tab，使用Command+N来新建窗口。 使用如下命令来附加到一个已存在的 tmux 会话。 tmux ls tmux -CC attach -t 0 Copy 下面的命令用于创建一个名为main的会话，如果该会话存在的话则直接恢复该会话。 tmux -CC new -A -s main Copy 或者在通过 SSH 连接到服务器的时候直接执行此命令，直接打开一个 tmux 会话。 ssh -t root@1.1.1.1 'tmux -CC new -A -s main' Copy "},{"title":"参考资料​","type":1,"pageTitle":"iterm2 对 tmux 的特殊支持","url":"blog/tmux-integration-in-iterm2#参考资料","content":"tmux Integration Best Practices · Wiki · George Nachman / iterm2 · GitLab tmux | 我的学习笔记↩tmux Integration - Documentation - iTerm2 - macOS Terminal Replacement↩ "},{"title":"在 HTML 中使用 Unicode 代码","type":0,"sectionRef":"#","url":"blog/use-unicode-in-html","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#前言","content":"在某些情况下需要在 HTML 中嵌入特殊符号，但是 HTML 实体中并不包含这些符号，或是该实体符号不能被浏览器正确渲染，可以通过 Unicode 代码代替这些字符，以达到在网页中正确渲染该字符的目的。HTML 实体代码和字符对应的 Unicode 代码可以参考 HTML Standard1。 "},{"title":"声明网页编码​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#声明网页编码","content":"为了能在网页中正常显示 Unicode 字符，该网页必须使用 Unicode 编码，如 UTF-8。可在meta标签里声明网页编码，并确保 HTTP 头也使用此编码。 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; Copy "},{"title":"使用 HTML 实体​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#使用-html-实体","content":"在 HTML Standard1 中可以看到该符号的名字是Aacute;，可以在其前方加上&amp;来表示 HTML 命名字符。 Á &lt;p&gt;&amp;Aacute;&lt;/p&gt; Copy 但是并不是所有的命名字符都能被渲染出来，比如字符{。 &amp;lbrace; &lt;p&gt;&amp;lbrace;&lt;/p&gt; Copy "},{"title":"使用 Unicode 代码​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#使用-unicode-代码","content":"可以使用十六进制编码。 { &lt;p&gt;&amp;#x0007B;&lt;/p&gt; Copy 也可以使用十进制编码。 { &lt;p&gt;&amp;#123;&lt;/p&gt; Copy "},{"title":"参考资料​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#参考资料","content":"HTML、CSS、JS 对 unicode 字符的不同处理 - 我是小茗同学 - 博客园HTML Unicode UTF-8 HTML Standard↩ "},{"title":"Zerotier 异地组网","type":0,"sectionRef":"#","url":"blog/zerotier","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#前言","content":"Zerotier1 是一个优秀的异地组网解决方案。其优点是组网灵活、不需要更改现有网络结构，支持 P2P 和转发。 Zerotier 使用也不是没有限制，免费版本的最多加入 50 个客户端，不过对于个人来说肯定够用了。 "},{"title":"控制台​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#控制台","content":"在控制台 2 注册并登陆。 在创建网络后会得到一个 Network ID，此 ID 是唯一的，是客户端加入此网络所需的唯一参数。  在网络管理页面中，Access Control 控制客户端认证方式，如果选择PRIVATE则每个客户端的加入都需要在此页面经由你允许。  在 IPv4 Auto-Assign 中，可以对客户端的 IP 段进行配置，不和你原来的网络地址冲突即可。  在 Members 中你可以管理该网络下的所有客户端，勾选客户端对应的Auth?选框即可让客户端加入此网络。每个客户端在加入的时候会自动分配一个 IP 地址，你还可以手动分配客户端的 IP 地址。  在多个客户端加入网络后，即使处于不同的网络环境下，客户端都可以通过分配到的 IP 互相访问。 "},{"title":"客户端​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#客户端","content":"Zerotier 在常用平台上都有客户端，有图形化的有命令行的。  "},{"title":"自动 NAT​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#自动-nat","content":"在前面的方案中， 如果多个机器互相访问就需要每个机器都安装 Zerotier 客户端并加入同一个网络。 借助 OpenWrt 和 Zerotier 可以暴露整个局域网到 Zerotier 网络中，只需要 OpenWrt 中的 Zerotier 加入网络即可。 勾选「自动允许客户端 NAT」即可。  许多 OpenWrt 的发行版都集成了此软件包。可以参考如下 Telegram 频道： Telegram: Contact @OpenWRTcnTelegram: Contact @aixiaoshaoTelegram: Contact @passwallOpenWRT233 OpenWrt 不需要作为你的主路由，它可以通过 LAN 口接入你现有的局域网，关闭 LAN 口的 DHCP 服务，作为旁路由使用。 你还需要在 Zerotier 控制台中配置静态路由。  在添加静态路由的时候Destination填局域网的网络地址，(Via)为下一跳地址，即 OpenWrt 路由器的 Zerotier 地址。 上面的静态路由配置将192.168.10.0/24局域网和192.168.11.0/24局域网暴露在 Zerotier 网络中。172.22.39.15和172.22.105.60分别是两个 OpenWrt 路由器在 Zerotier 网络中的地址，这两个路由器均配置了自动允许客户端 NAT。 这样做的优点是管理方便，不需要在每个机器上安装客户端并且加入网络。并且即使你在使用移动网络的时候可以直接访问到家里局域网的 IP，并且还是通过局域网 IP 访问，并不需要修改软件配置。 大致的网络拓扑图如下。在外使用移动网络的情况下，你可以使用192.168.10.0/24或192.168.11.0/24网段的内网地址访问局域网 A 或局域网 B 内的资源。 如果局域网 A 中的某台设备需要访问局域网 B 中的资源，还是需要在该设备上安装 Zerotier 客户端，并且加入统一 Zerotier 网络，然后就可以通过192.168.11.0/24的内网 IP 地址来访问局域网 B 中的资源了。  ZeroTier – Global Area Networking↩ZeroTier Central↩ "},{"title":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","type":0,"sectionRef":"#","url":"blog/use-pwsh-and-oh-my-posh3-on-windows","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#前言","content":"在 macOS 中用 zsh 配合 oh-my-zsh 可以打造出一个用的很舒服的终端，其实在 Windows 中也可以。 在 Windows 中可以用 pwsh1 和 oh-my-posh2 打造出一个好用的终端。 Windows 自带的 PowerShell 版本低，所以需要额外安装一个新版本的 pwsh，而不是用系统提供的。 oh-my-posh3 现在已基于 Go 语言重构，是一个跨平台的命令行工具，安装和配置方式和 oh-my-posh2 相比有些变化。 终端软件用的是 Windows Terminal3，这是一个现代化的、可自定义的好看的终端模拟器。 历史命令提示是通过 PowerShell 的 PSReadLine4 模组实现的。 "},{"title":"前置条件​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#前置条件","content":"Scoop5 是 Windows 上的一款基于 PowerShell 的包管理器，接下来的软件都是用 Scoop 安装的，因为它能很方便地管理软件和配置环境变量。Scoop 的安装及使用不在本文的讨论范围内。 由于多数软件来源于 Github，在网络不好的情况下可能会安装失败，请自行配置网络代理。 以下命令用于在 PowerShell 中配置代理，请自行替换地址和端口号。 $Env:http_proxy=&quot;http://127.0.0.1:11223&quot;; $Env:https_proxy=&quot;http://127.0.0.1:11223&quot; Copy Scoop 基于 Git，为了让 Scoop 能正常工作，请参考以下命令用于配置 Git 的代理。 git config --global http.proxy http://127.0.0.1:11223 git config --global https.proxy https://127.0.0.1:11223 Copy "},{"title":"安装 pwsh​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-pwsh","content":"scoop install pwsh Copy "},{"title":"安装 Windows Terminal​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-windows-terminal","content":"scoop install windows-terminal Copy "},{"title":"安装 Cascadia Code 字体​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-cascadia-code-字体","content":"部分命令行字符需要正确配置字体才能正常显示，安装字体需要管理员权限，注意授权提示。 更多命令行字符字体可参考 nerd-fonts6 项目。 scoop install sudo scoop bucket add nerd-fonts sudo scoop install CascadiaCode-NF-Mono Copy "},{"title":"在 Windows Terminal 中集成 pwsh​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#在-windows-terminal-中集成-pwsh","content":"在 Window Terminal 中添加一个新的终端配置。命名为「PWSH」，命令为pwsh。设置字体为「CaskaydiaCove NF」。     保存此配置，在「启动」选项卡中把刚刚新增的「PWSH」配置文件设置为默认配置文件。  打开 PWSH，配置完成。  "},{"title":"安装 oh-my-posh3​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-oh-my-posh3","content":"目前，在 oh-my-posh 的官方文档中使用的安装命令为scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json，请不要使用该命令。 oh-my-posh3 已存在于 Scoop 的 main 仓库中，请安装此软件包，后面的配置命令跟包名有关。 scoop install oh-my-posh3 Copy 接下来编写 PWSH 的用户配置，以下命令用于创建一个配置文件并用记事本打开。该配置文件的作用是在每次 pwsh 初始化的时候自动执行其中的命令。 if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE Copy 在弹出的记事本里写入 oh-my-posh 的初始化命令，该命令会在每次 pwsh 初始化的时候执行。 $env:POSH_GIT_ENABLED = $true oh-my-posh --init --shell pwsh --config &quot;$(scoop prefix oh-my-posh3)\\themes\\wopian.omp.json&quot; | Invoke-Expression Copy 重新打开终端就能看到一个带主题的 PowerShell，如果有些字符显示不出来就是字体没有配置好。  "},{"title":"配置历史命令提示​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#配置历史命令提示","content":"在 PWSH 中执行命令，安装 PSReadLine 模组。在安装时请输入「Y」来确认安装。以下命令用于安装 PSReadLine，请在 PWSH 中执行而不是在 PowerShell 中。 Install-Module PSReadLine Copy  然后编辑$PROFILE文件，在每次终端打开的时候对PSReadLine进行初始化。 notepad $PROFILE Copy 在配置文件中附加上以下内容。 Set-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录 Set-PSReadlineKeyHandler -Key Tab -Function Complete # 设置 Tab 键补全 Set-PSReadLineKeyHandler -Key &quot;Ctrl+d&quot; -Function MenuComplete # 设置 Ctrl+d 为菜单补全和 Intellisense Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo # 设置 Ctrl+z 为撤销 Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向上键为后向搜索历史记录 Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward # 设置向下键为前向搜索历史纪录 Copy 保存配置文件，重启终端，就能看到一个带历史命令提示的终端了。  "},{"title":"更改 oh-my-posh 的主题​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#更改-oh-my-posh-的主题","content":"oh-my-posh 提供了多套主题可供选择，在 PWSH 中执行以下命令对所有主题进行预览。 Get-ChildItem -Path &quot;$(scoop prefix oh-my-posh3)\\themes\\*&quot; -Include '*.omp.json' | Sort-Object Name | ForEach-Object -Process { $esc = [char]27 Write-Host &quot;&quot; Write-Host &quot;$esc[1m$($_.BaseName)$esc[0m&quot; Write-Host &quot;&quot; oh-my-posh --config $($_.FullName) --pwd $PWD Write-Host &quot;&quot; } Copy  其中以.omp结尾的是主题文件的名称，如果需要使用某个主题就替换掉$PROFILE文件中初始化命令中的配置文件名就可以了。 以下命令用于用记事本打开$PROFILE文件。 notepad $PROFILE Copy 在打开的记事本中你会看到 oh-my-posh 的初始化命令。 oh-my-posh --init --shell pwsh --config &quot;$(scoop prefix oh-my-posh3)\\themes\\wopian.omp.json&quot; | Invoke-Expression Copy 将你中意的主题名称替换命令中的wopian.omp，保存该配置文件然后重启终端就可以看到新主题的效果了。 "},{"title":"更改 Windows Terminal 的配色​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#更改-windows-terminal-的配色","content":"在 Windows Terminal 中默认有多套配色方案可选，这里推荐一套自定义的配色方案，来自于 Dracula7。 在 Windows Terminal 的设置页面中，点击「打开 JSON 文件」，在该文件的schemes数组中添加一个配色方案对象。 &quot;schemes&quot;: [ { &quot;name&quot;: &quot;Dracula&quot;, &quot;cursorColor&quot;: &quot;#F8F8F2&quot;, &quot;selectionBackground&quot;: &quot;#44475A&quot;, &quot;background&quot;: &quot;#282A36&quot;, &quot;foreground&quot;: &quot;#F8F8F2&quot;, &quot;black&quot;: &quot;#21222C&quot;, &quot;blue&quot;: &quot;#BD93F9&quot;, &quot;cyan&quot;: &quot;#8BE9FD&quot;, &quot;green&quot;: &quot;#50FA7B&quot;, &quot;purple&quot;: &quot;#FF79C6&quot;, &quot;red&quot;: &quot;#FF5555&quot;, &quot;white&quot;: &quot;#F8F8F2&quot;, &quot;yellow&quot;: &quot;#F1FA8C&quot;, &quot;brightBlack&quot;: &quot;#6272A4&quot;, &quot;brightBlue&quot;: &quot;#D6ACFF&quot;, &quot;brightCyan&quot;: &quot;#A4FFFF&quot;, &quot;brightGreen&quot;: &quot;#69FF94&quot;, &quot;brightPurple&quot;: &quot;#FF92DF&quot;, &quot;brightRed&quot;: &quot;#FF6E6E&quot;, &quot;brightWhite&quot;: &quot;#FFFFFF&quot;, &quot;brightYellow&quot;: &quot;#FFFFA5&quot; } ] Copy 保存该 JSON 文件，重启 Windows Terminal，在 PWSH 的外观配置中选择新添加的 Dracula 配色方案。前文中我用的配色方案就是 Dracula。  "},{"title":"在 VS Code 里使用​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#在-vs-code-里使用","content":"在 VS Code 的配置文件settings.json中加入以下配置。 &quot;terminal.integrated.profiles.windows&quot;: { &quot;Windows PowerShell&quot;: { &quot;path&quot;: &quot;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe&quot; }, &quot;PWSH&quot;: { &quot;path&quot;: &quot;pwsh&quot; } }, &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;PWSH&quot;, &quot;terminal.integrated.fontFamily&quot;: &quot;'CaskaydiaCove NF'&quot; Copy PowerShell/PowerShell: PowerShell for every system!↩Home | Oh My Posh↩microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place!↩PowerShell/PSReadLine: A bash inspired readline implementation for PowerShell↩Scoop↩Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher↩Dark theme for Windows Terminal and 218+ apps — Dracula↩ "},{"title":"有意思的项目","type":0,"sectionRef":"#","url":"docs/bookmarks/interesting-projects","content":"有意思的项目 名称\t备注\t链接restic\tGo 语言实现的、跨平台的、支持多种备份目的地类型的备份工具。\trestic/restic: Fast, secure, efficient backup program duplicati\tC# 语言实现的、跨平台的、支持多种备份目的地类型和备份策略的备份工具，有一个基于 Web 的 GUI。\tduplicati/duplicati: Store securely encrypted backups in the cloud! minio\t自建对象存储服务，兼容 Amazon S3 协议。\tminio/minio: High Performance, Kubernetes Native Object Storage rclone\t支持各种网络存储的 rsync。\trclone/rclone: &quot;rsync for cloud storage&quot; - Google Drive, S3, Dropbox, Backblaze B2, One Drive, Swift, Hubic, Wasabi, Google Cloud Storage, Yandex Files transfer.sh\t通过 HTTP 请求快速上传/分享临时文件，可以自建。\tdutchcoders/transfer.sh: Easy and fast file sharing from the command-line. wifi-card\t生成含有 WIFI 信息的二维码，可以扫描以快速连接 WIFI。\tbndw/wifi-card: 📶 Print a QR code for connecting to your WiFi (wificard.io) nginxconfig.io\t在线生成 Nginx 配置文件。\tdigitalocean/nginxconfig.io: ⚙️ NGINX config generator on steroids 💉 zx\t用 JavaScript 编写服务器脚本，适合对 Bash 变成不太精通的前端开发者。\tgoogle/zx: A tool for writing better scripts modern-unix\t收集了一些能代替 Unix 中的部分命令工作的现代化软件。\tibraheemdev/modern-unix: A collection of modern/faster/saner alternatives to common unix commands. certbot\t基于 ACME 协议的 TLS 证书自动签发工具，证书来自 Let’s Encrypt。\tcertbot/certbot: Certbot is EFF's tool to obtain certs from Let's Encrypt and (optionally) auto-enable HTTPS on your server. It can also act as a client for any other CA that uses the ACME protocol. caddy\t以自动 HTTP、简易配置而出名的跨平台 Web 服务器，用 Go 语言实现。\tcaddyserver/caddy: Fast, multi-platform web server with automatic HTTPS portainer\t轻量级 Docker GUI，基于 Web。以 Docker 容器的方式运行。\tportainer/portainer: Making Docker and Kubernetes management easy. watchtower\t自动更新 Docker 镜像，并用相同的创建命令重新用新版本镜像创建容器。\tcontainrrr/watchtower: A process for automating Docker container base image updates. plantuml\t声明式绘图工具，Java 实现。\tplantuml/plantuml: Generate UML diagram from textual description mermaid\t声明式绘图工具，JavaScript 实现，可以在浏览器中直接渲染，支持的图种类较少。\tmermaid-js/mermaid: Generation of diagram and flowchart from text in a similar manner as markdown foam\t个人知识库/笔记整理软件，基于 VS Code 插件。\tfoambubble/foam: A personal knowledge management and sharing system for VSCode siyuan\t国产的个人知识库/笔记整理软件。类似于 Notion，以块为基础结构。可以做到完全离线工作，数据文件都在本地，是 JSON 格式而不是 Markdown。基于 Electron。\tsiyuan-note/siyuan: 📕 SiYuan is a local-first personal knowledge management system, supports fine-grained block-level reference, and Markdown WYSIWYG. rubick\t基于 Electron 的开源桌面工具箱，和 uTools 的设计很像，目前正在火热开发阶段，优势是开源。\tclouDr-f2e/rubick: 🔧 基于 electron 的开源工具箱，自由集成丰富插件。 mitmproxy\t网络抓包工具，有命令行版本和基于 Web 的 GUI 版本。\tmitmproxy/mitmproxy: An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers. flameshot\t功能强大的、易用的截图工具。\tflameshot-org/flameshot: Powerful yet simple to use screenshot software dracula-theme\t提供很多软件的统一风格的黑暗模式主题。\tdracula/dracula-theme: 🧛🏻‍♂️ One theme. All platforms. (github.com) epicgames-freegames-node\t自动领取 Epic 每周免费游戏的脚本，支持 2FA，遇到验证码可以在网页中解决，支持 Email、Telegram 和 Discord 推送验证码解决网址。\tclaabs/epicgames-freegames-node: Automatically login and redeem promotional free games from the Epic Games Store. Powered by Docker. composerize\t把docker run命令转换为 docker-compose.yml。\tmagicmark/composerize: 🏃→🎼 docker run asdlksjfksdf &gt; docker-composerize up croc\t命令行文件传输工具，跨平台，不需要公网 IP。\tGitHub - schollz/croc: Easily and securely send things from one computer to another terminalizer\t记录命令行历史，以 GIF 图片或网页播放器分享。\tGitHub - faressoft/terminalizer: 🦄 Record your terminal and generate animated gif images or share a web player asciinema\t记录命令行历史，可以回放。\tasciinema/asciinema: Terminal session recorder 📹","keywords":""},{"title":"macOS 软件列表","type":0,"sectionRef":"#","url":"docs/bookmarks/macos-software-list","content":"macOS 软件列表 macOS - 小众软件Homebrew FormulaeiCHAIT/awesome-macOS:  A curated list of awesome applications, softwares, tools and shiny things for macOS.jaywcjlove/awesome-mac:  Now we have become very big, Different from the original idea. Collect premium software in various categories.苹果帝 - Appledi.com | 苹果美区账号 APPLE ID 免费账号共享","keywords":""},{"title":"VPS 相关书签","type":0,"sectionRef":"#","url":"docs/bookmarks/vps","content":"","keywords":""},{"title":"监控​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#监控","content":"欢迎来到古博 PING - 古博 PING "},{"title":"脚本​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#脚本","content":""},{"title":"aff​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#aff","content":"VPS 百科Telegram: Contact @vpscangVPS 大全 - 你的 VPS 仓库，提供 VPS 列表，库存，机房，价格等信息美国 vps 低至月付 1 刀，低价之王，超高性价比，VirMach 官方测速地址，各机房测试 IP – V2RaySSR 综合网TCM VPS 测评--云主机 VPS 交流推荐 "},{"title":"工具​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#工具","content":"Fake Person: male| Fake Person Generator/Fake Name GeneratorReggy - Chrome Web Store "},{"title":"Windows 软件列表","type":0,"sectionRef":"#","url":"docs/bookmarks/windows-software-list","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"Windows 软件列表","url":"docs/bookmarks/windows-software-list#参考资料","content":"Awesome-Windows/Awesome: 🎉 An awesome &amp; curated list of best applications and tools for Windows.Windows - 小众软件 "},{"title":"包管理​","type":1,"pageTitle":"Windows 软件列表","url":"docs/bookmarks/windows-software-list#包管理","content":"名称\t基因\t地址Scoop Scoop "},{"title":"视频播放​","type":1,"pageTitle":"Windows 软件列表","url":"docs/bookmarks/windows-software-list#视频播放","content":"名称\t基因\t地址QQ 影音 QQ 影音官方网站- 播放由我，创造由我 PotPlayer Global Potplayer VLC media player 官方下载：VLC media player，最棒的开源播放器 - VideoLAN "},{"title":"压缩解压​","type":1,"pageTitle":"Windows 软件列表","url":"docs/bookmarks/windows-software-list#压缩解压","content":"名称\t基因\t地址7-Zip 7-Zip Bandizip 6 Bandizip - 下载 Bandizip 6.x PeaZip PeaZip free archiver utility, open extract RAR TAR ZIP files "},{"title":"终端模拟器​","type":1,"pageTitle":"Windows 软件列表","url":"docs/bookmarks/windows-software-list#终端模拟器","content":"名称\t基因\t地址Windows Terminal microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place! "},{"title":"文本编辑​","type":1,"pageTitle":"Windows 软件列表","url":"docs/bookmarks/windows-software-list#文本编辑","content":"名称\t基因\t地址Notepad3 rizonesoft/Notepad3: Notepad like text editor based on the Scintilla source code. Notepad3 based on code from Notepad2 and MiniPath on code from metapath. Download Notepad3: Visual Studio Code Visual Studio Code - Code Editing. Redefined Typora Typora — a markdown editor, markdown reader. "},{"title":"SSH 连接​","type":1,"pageTitle":"Windows 软件列表","url":"docs/bookmarks/windows-software-list#ssh-连接","content":"名称\t基因\t地址MobaXterm Home Edition MobaXterm free Xserver and tabbed SSH client for Windows FinalShell SSH 工具 客户端 WindTerm kingToolbox/WindTerm: A quicker and better cross-platform SSH/Sftp/Shell/Telnet/Serial client. "},{"title":"数据库管理​","type":1,"pageTitle":"Windows 软件列表","url":"docs/bookmarks/windows-software-list#数据库管理","content":"名称\t基因\t地址DBeaver Community dbeaver/dbeaver: Free universal database tool and SQL client "},{"title":"代理​","type":1,"pageTitle":"Windows 软件列表","url":"docs/bookmarks/windows-software-list#代理","content":"名称\t基因\t地址Clash .NET ClashDotNetFramework/ClashDotNetFramework at main "},{"title":"图片处理​","type":1,"pageTitle":"Windows 软件列表","url":"docs/bookmarks/windows-software-list#图片处理","content":"名称\t基因\t地址Snipaste Snipaste "},{"title":"实用网站","type":0,"sectionRef":"#","url":"docs/bookmarks/useful-websites","content":"","keywords":""},{"title":"书籍文档​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#书籍文档","content":"Jiumo Search 鸠摩搜索 - 文档搜索引擎松鼠文库Kindle 电子书，mobi 电子书，epub 电子书，azw3 电子书，PDF,TXT 格式免费下载|Aibooks 积微书斋我爱电子书 - 注重体验与质量的电子书资源下载网站XmSearch 熊猫搜索-聚合文档搜索导航快吧软件--好东西，就是要分享！ - Fast8.CCSoBooks - 一起分享阅读的乐趣~ "},{"title":"Windows 软件​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#windows-软件","content":"果核剥壳 - 还原软件的本质腾龙工作室 - TenlonStudio.Com "},{"title":"Windows 系统镜像​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#windows-系统镜像","content":"MSDN, 我告诉你 - 做一个安静的工具站不忘初心博客 - 精简版系统官网UUP dump "},{"title":"Mac 软件​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#mac-软件","content":"MacWk - 精品 mac 软件下载精品 MAC 应用分享Mac 萌新网|最全的 Mac/Win/Linux 软件，科学软件，化学软件下载，软件首发站麦氪搜 (iMacSO.com)-我们致力于让您的 Mac 更有价值 ！mac 软件下载-分享优质 mac 软件游戏 - 苹果软件盒子 "},{"title":"网址导航​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#网址导航","content":"龙喵网 - 有态度的网址导航白鹭学园 | ACG 社区 "},{"title":"Xbox​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#xbox","content":"档案XboxFanBest Xbox Series X/S Games of All Time - OpenCriticPlati.Market. Digital goods marketplace. "},{"title":"游戏攻略​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#游戏攻略","content":"游戏时光 - vgtime.com游民星空 - 大型单机游戏媒体 提供特色单机游戏资讯、下载PowerPyx.com - Guides for Trophies, Achievements &amp; CollectiblesTrueAchievements - Xbox Achievement Tracking "},{"title":"梯子​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#梯子","content":"Foo&amp;Friends.freefq/freeBuLink 永久免费网络加速众筹加速器 "},{"title":"技术文档​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#技术文档","content":"网道 - 互联网开发文档正则表达式 30 分钟入门教程正则表达式手册RegExp 对象 - JavaScript 教程 - 网道RegExr: Learn, Build, &amp; Test RegEx "},{"title":"影视​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#影视","content":"豆瓣电影RARBG Torrents , films , download "},{"title":"网站工具​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#网站工具","content":"Favicon Generator for perfect icons on all browsersCloudflare - Web Performance &amp; SecurityUptimeRobot: Free Website Monitoring ServiceWebPageTest - Website Performance and Optimization TestBench.shGravatar - 全球公认的头像PageSpeed InsightsCompare Prices of All Top-Level Domains | TLD ListDomain Availability and Price Comparison – Find cheap domain to buy! "},{"title":"写作​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#写作","content":"ruanyf/document-style-guide: 中文技术文档的写作规范Online LaTeX Equation Editor - create, integrate and download "},{"title":"IP​","type":1,"pageTitle":"实用网站","url":"docs/bookmarks/useful-websites#ip","content":"网易 DNS 检测工具查看我的 IP 地址 | 查询本机 IP 地址及归属地 | Sukka显示查询自己的 IP 地址IP125.com - 查询我的 IP 地址IP 地址检测IP Address Lookup / IPv4 / IPv6 - IP.SBcurl ip.sbIP 地址查询 - 在线工具curl ip.tool.lu "},{"title":"备份工具","type":0,"sectionRef":"#","url":"docs/drafts/backing-up-tools","content":"","keywords":""},{"title":"对比𐄂​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#对比","content":"项目\t编程语言\tDocker\t增量备份\t加密\t多版本\t备份到本地\tS3\tOne Driveduplicati\tC#\t✓\t✓\t✓\t✓\t✓\t✓\t✓ restic\tGo\t✓ ✓\t✓\t✓\t𐄂 autorestic\tGo\t✓ ✓\t✓\t✓ duplicacy\tGo duplicity\tPython backup\tRuby attic\tPython rdiff-backup\tPython borg\tPython kopia\tGo\t✓\t✓\t✓\t✓\t✓\t✓\t𐄂 gobackup\tGo\t✓\t𐄂\t✓\t✓\t✓\t✓\t𐄂 "},{"title":"restic​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#restic","content":"仓库：restic/restic: Fast, secure, efficient backup program文档：restic · Backups done right!工具：cupcakearmy/autorestic: Config driven, easy backup cli for restic. "},{"title":"borg​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#borg","content":"仓库：borgbackup/borg: Deduplicating archiver with compression and authenticated encryption.文档：Borg Documentation — Borg - Deduplicating Archiver 1.1.17 documentation工具：borgmatic-collective/borgmatic: Simple, configuration-driven backup software for servers and workstations "},{"title":"duplicati​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#duplicati","content":"仓库：duplicati/duplicati: Store securely encrypted backups in the cloud!文档：Duplicati 2 User's Manual 好用，但是内存占用高。备份任务基于.json配置文件。备份目的地多样，支持 S3 API，但是在使用阿里云 OOS 时出错；支持腾讯云 COS。 "},{"title":"bup​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#bup","content":"仓库：bup/bup: Very efficient backup system based on the git packfile format, providing fast incremental saves and global deduplication (among and within files, including virtual machine images). Current release is 0.31, and the development branch is master. Please post problems or patches to the mailing list for discussion (see the end of the README below).工具：tobru/bupper: bupper - a bup backup profile manager "},{"title":"backup​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#backup","content":"仓库：backup/backup: Easy full stack backup operations on UNIX-like systems.文档：Overview · Backup Documentation "},{"title":"duplicacy​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#duplicacy","content":"仓库：gilbertchen/duplicacy: A new generation cloud backup toolhttps://github.com/duplicati/duplicati)文档：Home · gilbertchen/duplicacy Wiki "},{"title":"duplicity​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#duplicity","content":"仓库：duplicity / duplicity · GitLab文档：duplicity: Main "},{"title":"kopia​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#kopia","content":"仓库：kopia/kopia: Cross-platform backup tool for Windows, macOS &amp; Linux with fast, incremental backups, client-side end-to-end encryption, compression and data deduplication. CLI and GUI included.文档： "},{"title":"attic​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#attic","content":"仓库：jborg/attic: Deduplicating backup program文档： "},{"title":"rdiff-backup​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#rdiff-backup","content":"仓库：rdiff-backup/rdiff-backup: Reverse differential backup tool, over a network or locally.文档： "},{"title":"gobackup​","type":1,"pageTitle":"备份工具","url":"docs/drafts/backing-up-tools#gobackup","content":"仓库：huacnlee/gobackup: 🗄 Simple tool for backup your databases, files to FTP / SCP / S3 storages.文档： "},{"title":"网站生成器的要求","type":0,"sectionRef":"#","url":"docs/drafts/site-generator-requirements","content":"","keywords":""},{"title":"要求​","type":1,"pageTitle":"网站生成器的要求","url":"docs/drafts/site-generator-requirements#要求","content":"以 Markdown 文档为基础样式简洁，没有花里胡哨的颜色和动画字体美观，可以设置中英文字体移动端适配图片放大代码高亮、代码一键复制支持渲染 MathJax1 或 KaTex2支持渲染 PlantUML3支持渲染 Mermaid4明亮/黑暗主题自动切换搜索自动生成文章内目录 "},{"title":"可选方案​","type":1,"pageTitle":"网站生成器的要求","url":"docs/drafts/site-generator-requirements#可选方案","content":""},{"title":"docsify​","type":1,"pageTitle":"网站生成器的要求","url":"docs/drafts/site-generator-requirements#docsify","content":"docsifyjs/docsify: 🃏 A magical documentation site generator. "},{"title":"docute​","type":1,"pageTitle":"网站生成器的要求","url":"docs/drafts/site-generator-requirements#docute","content":"egoist/docute: 📚 Effortless documentation, done right. "},{"title":"VuePress​","type":1,"pageTitle":"网站生成器的要求","url":"docs/drafts/site-generator-requirements#vuepress","content":"VuePress 遇到的问题： 不支持主题切换 "},{"title":"VuePress V2​","type":1,"pageTitle":"网站生成器的要求","url":"docs/drafts/site-generator-requirements#vuepress-v2","content":"首页 | VuePress 遇到的问题： 明亮主题代码块背景有问题没有代码复制按钮不支持 Mermaid "},{"title":"MkDocs​","type":1,"pageTitle":"网站生成器的要求","url":"docs/drafts/site-generator-requirements#mkdocs","content":"MkDocsMaterial for MkDocs - Material for MkDocs 遇到的问题： Python 语言实现主题的部分功能要高级版才能用 "},{"title":"wiki​","type":1,"pageTitle":"网站生成器的要求","url":"docs/drafts/site-generator-requirements#wiki","content":"Requarks/wiki: Wiki.js | A modern and powerful wiki app built on Node.js 需要服务端图片资源管理有点不太方便 "},{"title":"docusaurus​","type":1,"pageTitle":"网站生成器的要求","url":"docs/drafts/site-generator-requirements#docusaurus","content":"facebook/docusaurus: Easy to maintain open source documentation websites. MathJax | Beautiful math in all browsers.↩KaTeX – The fastest math typesetting library for the web↩开源工具，使用简单的文字描述画 UML 图。↩mermaid - Markdownish syntax for generating flowcharts, sequence diagrams, class diagrams, gantt charts and git graphs.↩ "},{"title":"待办事项","type":0,"sectionRef":"#","url":"docs/drafts/todo","content":"待办事项 sdkman nodebrew oh-my-posh3 oh-my-posh5 nrm nvm rsync cmake zerotier sourcetree","keywords":""},{"title":"Markdown 渲染测试","type":0,"sectionRef":"#","url":"docs/drafts/markdown-render-test","content":"","keywords":""},{"title":"Autolink​","type":1,"pageTitle":"Markdown 渲染测试","url":"docs/drafts/markdown-render-test#autolink","content":"If the autolink extension is enabled the URL https://www.github.com is displayed as a link. "},{"title":"Emoji​","type":1,"pageTitle":"Markdown 渲染测试","url":"docs/drafts/markdown-render-test#emoji","content":"Using the emoji extension you can replace the :smile: with 😄. You can choose to use the standard emoji font or the GitHub images. Multibyte emoji are also supported, so :it: equivalent to the code \\u1f1ee\\u1f1f9 must be rendered as the Italian flag 🇮🇹. "},{"title":"Inline images​","type":1,"pageTitle":"Markdown 渲染测试","url":"docs/drafts/markdown-render-test#inline-images","content":"The inline image extension embed the local image inside the HTML output. Is required for view local images in the Quick Look preview.  "},{"title":"Table​","type":1,"pageTitle":"Markdown 渲染测试","url":"docs/drafts/markdown-render-test#table","content":"Option\tDescriptiondata\tpath to data files to supply the data that will be passed into templates. engine\tengine to be used for processing templates. Handlebars is the default. ext\textension to be used for dest files. "},{"title":"Strikethrough​","type":1,"pageTitle":"Markdown 渲染测试","url":"docs/drafts/markdown-render-test#strikethrough","content":"You can choose to recognize the single tilde ~ on ~test~ or only the double tilde ~~ on another test. "},{"title":"Syntax Highlight​","type":1,"pageTitle":"Markdown 渲染测试","url":"docs/drafts/markdown-render-test#syntax-highlight","content":"This fenced block uses the php syntax highlight: public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) { return new SynchronizedMap&lt;&gt;(m); } Copy "},{"title":"Task list​","type":1,"pageTitle":"Markdown 渲染测试","url":"docs/drafts/markdown-render-test#task-list","content":" step 1 step 2 step 3 "},{"title":"Footnotes​","type":1,"pageTitle":"Markdown 渲染测试","url":"docs/drafts/markdown-render-test#footnotes","content":"The smart quote option format the quote as &quot;curly&quot; 1. "},{"title":"Mermaid​","type":1,"pageTitle":"Markdown 渲染测试","url":"docs/drafts/markdown-render-test#mermaid","content":"sequenceDiagram participant Alice participant Bob Alice-&gt;&gt;John: Hello John, how are you? loop Healthcheck John-&gt;&gt;John: Fight against hypochondria end Note right of John: Rational thoughts &lt;br/&gt;prevail! John--&gt;&gt;Alice: Great! John-&gt;&gt;Bob: How about you? Bob--&gt;&gt;John: Jolly good! Copy "},{"title":"PlantUML​","type":1,"pageTitle":"Markdown 渲染测试","url":"docs/drafts/markdown-render-test#plantuml","content":"@startuml participant participant as Foo actor actor as Foo1 boundary boundary as Foo2 control control as Foo3 entity entity as Foo4 database database as Foo5 collections collections as Foo6 queue queue as Foo7 Foo -&gt; Foo1 : To actor Foo -&gt; Foo2 : To boundary Foo -&gt; Foo3 : To control Foo -&gt; Foo4 : To entity Foo -&gt; Foo5 : To database Foo -&gt; Foo6 : To collections Foo -&gt; Foo7 : To queue @enduml Copy @startuml participant participant as Foo actor actor as Foo1 boundary boundary as Foo2 control control as Foo3 entity entity as Foo4 database database as Foo5 collections collections as Foo6 queue queue as Foo7 Foo -&gt; Foo1 : To actor Foo -&gt; Foo2 : To boundary Foo -&gt; Foo3 : To control Foo -&gt; Foo4 : To entity Foo -&gt; Foo5 : To database Foo -&gt; Foo6 : To collections Foo -&gt; Foo7 : To queue @enduml Copy "},{"title":"Tex​","type":1,"pageTitle":"Markdown 渲染测试","url":"docs/drafts/markdown-render-test#tex","content":"c=a2+bxy2+exc = \\sqrt{a^{2}+b_{xy}^{2}+e^{x}}c=a2+bxy2​+ex​ c=a2+bxy2+exc = \\sqrt{a^{2}+b_{xy}^{2} +e^{x}}c=a2+bxy2​+ex​ If the option footnotes is enabled this text is rendered as a foot note. Footnotes is not recognized in the github pages.↩ "},{"title":"相对路径修复","type":0,"sectionRef":"#","url":"docs/drafts/相对路径修复","content":"相对路径修复 Typora 插入图片时使用的是/xxx.assets/xxx.png格式的路径，但是 Vuepress 需要用./xxx.assets/xxx.png这种格式的路径，不然会被解析到网站的根目录。 使用 VS Code 的正则表达式替换解决。 搜索\\]\\((?!\\.|http)，替换为](./。","keywords":""},{"title":"中英文间插入空格","type":0,"sectionRef":"#","url":"docs/drafts/中英文间插入空格","content":"","keywords":""},{"title":"手动插入空格​","type":1,"pageTitle":"中英文间插入空格","url":"docs/drafts/中英文间插入空格#手动插入空格","content":"如果用 Microsoft Word 的话中英文字符之间会有间距，不需要手动插入，但是 Markdown 文档无法这样做，手动插入空格太麻烦了。 "},{"title":"Vuepress 配合 pangu 插件​","type":1,"pageTitle":"中英文间插入空格","url":"docs/drafts/中英文间插入空格#vuepress-配合-pangu-插件","content":"markdown-it-pangu - npm (npmjs.com) 不管 Markdown 文档如何，在页面渲染的时候插入空格。 缺点就是在源文件中，中英文之间还是没有空格。 "},{"title":"VS Code 中的 Pangu-Markdown 插件​","type":1,"pageTitle":"中英文间插入空格","url":"docs/drafts/中英文间插入空格#vs-code-中的-pangu-markdown-插件","content":"Pangu-Markdown - Visual Studio Marketplace 对md文件进行格式化，不需要在前端渲染的时候再插入空格了，从源头保证了排版美观。 缺点就是每个文件都需要手动格式化。 目前采用此种方式。 "},{"title":"MySQL","type":0,"sectionRef":"#","url":"docs/notes/database/mysql","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#参考资料","content":"【宋红康】MySQL数据库（mysql安装/基础/高级/优化）_哔哩哔哩_bilibili "},{"title":"数据库的作用​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#数据库的作用","content":"实现数据持久化使用完整的管理系统统一管理 "},{"title":"名词解释​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#名词解释","content":"DB（Database），数据库，它保存了一系列有组织的数据DBMS（Database Management System），数据库管理系统，简称数据库软件，可以对数据库进行操作DBA（Database Administrator），数据库管理员SQL（Structure Query Language），结构化查询语言 "},{"title":"命令行​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#命令行","content":"mysql -h localhost -P 3306 -u root -proot Copy -P指定端口-p指定密码，密码可以不写在命令中，只指定参数而不写密码的话会在交互式命令行中输入密码，不会在密码历史或屏幕中暴露密码 "},{"title":"默认数据库​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#默认数据库","content":""},{"title":"SQL​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#sql","content":""},{"title":"SQL 概念​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#sql-概念","content":"结构化查询语言（Structured Query Language），是一种规范，用来操作关系型数据库。但是每种数据库在实现上有略微不同，称为「方言」；不区分大小写，但建议关键字大写；分号作为语句结束；单双引号都可以。 "},{"title":"分类​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#分类","content":"DDL（Data Definition Language）数据定义语言：用于操作数据库对象，如数据库、表、字段等。关键字：create、drop、alter ；DML（Data Manipulation Language）数据操作语言：用于操作数据本身。关键字 insert、delete、update ；DQL（Data Query Language）数据查询语言：用于查询数据。关键字 select；DCL（Data Control Language）数据控制语言：用户操作数据库 的访问权限和安全级别，以及管理用户，关键字 grant、revoke。 "},{"title":"注释​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#注释","content":"-- 单行注释 # 单行注释 /* 多行注释 */ Copy "},{"title":"DDL​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#ddl","content":"SHOW​ 查询所有数据库。 show databases; Copy 查询数据库创建语法，以及数据库字符集。 show create database mysql; Copy 查询所有表。 show tables; show tables from test; Copy 查询当前选择的数据库。 select database(); Copy // TODO 查询变量。 show variables like '%char%'; Copy CREATE​ 创建数据库。 create database db1; Copy 只在不存在的情况下创建。 create database if not exists db2; Copy 指定使用其他字符集。 create database db3 character set gbk; Copy 综合到一起。 create database if not exists db4 character set gbk; Copy 创建表。 create table table_name( id int, name varchar(32) ); Copy 复制表结构。 create table stu like student; Copy "},{"title":"DQL​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#dql","content":"SELECT​ select [distinct | ] 字段列表 from 表名列表 where 条件列表 group by 分组条件 having 分组之后的条件 order by 排序 limit 分页条件 escape '转移字符' Copy 关键词​ 用在字段列表之前： distinct：去除重复 用在字段列表： as：起别名 运算符​ &gt;、&lt;、&gt;=、&lt;=、=、&lt;&gt;&lt;=&gt;，安全等于，可以用来判断nullbetween ... and ...in()like _：单个字符%：多个字符 is nullis not nulland、&amp;&amp;or、||not、! 排序​ 如果不指定排序方式的话，默认是 asc，升序排序。字段名可以是别名。 select * from student order by id desc, name asc; Copy 单行函数​ 字符函数​ length()，字符串长度，中文字符长度和字符集有关concat()，拼接字符串upper()，字符串转大写lower()，字符串转小写substr(str, pos, len)/substring()，编号从1开始instr(str, substr)，搜索字符串第一次出现的位置trim()，去除字符串前后空格trim('a' FROM 'aaaabaaaaa')，去除字符串前后的alpad(str, len, padstr)，左填充字符串，直到达到长度lenrpad()，右填充replace()，替换子串 数学函数​ round()，四舍五入ceil()，数轴向右取整floor()，数轴向左取整truncate(x, n)，保留n位小数，后面的全都舍弃mod()，求余数 日期函数​ now()，日期和时间curdate()，日期curtime()，时间year(now())，获取年的部分month()，数字月monthname()，英语月day()hour()minute()hour()str_to_date()，字符转日期date_format()，日期转字符  其它函数​ version()，查询 MySQL 版本database()，当前选择的数据库user()，当前用户 流程控制函数​ if(exp1, exp2, exp3)，相当于三元运算符CASE  SELECT salary , department_id , CASE department_id when 30 then salary * 1.1 when 40 then salary * 1.2 when 50 then salary * 1.3 else salary end as new_salary from employees Copy 聚合函数​ 将一列数据作为一个整体，进行纵向计算。所有聚合函数都排除了 null 值的计算。 count() count(*) 只要这一行不全为 null，就能算作一行count(1)，统计有多少行 max()min()sum()avg() 可以和distinct搭配使用。 select SUM(DISTINCT salary) from employees; Copy 分组​ 分组之后只能查询分组字段或聚合函数，因为其他独立字段已经没有意义了。 where 在分组之前条件限定，如果不满足结果不会参与分组。 having 可以在分组之后限定条件，不满足条件不参与查询，可以使用聚合函数，可以使用查询字段的别名。 分页​ limit 是 MySQL 的方言。 limit 开始索引，查多少条 Copy 多表查询​ 内连接，左右表不匹配则不显示该行。 -- 隐式内连接 select t1.name, t1.gender, t2.name from emp as t1, dept as t2 where t1. = t2.dep_id; -- 显式内连接，inner 可以省略 select t1.name, t1.gender, t2.name from emp as t1 inner join dept as t2 on t1.dept_id = t2.id Copy 外连接，不匹配的行也会显示。 -- 左外连接，左表会全部显示，右表不匹配的字段会显示 null -- outer 可以省略 left outer join -- 右外连接，右表会全部显示，... right join Copy 子查询，查询中嵌套查询。 where 型子查询：指把内部查询的结果作为外层查询的比较条件；from 型子查询：把内层的查询结果当成临时表，供外层 SQL 再次查询；in 子查询：内层查询语句仅返回一个数据列，这个数据列的值将供外层查询语句进行比较；exists 子查询：内层的返回 true，外层才会执行；any 子查询：只要满足内层子查询中的任意一个比较条件，就返回一个结果作为外层查询条件；all 子查询：内层子查询返回的结果需同时满足所有内层查询条件；比较运算符子查询：子查询中可以使用比较运算符。 -- where 型 select cat_id,good_id,good_name from goods where good_id in(selct max(good_id) from goods group by cat_id); -- from 型 select * from (select cat_id,good_id,good_name from goods order by cat_id asc, good_id desc) as tep group by cat_id; -- all 型 select * from department where did &gt; all(SELECT did from employee); Copy "},{"title":"数据结构​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#数据结构","content":""},{"title":"事务​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#事务","content":""},{"title":"存储引擎​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#存储引擎","content":""},{"title":"Redis","type":0,"sectionRef":"#","url":"docs/notes/database/redis","content":"Redis","keywords":""},{"title":"apache-commons","type":0,"sectionRef":"#","url":"docs/notes/java/apache-commons","content":"apache-commons","keywords":""},{"title":"arthas","type":0,"sectionRef":"#","url":"docs/notes/java/arthas","content":"arthas","keywords":""},{"title":"freemaker","type":0,"sectionRef":"#","url":"docs/notes/java/freemaker","content":"freemaker","keywords":""},{"title":"gson","type":0,"sectionRef":"#","url":"docs/notes/java/gson","content":"gson","keywords":""},{"title":"guava","type":0,"sectionRef":"#","url":"docs/notes/java/guava","content":"guava","keywords":""},{"title":"hutool","type":0,"sectionRef":"#","url":"docs/notes/java/hutool","content":"hutool","keywords":""},{"title":"jackson","type":0,"sectionRef":"#","url":"docs/notes/java/jackson","content":"jackson","keywords":""},{"title":"C 语言","type":0,"sectionRef":"#","url":"docs/notes/c/c","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#参考资料","content":"C 语言教程 | 菜鸟教程C reference - cppreference.com "},{"title":"C 简介​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#c-简介","content":""},{"title":"程序​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#程序","content":"一系列有序指令的集合，目的是执行某些操作或解决某个特定问题。 "},{"title":"C 语言发展历程​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#c-语言发展历程","content":" 需要注意的几个版本： ANSI C（标准 C）C89C99 "},{"title":"C 语言的特点​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#c-语言的特点","content":"代码级别的跨平台允许直接访问物理地址，对硬件进行操作结构化程序设计，具有变量作用域以及递归功能的过程式语言参数可以是指传递，也可以是指针传递没有对象，可以用结构体预编译处理 "},{"title":"程序结构​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#程序结构","content":""},{"title":"基本结构​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#基本结构","content":"C 程序主要包括以下部分： 预处理器指令函数变量语句 &amp; 表达式注释 "},{"title":"程序入口​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#程序入口","content":"程序的入口是main函数。 int main(){ // 方法体 } Copy "},{"title":"开发过程​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#开发过程","content":"编辑（.c/.h）编译（.obj）链接（.exe）运行 "},{"title":"编译&执行命令​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#编译执行命令","content":"gcc test1.c -o main.out ./main.out Copy "},{"title":"基本语法​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#基本语法","content":"C 程序的入口是main函数C 程序源代码文件的扩展名为.c头文件的扩展名为.h语法区分大小写每条执行语句以;结束 "},{"title":"数据类型​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#数据类型","content":"C Tutorials - data types in C Programming Language  每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间。 基本类型，它们是算术类型，包括两种类型：整数类型和浮点类型。枚举类型，它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。void，表明没有可用的值。派生类型，包括指针类型、数组类型、结构类型、共用体类型和函数类型。 "},{"title":"字符类型​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#字符类型","content":"在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义。 \\t，制表位\\n，换行符\\\\，\\\\&quot;，&quot;\\'，'\\r，回车 "},{"title":"整数类型​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#整数类型","content":"前缀： 0x，16 进制0，8 进制无前缀，10 进制 后缀： U，unsigned，无符号整数L，long，长整数 "},{"title":"枚举​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#枚举","content":"enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; Copy 枚举本质上就是整形。默认情况下编号从 0 开始。 "},{"title":"浮点类型​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#浮点类型","content":"float是单精度浮点类型，1 位符号，8 位指数，23 位小数。  double是双精度浮点值。双精度是 1 位符号，11 位指数，52 位小数。  可以使用科学计数法表示，如3.14e-11，表示3.14×(10)−113.14\\times(10)^{-11}3.14×(10)−11。 "},{"title":"void类型​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#void类型","content":""},{"title":"变量​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#变量","content":""},{"title":"初始值​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#初始值","content":"局部变量不会被自动初始化；全局变量会被自动初始化。 数据类型\t初始化默认值int\t0 char\t'\\0' float\t0 double\t0 pointer\tNULL "},{"title":"常量​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#常量","content":""},{"title":"字面量​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#字面量","content":"写出来的数字、字符、字符串都是字面量，是不变的。 "},{"title":"定义常量​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#定义常量","content":"#define​ #define identifier value Copy 这是一个预处理命令，实现原理是在编译时进行字符串替换。注意 value 使用括号包围起来，不然在某些地方会产生意料之外的结果。 const​ const type variable = value; Copy 这是一个关键字，用于把变量所在的内存区域设置为只读。可以用在参数列表中，在该方法中，该参数不能被修改。 "},{"title":"判断​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#判断","content":""},{"title":"switch​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#switch","content":"switch(expression){ case constant-expression : statement(s); break; /* 可选的 */ case constant-expression : statement(s); break; /* 可选的 */ /* 您可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s); } Copy switch 语句中的 expression 是一个常量表达式，必须是一个整型或枚举类型。 "},{"title":"循环​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#循环","content":""},{"title":"goto​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#goto","content":"goto label; // .. // . label: statement; Copy label 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 goto 语句的前面或者后面。 "},{"title":"函数​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#函数","content":"函数的参数传递都是值传递，没有引用传递。即使是指针，传递的也是指针值的复制。所以直接修改局部变量的指针地址是不会影响到外部的变量的。 传递结构体的时候也是传递了一个复制，而不是引用；包括结构体中的指针，也是传递了一个指针的复制。 "},{"title":"数组​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#数组","content":"// 逐个初始化 double balance[5]; balance[4] = 50.0; // 使用初始化语句 double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0}; // 可以省略掉长度 double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0}; Copy 数组名就是一个指针，指向数组的首地址。 "},{"title":"指针​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#指针","content":""},{"title":"操作符​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#操作符","content":"&amp;，取地址操作符*，取实例操作符 "},{"title":"变量指针​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#变量指针","content":"指针变量中保存着一个内存地址。 "},{"title":"指向数组的指针​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#指向数组的指针","content":"数组名就是一个指针，指向数组的首地址。 "},{"title":"多重指针​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#多重指针","content":"指针中的内存地址指向的还是指针。多维数组就是多重指针。 "},{"title":"函数指针​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#函数指针","content":"int max(int a, int b); int (*fun_ptr)(int,int) = max; // 声明一个指向同样参数、返回值的函数指针类型 fun_ptr(1, 2); // 通过 fun_ptr 调用 max 函数 Copy 声明一个函数指针与声明一个变量类似；其中fun_ptr是变量名，前面的int是返回值类型，后面的是参数列表，参数列表可以不用写参数名称，只与参数类型和顺序有关。 通过函数指针可以实现回调函数。即将其声明在函数参数中，在函数内部可以调用传递进来的方法。 #include &lt;stdio.h&gt; int max(int a, int b) { return a &gt; b ? a : b; } void callback(int (*p_max)(int, int)) { printf(&quot;%d\\n&quot;, p_max(1, 2)); } int main() { callback(max); } Copy "},{"title":"指针与算术运算符​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#指针与算术运算符","content":"可以对指针使用算数运算，如+、-、*、/；单位偏移量和指针类型有关，如int指针的单位偏移量为 4。可以使用这个特性来计算出每个数组元素的地址，可以通过指针访问该地址。 指针也可以用比较运算符进行比较。 "},{"title":"字符串​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#字符串","content":"字符串实际上是字符数组，字符串以'\\0'结尾，无论该元素后是否还有字符。  在使用字符串常量时不需要手动在末尾放一个'\\0'，编译器会自动给你加。 "},{"title":"struct结构体​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#struct结构体","content":"把多种类型的数据声明在一起，结构体所占内存长度是其中最大字段大小的整数倍。 使用.来访问结构体成员；在通过结构体指针访问结构体成员时可以使用-&gt;。不用通过*符号取到结构体实力再操作成员，是一种简便写法。 struct Books book1; struct Books *struct_pointer; struct_pointer = &amp;book1; // -&gt; struct_pointer-&gt;title; // . (*struct_pointer).title; Copy "},{"title":"union共用体​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#union共用体","content":"共用体的声明和使用与结构体类似。区别是共用体的长度是其内最大成员的长度；其内所有成员共用同一个内存区域来存储数据，修改一个成员的内容可能会对其它数据造成影响；在读取成员值的时候会按照该成员类型的长度来读取对应长度的内存值来解析为对应类型。 "},{"title":"typedef​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#typedef","content":"给类型取新名字。 "},{"title":"I/O​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#io","content":"在&lt;stdio.h&gt;中声明有三个FILE *，把输入/输出当作文件处理。 stdin，标准输入stdout，标准输出stderr，错误输出 "},{"title":"预处理命令​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#预处理命令","content":"C 预处理器 | 菜鸟教程 "},{"title":"include​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#include","content":"#include &lt; &gt;引用的是编译器的类库路径里面的头文件；#include &quot; &quot;引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件。 "},{"title":"错误处理​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#错误处理","content":"int atexit(void (*func)(void))，&lt;stdlib.h&gt;，注册程序退出时的回调函数extern int errno，&lt;errno.h&gt;，存储最后一个错误号char *strerror(int errnum)，&lt;string.h&gt;，把错误号转为字符串 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; void ae() { if (errno) { fprintf(stderr, &quot;%s\\n&quot;, strerror(errno)); } } int main() { atexit(ae); // ... } Copy "},{"title":"可变参数​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#可变参数","content":"在&lt;stdarg.h&gt;中。 "},{"title":"内存管理​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#内存管理","content":"这些函数在&lt;stdlib.h&gt;中。 void *malloc(int num);void *calloc(int num, int size);void free(void *address); "},{"title":"标准库​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#标准库","content":""},{"title":"stdio.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#stdioh","content":"结构​ FILE 成员​ 声明有三个FILE *，把输入/输出当作文件处理。 stdin，标准输入stdout，标准输出stderr，错误输出 函数​ int printf(const char *format, ...);，格式化字符串并向stdout输出int fprintf(FILE *stream, const char *format, ...);格式化字符串，可以向指定的流输出int sprintf(char *buffer, const char *format, ...);，格式化字符串，写入另一个字符串int scanf( const char *format, ... );int fscanf( FILE *stream, const char *format, ... );int sscanf( const char *buffer, const char *format, ... ); 格式化参数\t备注\tPrecision%\t%本身 %c\tchar %s\t字符串\t指定最大输出长度 %d/%i\tint %u\tunsigned int\t指定小数位数，默认是 6 %f/%F\tfloat %e/%E\t十进制科学计数法 %x/%X\t十六进制 %p\t输出指针内的内存地址\t int getchar(void);，从标准输入读一个字符int getc( FILE *stream );，从指定流读一个字符int putchar(int ch);，写出一个字符到标准输出int putc( int ch, FILE *stream );，写出一个字符到指定流char *gets( char *str );，字符串char *fgets( char *str, int count, FILE *stream );int puts( const char *str );int fputs( const char *str, FILE *stream ); 文件读写： FILE *fopen( const char *filename, const char *mode );int fclose( FILE *stream );size_t fread( void *buffer, size_t size, size_t count, FILE *stream );，二进制读size_t fwrite( const void *restrict buffer, size_t size, size_t count, FILE *restrict stream );，二进制写int fseek( FILE *stream, long offset, int origin );，移动文件指针 fopen访问模式mode的值可以是下列值中的一个。 文本模式\t二进制模式\t备注r\trb\t打开已有文件，只读 w\twb\t读写，如果文件存在则清空文件覆盖写入 a\tab\t读写，追加写入 r+\tr+b/rb+\t读写 w+\tw+b/wb+\t读写，存在则清空，不存在则创建 a+\ta+b/ab+\t读写，从头读，追加写 fseek中origin有以下 3 个可选值。 SEEK_SET，以文件开头为基准SEEK_CUR，以当前指针位置为基准SEEK_END，以文件结束为基准 "},{"title":"stdlib.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#stdlibh","content":"系统： int system( const char *command );，执行系统命令void exit( int exit_code ); 随机数： void srand( unsigned seed );，重置随机数种子int rand();，生成0到`RAND_MAX 的一个随机数 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main(void) { srand(time(NULL)); // use current time as seed for random generator int random_variable = rand(); printf(&quot;Random value on [0,%d]: %d\\n&quot;, RAND_MAX, random_variable); // roll a 6-sided die 20 times for (int n=0; n != 20; ++n) { int x = 7; while(x &gt; 6) x = 1 + rand()/((RAND_MAX + 1u)/6); // Note: 1+rand()%6 is biased printf(&quot;%d &quot;, x); } } Copy // Possible output Random value on [0,2147483647]: 448749574 3 1 3 1 4 2 2 1 3 6 4 4 3 1 6 2 3 2 6 1 Copy "},{"title":"stdbool.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#stdboolh","content":"定义了bool类型和true/false。 true=1false=0 "},{"title":"string.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#stringh","content":"类型转换函数： int atoi( const char *str );，字符串转intlong atol( const char *str );long long atoll( const char *str );double atof( const char* str ); 字符串操作： void *memchr(const void *str, int c, size_t n)，字符串中搜索某个字符char *strchr(const char *str, int c)int memcmp(const void *str1, const void *str2, size_t n)，字符串比较int strcmp(const char *str1, const char *str2)void *memcpy(void *str1, const void *str2, size_t n)，复制字符串char *strcpy(char *dest, const char *src)void *memmove(void *str1, const void *str2, size_t n)，移动字符串char *strcat(char *dest, const char *src)，连接两个字符串char *strerror(int errnum)，把错误号转为对应的错误消息size_t strlen(const char *str)，字符串长度，以\\0为字符串结束char *strtok(char *str, const char *delim)，分隔字符串char *strstr(const char *haystack, const char *needle)，字符串中查找子串 "},{"title":"time.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#timeh","content":"结构​ struct tm { int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月，范围从 0 到 11 */ int tm_year; /* 自 1900 年起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ }; Copy 成员​ CLOCKS_PER_SEC，表示每秒的处理器时钟个数 函数​ clock_t clock(void)，返回自从程序启动起，所经过的处理器时钟char *asctime(const struct tm *timeptr)，将tm结构解析为字符串char *ctime(const time_t *timer)，把时间戳转换为字符串double difftime(time_t time1, time_t time2)，计算两个时间戳之间的差值struct tm *gmtime(const time_t *timer)，时间戳转tm结构，用 UTC 时间，时区为+0struct tm *localtime(const time_t *timer)，时间戳转tm，用本地时区time_t mktime(struct tm *timeptr)，tm转时间戳，用本地时区time_t time(time_t *seconds)，得到当前时间戳size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)，tm转时间戳，可以自定义格式 "},{"title":"ctype.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#ctypeh","content":"类型判断函数。 "},{"title":"math.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/c#mathh","content":"double modf(double x, double *integer)，分解整数和小数部分double fabs(double x)，求绝对值double fmod(double x, double y)，求余数double sqrt(double x)，求平方根，x\\sqrt{x}x​double pow(double x, double y)，幂运算，x12=xx^{\\frac{1}{2}}=\\sqrt{x}x21​=x​double floor(double x)，返回数轴上在x左边的最近一个整数值，包括xdouble ceil(double x) "},{"title":"java-web","type":0,"sectionRef":"#","url":"docs/notes/java/java-web","content":"java-web","keywords":""},{"title":"jdbc","type":0,"sectionRef":"#","url":"docs/notes/java/jdbc","content":"jdbc","keywords":""},{"title":"junit","type":0,"sectionRef":"#","url":"docs/notes/java/junit","content":"junit","keywords":""},{"title":"jvm","type":0,"sectionRef":"#","url":"docs/notes/java/jvm","content":"jvm","keywords":""},{"title":"logback","type":0,"sectionRef":"#","url":"docs/notes/java/logback","content":"logback","keywords":""},{"title":"lombok","type":0,"sectionRef":"#","url":"docs/notes/java/lombok","content":"lombok","keywords":""},{"title":"maven","type":0,"sectionRef":"#","url":"docs/notes/java/maven","content":"maven","keywords":""},{"title":"mybatis","type":0,"sectionRef":"#","url":"docs/notes/java/mybatis","content":"mybatis","keywords":""},{"title":"mybatis-plus","type":0,"sectionRef":"#","url":"docs/notes/java/mybatis-plus","content":"mybatis-plus","keywords":""},{"title":"netty","type":0,"sectionRef":"#","url":"docs/notes/java/netty","content":"netty","keywords":""},{"title":"okhttp","type":0,"sectionRef":"#","url":"docs/notes/java/okhttp","content":"okhttp","keywords":""},{"title":"retrofit","type":0,"sectionRef":"#","url":"docs/notes/java/retrofit","content":"retrofit","keywords":""},{"title":"spring","type":0,"sectionRef":"#","url":"docs/notes/java/spring","content":"spring","keywords":""},{"title":"spring-boot","type":0,"sectionRef":"#","url":"docs/notes/java/spring-boot","content":"spring-boot","keywords":""},{"title":"spring-cloud","type":0,"sectionRef":"#","url":"docs/notes/java/spring-cloud","content":"spring-cloud","keywords":""},{"title":"spring-cloud-alibaba","type":0,"sectionRef":"#","url":"docs/notes/java/spring-cloud-alibaba","content":"spring-cloud-alibaba","keywords":""},{"title":"spring-mvc","type":0,"sectionRef":"#","url":"docs/notes/java/spring-mvc","content":"spring-mvc","keywords":""},{"title":"spring-security","type":0,"sectionRef":"#","url":"docs/notes/java/spring-security","content":"spring-security","keywords":""},{"title":"thymeleaf","type":0,"sectionRef":"#","url":"docs/notes/java/thymeleaf","content":"thymeleaf","keywords":""},{"title":"TypeScript","type":0,"sectionRef":"#","url":"docs/notes/javascript/typescript","content":"","keywords":""},{"title":"基本类型​","type":1,"pageTitle":"TypeScript","url":"docs/notes/javascript/typescript#基本类型","content":"在声明变量时指定类型。如果在声明时直接赋值则 TS 会自动推断类型。 let a: number; let b = true; Copy 类型\t例子\t描述number 数字 string 字符串 boolean 布尔值 字面量 限制类型和值就只能是当前字面量本身 any 任意类型 unknown 类型安全的 any void 没有值或 undefined never 没有值，不能是任何值 object 任意 JavaScript 对象 array 数组 tuple 固定长度数组 enum 枚举 可以使用|来连接多个类型。 let a: &quot;male&quot; | &quot;female&quot; let b: number | boolean Copy "},{"title":"Vue.js","type":0,"sectionRef":"#","url":"docs/notes/javascript/vue.js","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#参考资料","content":"Vue.js【尚硅谷】Web 前端迅速上手 Vue 教程丨 vue3.0 入门到精通_哔哩哔哩_bilibili "},{"title":"Vue 简介​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#vue-简介","content":"Vue.js 是一套构建用户界面的渐进式 JavaScript 框架。 构建用户界面：将数据渲染在页面上；渐进式：Vue 可以自底向上逐层应用。如果是简单应用只需要引入核心库；如果是复杂应用，可以引入各种各样的 Vue 插件。 "},{"title":"MVVM​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#mvvm","content":""},{"title":"模板语法​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#模板语法","content":""},{"title":"插值​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#插值","content":"将表达式写入{{ }}中， "},{"title":"指令​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#指令","content":""},{"title":"微信小程序","type":0,"sectionRef":"#","url":"docs/notes/javascript/weapp","content":"","keywords":""},{"title":"组件库​","type":1,"pageTitle":"微信小程序","url":"docs/notes/javascript/weapp#组件库","content":"wechat-miniprogram/weui-miniprogram: 小程序 WeUI 组件库youzan/vant-weapp: 轻量、可靠的小程序 UI 组件库 "},{"title":"功能库​","type":1,"pageTitle":"微信小程序","url":"docs/notes/javascript/weapp#功能库","content":"jin-yufeng/mp-html: 小程序富文本组件，支持渲染和编辑 html，支持在微信、QQ、百度、支付宝、头条和 uni-app 平台使用NewFuture/miniprogram-network: Redefine the Network API of MiniProgram（小程序网络库）zfxmnb/wxStore: 小程序状态管理tailwind-one: 使用 tailwind 运行在 小程序（微信小程序 头条小程序 阿里小程序 taro remax uniapp 等等） web 端 h5 端 native 端！ "},{"title":"RocketMQ","type":0,"sectionRef":"#","url":"docs/notes/message-queuing/rocketmq","content":"","keywords":""},{"title":"MQ​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#mq","content":"MQ（Message Queue，消息队列），是一种 FIFO 的队列。 它的作用有： 异步解耦削峰 "},{"title":"RocketMQ 介绍​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#rocketmq-介绍","content":"RcoketMQ 是一款低延迟、高可靠、可伸缩、易于使用的消息中间件。 "},{"title":"NameServer​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#nameserver","content":"注册中心，可以集群。 "},{"title":"Broker​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#broker","content":"真正负责消息收发和存储的实体，可以主从。 "},{"title":"单机部署​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#单机部署","content":"可以使用 Docker Compose 来快速部署 RocketMQ。 RockerMQ 分为 NameServer1 和 Broker2，前者类似于注册中心，后者才是进行存储消息的服务。还有一个第三方服务rocket-mq-console-ng34，是 RocketMQ 的网页控制台。 RocketMQ 的 NameServer 和 Broker 是同一套代码，只是启动的时候参数不一样。apacherocketmq/rocketmq-nameserver和 apacherocketmq/rocketmq-broker在启动参数上有不同。 RocketMQ 的数据存储在user.home目录下，你可以设置user.home环境变量来自定义存储路径。在这两个 Docker 镜像中，该环境变量的值为/opt。 version: &quot;3&quot; services: nameserver: image: apacherocketmq/rocketmq-nameserver:4.5.0-alpine volumes: - nameserver_logs:/root/logs ports: - 9876:9876 environment: JAVA_OPT_EXT: &quot; -Xms128m -Xmx128m -Xmn128m&quot; command: sh mqnamesrv broker: image: apacherocketmq/rocketmq-broker:4.5.0-alpine depends_on: - nameserver volumes: - broker_data:/root/store - broker_logs:/root/logs - /root/docker-compose/rocketmq/broker.conf:/home/rocketmq/broker.conf ports: - 10909:10909 - 10911:10911 - 10912:10912 environment: JAVA_OPT_EXT: &quot; -Xms128m -Xmx128m -Xmn128m&quot; command: sh mqbroker -c /home/rocketmq/broker.conf console: image: apacherocketmq/rocketmq-console:2.0.0 depends_on: - nameserver - broker ports: - 8088:8080 environment: LOGGIN_LEVEL_ROOT: info ROCKETMQ_CONFIG_NAMESRVADDR: nameserver:9876 JAVA_OPTS: &quot; -Xms128m -Xmx128m -Xmn128m&quot; volumes: nameserver_logs: broker_data: broker_logs: Copy 根据上面的文件中的配置内容，你还需要为 Broker 提供配置文件，位于/root/docker-compose/rocketmq/broker.conf。 需要配置 Broker 的外部 IP，不然客户端连接不上。 brokerClusterName = DefaultCluster brokerName = broker-a brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH namesrvAddr=nameserver:9876 brokerIP1=192.168.229.129 defaultTopicQueueNums=4 autoCreateTopicEnable=true autoCreateSubscriptionGroup=true Copy 接着使用docker compose up -d就可以启动容器了，容器名字都会加上当前文件夹名作为前缀。 可以使用docker compose ps查看容器的运行状态。 "},{"title":"集群部署​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#集群部署","content":"// TODO 还没学，学了再写 "},{"title":"开发​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#开发","content":"首先为了使用方便，定义了一些常量。 public class MQConstant { public static final String NAMESERVER_ADDR = &quot;192.168.229.129:9876&quot;; } Copy "},{"title":"原生 API​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#原生-api","content":"消费者（推送）​ package example.sync; @Slf4j public class Consumer { public static final String CONSUMER_GROUP = &quot;sync_message_consumer&quot;; public static void main(String[] args) throws Exception { DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP); consumer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET); consumer.subscribe(MQTopicConstant.PRACTISE, MQTagConstant.PRACTISE); consumer.registerMessageListener((MessageListenerOrderly) (msgs, context) -&gt; { msgs.forEach(messageExt -&gt; { log.info(&quot;收到消息：{}&quot;, messageExt); log.info(&quot;消息体：{}&quot;, new String(messageExt.getBody())); }); return ConsumeOrderlyStatus.SUCCESS; }); consumer.start(); log.info(&quot;Consumer 已启动&quot;); Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; { log.info(&quot;程序正在退出&quot;); consumer.shutdown(); })); } } Copy 生产者（同步发送）​ package example.sync; @Slf4j public class Producer { public static final String PRODUCER_GROUP = &quot;sync_message_producer&quot;; public static void main(String[] args) throws Exception { DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP); producer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); producer.start(); Stream.generate(RandomUtil::randomInt) .limit(10) .map(i -&gt; new Message(MQTopicConstant.PRACTISE, MQTagConstant.PRACTISE, StrUtil.format(&quot;Hello RocketMQ: {}&quot;, i).getBytes(StandardCharsets.UTF_8))) .forEach(message -&gt; { try { SendResult result = producer.send(message, 10000); log.info(&quot;消息已发送：{}&quot;, result); } catch (Exception e) { log.error(&quot;消息发送失败&quot;, e); } }); producer.shutdown(); } } Copy 生产者（异步发送）​ package example.producer; @Slf4j public class AsyncMessageProducer { public static final String PRODUCER_GROUP = &quot;async_message_producer&quot;; public static void main(String[] args) throws Exception { final int count = 10; DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP); producer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); producer.start(); CountDownLatch countDownLatch = new CountDownLatch(count); Stream.generate(RandomUtil::randomInt) .limit(count) .map(i -&gt; new Message(MQTopicConstant.PRACTISE, MQTagConstant.PRACTISE, StrUtil.format(&quot;Hello RocketMQ: {}&quot;, i).getBytes(StandardCharsets.UTF_8))) .forEach(message -&gt; { try { producer.send(message, new SendCallback() { @Override public void onSuccess(SendResult sendResult) { log.info(&quot;消息发送成功：{}&quot;, sendResult); countDownLatch.countDown(); } @Override public void onException(Throwable e) { log.error(&quot;消息发送失败&quot;, e); countDownLatch.countDown(); } }); log.info(&quot;消息已发送：{}&quot;, message); } catch (Exception e) { log.error(&quot;消息发送失败&quot;, e); } }); countDownLatch.await(); producer.shutdown(); } } Copy 生产者（单向发送）​ // org.apache.rocketmq.client.producer.DefaultMQProducer#sendOneway public void sendOneway(Message msg) Copy 消费者（拉取）​ 主动拉取可以更灵活地消费消息。 // TODO 还需要明白主动拉取后的消费确认机制 package example.consumer; @Slf4j public class PullConsumer { public static final String CONSUMER_GROUP = &quot;pull_message_consumer&quot;; public static void main(String[] args) throws Exception { DefaultLitePullConsumer consumer = new DefaultLitePullConsumer(CONSUMER_GROUP); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET); consumer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); consumer.subscribe(MQTopicConstant.PRACTISE, MQTagConstant.ALL); consumer.start(); while (true) { List&lt;MessageExt&gt; messages = consumer.poll(); if (CollUtil.isEmpty(messages)) { break; } messages.forEach(messageExt -&gt; log.info(&quot;收到消息：{}&quot;, messageExt)); } Runtime.getRuntime().addShutdownHook(new Thread(consumer::shutdown)); } } Copy 顺序消费​ 顺序消费要做到需要顺序消费的一组消息都发送到同一个队列上。消费者在消费的时候使用串行消费而不是并发消费。 // org.apache.rocketmq.client.producer.DefaultMQProducer#send public SendResult send(Message msg, MessageQueueSelector selector, Object arg) Copy MessageQueueSelector可以选择发送消息到哪个队列上。 在实际使用中，可以动态地选择队列来实现负载均衡，只要保证需要顺序消费的同一组消息发送到同一个队列上即可。 SendResult sendResult = producer.send(message, (mqs, msg, arg) -&gt; { int i = (Integer) arg % mqs.size(); return mqs.get(i); }, pair.getKey()); Copy 广播消息​ 默认情况下，同一个消费者组在消费消息时有竞争关系。在消费消息的时候设置消费者为广播模式就可以让消费者去掉竞争属性。 // org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#setMessageModel public void setMessageModel(MessageModel messageModel) Copy MessageModel默认为CLUSTERING，需要设置为BROADCASTING。 consumer.setMessageModel(MessageModel.BROADCASTING); Copy 延迟消息​ // org.apache.rocketmq.common.message.Message#setDelayTimeLevel public void setDelayTimeLevel(int level) Copy 可以给Message设置delayLevel，延迟级别分别为1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h，从 1 开始数。 批量消息​ // org.apache.rocketmq.client.producer.DefaultMQProducer#send public SendResult send(Collection&lt;Message&gt; msgs) Copy 可以简单地把消息封装为Collection&lt;Message&gt;，一起发出去。 过滤消息​ 大多数情况下，可以通过 Topic 和 Tag 来过滤消息。 Tag 可以用表达式写。 consumer.subscribe(MQTopicConstant.PRACTISE, MessageSelector.byTag(&quot;TAG&quot;)); Copy 在复杂情况下，还可以通过 SQL 语句来过滤消息。  其中变量a可以在发送消息的时候通过putUserProperty()放入。 // org.apache.rocketmq.common.message.Message#putUserProperty public void putUserProperty(final String name, final String value) Copy 只有推送模式的 Consumer 可以使用消息过滤。 事务消息​  事务消息的机制是在发送消息时会发送一个办消息，这个消息存放在系统创建的 Topic 中，对消费者是不可见的。在生产者对消息进行提交之后才会把消息转移到目标 Topic。如果生产者没有对消息进行提交，RocketMQ 会每隔一段时间进行回查，确认本地事务是否已提交成功，如果是则把消息转移到目标 Topic，否则若超过最大回查尝试次数则丢弃消息，默认最大重试次数为 15。 "},{"title":"Spring Boot​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#spring-boot","content":"配置​ 配置解耦，写在配置文件中。 rocketmq.name-server=192.168.229.129:9876 rocketmq.producer.group=spring-boot-producer-group Copy 生产者（同步发送）​ 核心是RocketMQTemplate，消息的发送都依赖它完成。RocketMQTemplate已经在 Spring 容器中，可以自动注入拿到。其中destination的格式为${topic}:${tag}。 // org.springframework.messaging.core.AbstractMessageSendingTemplate#send public void send(D destination, Message&lt;?&gt; message) Copy 发送消息用send()，参数中的Message实际上是org.springframework.messaging.Message，而不是org.apache.rocketmq.common.message.Message。 Message可以用MessageBuilder构建。 MessageBuilder.withPayload(payload).build(); Copy 生产者（异步发送）​ // org.apache.rocketmq.spring.core.RocketMQTemplate#asyncSend public void asyncSend(String destination, Message&lt;?&gt; message, SendCallback sendCallback) Copy 生产者（单向发送）​ // org.apache.rocketmq.spring.core.RocketMQTemplate#sendOneWay public void sendOneWay(String destination, Message&lt;?&gt; message) Copy 消费者（推送）​ 消息的消费有了新的抽象。只需实现RocketMQListener接口就可以快速完成消息消费。设计原则是一个接口消费一种消息，如果需要消费其他消息则需要多个接口。 package com.example.rocketmqinspringboot.listener; @Slf4j @Service @RocketMQMessageListener(consumerGroup = MQConstant.CONSUMER_GROUP, topic = MQTopicConstant.PRACTISE, selectorExpression = MQTagConstant.PRACTISE) public class Consumer implements RocketMQListener&lt;String&gt; { @Override public void onMessage(String message) { log.info(&quot;收到消息：{}&quot;, message); } } Copy 上面的例子会直接拿到消息中的 Payload 并且将之转为泛型对应类型的对象。如果你需要拿到消息的头部信息，把泛型设置为MessageExt，其中可以拿到头部信息 5。 顺序消费​ // org.apache.rocketmq.spring.core.RocketMQTemplate#sendAndReceive public &lt;T&gt; T sendAndReceive(String destination, Message&lt;?&gt; message, Type type, String hashKey) Copy 生产者同一组消息指定相同的hashKey，则该组消息会被发送到同一个消息队列上。 // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#consumeMode ConsumeMode consumeMode() default ConsumeMode.CONCURRENTLY; Copy 消费者把consumeMode设置为ORDERLY。 广播消息​ // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#messageModel MessageModel messageModel() default MessageModel.CLUSTERING; Copy 过滤消息​ // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#selectorType SelectorType selectorType() default SelectorType.TAG; // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#selectorExpression String selectorExpression() default &quot;*&quot;; Copy 事务消息​ // org.apache.rocketmq.spring.core.RocketMQTemplate#sendMessageInTransaction public TransactionSendResult sendMessageInTransaction(final String destination, final Message&lt;?&gt; message, final Object arg) Copy 发送事务消息依赖sendMessageInTransaction完成。arg作为自定义参数会被传递到RocketMQLocalTransactionListener#executeLocalTransaction中，本地事务逻辑会在该方法中完成。 package com.example.rocketmqinspringboot.controller; @Operation(summary = &quot;发事务消息&quot;) @PostMapping(&quot;/transaction&quot;) public void sendTransactionMessage(@RequestBody String message) { TransactionSendResult transactionSendResult = rocketMQTemplate.sendMessageInTransaction(getDestination(), getMessage(message), message); log.info(&quot;transactionSendResult: {}&quot;, transactionSendResult); } Copy package com.example.rocketmqinspringboot.listener; @Slf4j @RocketMQTransactionListener public class TransactionListener implements RocketMQLocalTransactionListener { @Override public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) { String orderNumber = new String((byte[]) msg.getPayload()); log.info(&quot;执行事务，{}&quot;, orderNumber); return RocketMQLocalTransactionState.UNKNOWN; } @Override public RocketMQLocalTransactionState checkLocalTransaction(Message msg) { String orderNumber = new String((byte[]) msg.getPayload()); log.info(&quot;回查，{}&quot;, orderNumber); return RocketMQLocalTransactionState.COMMIT; } } Copy 发送事务消息时，一个RocketMQTemplate对应一个RocketMQLocalTransactionListener，该RocketMQTemplate所发出的事务消息都会在对应的RocketMQLocalTransactionListener中执行。 如果需要定义多个事务消息监听器，就需要多个RocketMQListener，对应多个RocketMQLocalTransactionListener。 package com.example.rocketmqinspringboot.config; @ExtRocketMQTemplateConfiguration public class ExtRocketMQTemplate extends RocketMQTemplate { } Copy package com.example.rocketmqinspringboot.listener; @RocketMQTransactionListener(rocketMQTemplateBeanName = &quot;extRocketMQTemplate&quot;) public class ExtTransactionListener implements RocketMQLocalTransactionListener { @Override public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) { return RocketMQLocalTransactionState.UNKNOWN; } @Override public RocketMQLocalTransactionState checkLocalTransaction(Message msg) { return RocketMQLocalTransactionState.COMMIT; } } Copy "},{"title":"Spring Cloud Stream​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#spring-cloud-stream","content":"Spring Cloud Stream 是 Spring 官方提供的一个针对所有开源的消息系统进行统一封装。 配置​ package com.example.rocketmqspringcloudstream; @EnableBinding({Source.class, Sink.class}) @SpringBootApplication public class RocketmqSpringCloudStreamApplication { public static void main(String[] args) { SpringApplication.run(RocketmqSpringCloudStreamApplication.class, args); } } Copy Source和Sink是 Spring Cloud Stream 提供的简单的消息输入和输出通道。 spring.cloud.stream.bindings.input.destination=STREAM_TOPIC spring.cloud.stream.bindings.input.group=STREAM_GROUP spring.cloud.stream.bindings.output.destination=STREAM_TOPIC spring.cloud.stream.rocketmq.binder.name-server=192.168.229.129:9876 Copy Spring Cloud Stream 关于消息生产和消费的配置都放在配置文件中。 spring.cloud.stream.bindings是一个Map，可以配置多个通道，input就是Sink的通道名，output就是Source的通道名。 如果需要定义其他通道就新增配置文件，然后新增类似于Sink和Sourec的接口。 生产者​ package com.example.rocketmqspringcloudstream.controller; @Tag(name = &quot;消息&quot;) @Slf4j @RestController @RequestMapping(&quot;/messages&quot;) public class MessageController { @Autowired private Source source; @Operation(summary = &quot;发同步消息&quot;) @PostMapping(&quot;/sync&quot;) public void sendSync(@RequestBody String message) { Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;(); headers.put(MessageConst.PROPERTY_TAGS, MQTagConstant.PRACTISE); Message&lt;String&gt; msg = MessageBuilder.createMessage(message, new MessageHeaders(headers)); boolean success = source.output().send(msg); log.info(&quot;success: {}&quot;, success); } } Copy 消费者​ package com.example.rocketmqspringcloudstream.consumer; @Slf4j @Service public class Consumer { @StreamListener(Sink.INPUT) public void consume(String message) { log.info(&quot;收到消息：{}&quot;, message); } } Copy "},{"title":"参考资料​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#参考资料","content":"2021 年 B 站讲的最牛掰的 RocketMQ 分布式消息中间件：核心原理与最佳实践_哔哩哔哩_bilibiliApache RocketMQrocketmq/docs/cn at master · apache/rocketmqrocketmq-externals/rocketmq-console at master · apache/rocketmq-externals基于 Docker 安装 RocketMQ - 简书rocketmq-docker/docker-compose.yml at master · apache/rocketmq-docker用户手册 · apache/rocketmq-spring Wiki apacherocketmq/rocketmq-nameserver - Docker Image | Docker Hub↩apacherocketmq/rocketmq-broker - Docker Image | Docker Hub↩apacherocketmq/rocketmq-console - Docker Image | Docker Hub↩rocketmq-externals/rocketmq-console at master · apache/rocketmq-externals↩常见问题 · apache/rocketmq-spring Wiki↩ "},{"title":"Java","type":0,"sectionRef":"#","url":"docs/notes/java/java","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#参考资料","content":"2021 年度全网最全 Java 学习路线 - 哔哩哔哩尚硅谷 Java 零基础入门教程（含百道 Java 真题，2 万多行 Java 代码实战）_哔哩哔哩_bilibili30 天搞定 Java 核心技术-程序员标配，人手一套尚硅谷教程30 天搞定 Java 核心技术（上） - 谷粒学苑 - Java 培训|大数据培训|前端培训|HTML5 培训|Linux 运维培训_程序员一站式 IT 在线学习平台 - Powered By EduSoho "},{"title":"Java 语言概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#java-语言概述","content":""},{"title":"软件开发介绍​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#软件开发介绍","content":"人机交互方式​ 图形化界面（Graphical User Interface, GUI）命令行方式（Command Line Interface, CLI） 常用的 DOS 命令​ dir列出目录下的文件以及文件夹md创建目录rd删除目录cd进入指定目录cd..进入上级目录cd\\进入根目录del删除文件exit退出 DOS 命令行echo回显；可以用输出重定向输出内容到文件，如echo javase &gt; 1.txtTAB代码提示←→移动光标↑↓调整历史命令DeleteBackspace删除字符 "},{"title":"计算机编程语言介绍​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#计算机编程语言介绍","content":"第一代语言：机器语言，指令以二进制代码形式存在；第二代语言：汇编语言，使用助剂符表示一条机器指令；第三代语言：高级语言。 "},{"title":"Java 语言概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#java-语言概述-1","content":"Java 语言是 SUN（Stanford University Network）1995 年推出的一门高级编程语言。 编程语言排行榜：index | TIOBE - The Software Quality Company。 Java 简史​ 1991 年 Green 项目，开发语言最初命名为 Oak （橡树）1996 年，发布 JDK 1.01999 年，Java 分成 J2SE、J2EE 和 J2ME，JSP/Servlet 技术诞生2004 年，发布里程碑式版本 JDK 1.5，为突出此版本的重要性，更名为 JDK 5.02005 年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME2009 年，Oracle 公司收购 SUN，交易价格 74 亿美元2014 年，发布 JDK 8.0，是继 JDK 5.0 以来变化最大的版本2018 年 3 月，发布 JDK 10.0，版本号也称为 18.32018 年 9 月，发布 JDK 11.0，版本号也称为 18.9 Java 技术体系平台​ Java SE（Java Standard Edition）标准版，面向桌面级应用开发；Java EE（Java Enterprise Edition）企业版，是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如 Servlet 、JSP 等，主要针对于 Web 应用程序开发；ava ME（Java Micro Edition）小型版，支持 Java 程序运行在移动终端上的平台；Java Card，支持一些 Java 小程序（Applets）运行在小内存设备（如智能卡）上的平台。 "},{"title":"Java 语言的环境搭建​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#java-语言的环境搭建","content":"JRE（Java Runtime Environment，Java 运行环境）JDK（Java Development Kit，Java 开发工具包）   "},{"title":"开发体验——Hello World​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#开发体验hello-world","content":"编写 文件以.java为后缀以类为基本单位一个文件中只能由一个public类如果存在public类，则源代码文件名需要与类名相同程序的入口为固定写法，public static void main(String[] args) { /* ... */ }语句之间用分号分隔 编译，javac A.java运行，java 类名  "},{"title":"注释​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#注释","content":"单行注释，// 注释多行注释，/* 注释 */文档注释，/** @author Roddy */，可以用javadoc工具解析，生成代码文档 "},{"title":"Java API 文档​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#java-api-文档","content":"Java 8 中文版 - 在线 API 中文手册 - 码工具Overview (Java Platform SE 8 ) "},{"title":"Java 基本语法​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#java-基本语法","content":""},{"title":"关键字与保留字​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#关键字与保留字","content":"Java Language Keywords (The Java™ Tutorials &gt; Learning the Java Language &gt; Language Basics) 关键字（keyword）：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词）。关键字中所有字母都为小写。 保留字（reserverd word）：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。有两个goto、const。  "},{"title":"标识符​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#标识符","content":"命名规则​ Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符。 由 26 个英文字母大小写，0-9 、_或 $ 组成；数字不可以开头；不可以使用关键字和保留字，但能包含关键字和保留字；Java 中严格区分大小写，长度无限制；标识符不能包含空格。 命名规范​ 命名规范，不强制但是强烈建议。 包名：xxxyyyzzz类名、接口名：XxxYyyZzz变量名、方法名：xxxYyyZzz常量名：XXX_YYY_ZZZ "},{"title":"变量​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#变量","content":"概念​ 内存中的一个存储区域该区域的数据可以在同一类型范围内不断变化变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值。 作用​ 用于在内存中保存数据。 使用规则​ Java 中每个变量必须先声明，后使用使用变量名来访问这块区域的数据变量的作用域为其定义所在的一对{}内变量只有在其作用域内才有效同一个作用域内，不能定义重名的变量 变量分类​ 按类型分类​  @startmindmap * Java 数据类型 **: 基本数据类型 （primitive type）; *** 数值型 **** 整数类型（byte，short，int，long） **** 浮点类型（float，double） *** 字符型（char） *** 布尔型（boolean） **: 引用数据类型 （reference type）; *** 类（class） ****_ 字符串在这里 *** 接口（interface） *** 数组（[]） @endmindmap Copy 按声明位置分类​ 成员变量：在方法体外，类内部声明的变量； 实例变量：没有static修饰的变量；类变量：有static修饰的变量。 局部变量：在方法体内部声明的变量。 变量的初始值​ 成员变量有初始值，局部变量没有初始值，需要显示初始化，不然不能通过编译检查。 数据类型\t默认值byte\t0 short\t0 int\t0 long\t0L float\t0.0F double\t0.0 char\t0（int类型）或'\\u0000' boolean\tfalse 引用类型\tnull 数据类型​   #\t数据类型\t占用存储空间\t表数范围\t备注1\tbyte\t1 字节\t[−128,127][-128,127][−128,127] 2\tshort\t2\t[−215,215−1][-2^{15},2^{15}-1][−215,215−1] 3\tint\t4\t[−232,232−1][-2^{32},2^{32}-1][−232,232−1]（约为 21 亿）\t默认的整数类型 4\tlong\t8 数字后面加l或L可声明为此类型 5\tfloat\t4\t尾数可以精确到 7 位有效数字\t后加f或F 6\tdouble\t8\t精度是float的两倍\t默认的浮点数字类型 7\tchar\t2\t\\u0000~\\uFFFF，即0~65535，无符号 16 位二进制数\t存储一个 Unicode 编码字符，用一对单引号''包括，可以用 Unicode 编码，比如'\\u00443' 8\tboolean 只可以在true或false两个字面量之间取值 浮点类型补充​ float 遵循 IEEE R32.24 规范，double 遵循 IEEE R64.53 规范。 无论是单精度还是双精度在存储中都分为三个部分： 符号位（Sign） ：0 代表正，1 代表为负指数位（Exponent）：用于存储科学计数法中的指数数据，并且要加上偏移量（float 偏移量 127，double 偏移量 1023）尾数部分（Mantissa）   注意： 浮点类型不精确，因为可能会舍弃存不下的位float 类型的表示范围比 long 类型的表示范围大 // TODO 补充浮点数知识 自动类型转换​ int a = 100; long b = a; Copy  容量（表数范围/精度）小的类型在需要的时候会自动转为容量大的类型，不会丢失精度；有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算；byte、short、char之间不会相互转换，它们三种类型在计算时会首先转为int类型；boolean类型不会与其他类型转换；任何基本数据类型和Sting字符串在进行+运算时，基本数据类型会首先被转换为字符串类型，参与字符串拼接。 Unicode 与 ASCII​ char类型的变量在转换为int类型的时候会转换为对应 Unicode 编码的十进制值。Unicode 兼容 ASCII。 ASCII TableUnicode 14.0 Character Code Charts String​ String不是基本数据类型，而是引用数据类型，它是一个类；可以使用字面量方式声明，用双引号&quot;&quot;包括；也可以用new String()的方式创建对象；String在和+使用的时候意义为字符串拼接而不是加法，在和基本数据类型进行拼接运算时，基本数据类型会首先被转为String类型； 强制类型转换​ long a = 100L; int b = (int) a; Copy boolean类型不可以被转换为其他类型；如果想把更大容量/更高精度的类型转为小容量/低精度类型的时候可以用强制类型转换，有丢失精度的和数据的风险。 "},{"title":"进制​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#进制","content":"这是常用进制在 Java 中的声明方式。 进制\t开头二进制（Binary）\t0b或0B 八进制（Octal）\t0 十进制（Decimal） 十六进制（Hex）\t0x或0X "},{"title":"运算符​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#运算符","content":"算术运算符​  %的结果和前一个操作数的正负相同，与后一个操作数的正负无关；(a++)++是行不通的，编译错误。 赋值运算符​ =当两侧的数据类型不一致的时候，可以使用自动类型转换或强制类型转换处理支持连续赋值扩展赋值运算符，不会改变原有的数据类型 +=，a+=b &lt;=&gt; a=a+b-=*=/=%= short s = 3; s = s + 2; // 编译不通过 s += 2; // 不改变原来的数据类型 Copy 比较运算符​  比较运算符的结果都是boolean类型，要么是true，要么是false。 逻辑运算符​  位运算符​   位运算符对整数的二进制进行运算；&lt;&lt;左移一位相当于×2\\times2×2；&gt;&gt;右移一位相当于÷2\\div2÷2；没有无符号左移运算符&lt;&lt;&lt;；异或^在交换两个整数类型变量的值的时候有妙用，异或三次次即可交换值，不需要中间变量。 // 加减交换整数值 // 可能会超出 int 的范围 n1 = n1 + n2; n2 = n1 - n2; n1 = n1 - n2; // 用异或交换整数值 n1 = n1 ^ n2; n2 = n1 ^ n2; n1 = n1 ^ n2; Copy 三元运算符​ （条件表达式） ? 表达式 1 : 表达式 2; Copy 当条件表达式为true时，执行表达式 1，整个表达式的值为表达式 1 的结果；否则执行表达式 2，整个表达式的结果为表达式 2 的结果；表达式 1 和表达式 2 必须是同种类型。 运算符的优先级​  "},{"title":"程序流程控制​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#程序流程控制","content":"顺序结构​ Java 程序在整体上是顺序结构的，依据语句书写的顺序从前往后执行。 分支结构​ ifif-elseswitch-case switch表达式中的值必须是下面几种类型之一 byteshortintcharEnum（JDK 5）String（JDK 7） case子句的值必须是常量，不能是变量名或者不确定值的表达式；所有case字句的值应该互斥；break关键字用于跳出switch结构，如果没有使用break则会接着向下执行，意味着可以匹配多个case；default子句是可选的，位置也是灵活的（不一定要写在case语句之后），在没有匹配到case语句时会执行default子句中的表达式；如果default语句写在case语句之前，并且没有break，在匹配default语句之后还会向下执行case里的语句，直到遇到break或者执行完毕。这是一个很反直觉的行为，所以default子句尽量写在最后，并且如果不是特殊情况下，每条case语句都应包含一个break。 循环结构​ forwhiledo-while "},{"title":"数组​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#数组","content":""},{"title":"数组的概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#数组的概述","content":"数组（Array）是多个相同数据类型按一定顺序排列的集合。 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型；数组在内存中是一整块连续的空间，数组名引用的是这块连续空间的首地址；数组的长度一旦确定就不能修改。 "},{"title":"一维数组​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#一维数组","content":"声明​ int a[]; int[] a; Copy 动态初始化​ int[] arr = new int[3]; arr[0] = 3; Copy 静态初始化​ int[] arr = new int[]{1, 2, 3}; // 类型推断 int[] arr = {1, 2, 3}; Copy 默认值​ 数组成员具有默认值，和成员变量的初始值规则相同。不管是通过动态初始化还是静态初始化的方式来初始化数组，数组成员都有默认值，不过通过静态初始化方式初始化之后，数组成员的值又立刻被修改了一次。 "},{"title":"多维数组的使用​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#多维数组的使用","content":"声明​ int arr[][]; int [][] arr; // 也可以这样写 int[] arr[]，也是二维数组的声明 int[] arr[] = new int[3][3]; // 注意特殊写法 // x 是一维数组，y 是二维数组 int[] x, y[]; Copy 动态初始化​ int arr[][] = new int[3][2]; arr[0][1] = 2; Copy // 后面的可以先不初始化 int arr[][] = new int[3][]; arr[0] = new int[3]; arr[0][2] = 1; // 多维数组不必是规则矩阵形式 arr[1] = new int[2]; arr[1][1] = 2; Copy 静态初始化​ int[][] arr = new int[][]{{1, 1, 1}, {2, 2, 2}, {3, 3, 3}}; // 类型推断 int[][] arr = {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}}; Copy "},{"title":"面向对象编程​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#面向对象编程","content":""},{"title":"面向过程与面向对象​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#面向过程与面向对象","content":"面向过程编程（Procedure Oriented Programming，POP），以函数为最小单位，考虑怎么做； 面向对象编程（Object Oriented Programming, OOP），以类/对象为最小单位，考虑谁来做。 "},{"title":"面向对象的三大特征​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#面向对象的三大特征","content":"封装（Encapsulation）​ 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的安全性、可扩展性和可维护性。 修饰符\t同一个类\t同一个包\t不同包的子类\t同一个工程private\t✅ （空）\t✅\t✅ protected\t✅\t✅\t✅ public\t✅\t✅\t✅\t✅ 在修饰class时只能用public或者空修饰符。 继承（Inheritance）​ 子类继承了父类，就继承了父类的所有方法和属性。但是父类中的private成员进行了隐藏，不能直接访问。 父类中的成员，无论是公有还是私有，均被子类继承。只是因为访问控制修饰符的原因，子类不能对继承的私有成员直接进行访问。 子类不会继承父类的构造器，但是一定会调用父类的构造器。 Java 中只能实现单继承。 Java 中所有的类都直接或间接继承自Object类。 子类可以根据需要方法重写（Overwrite）。 子类中的方法和父类中的方法必须有相同的名称和参数列表；子类方法的返回值类型不能大于父类方法的返回值类型；子类方法的访问权限不能小于父类方法的访问权限； 父类中的private方法不能被重写，但是可以在子类中声明相同方法签名的方法，不称为重写；父类中的static方法也不能被重写，可以重新声明。 子类方法抛出的异常不能大于父类方法的异常。 多态（Polymorphism）​ 编译时和运行时对象类型不一致，就出现了对象的多态性。子类对象可以替代父类对象使用。 编译时，看左边（类型声明）；运行时，看右边（对象实例）。 多态不适用于属性，属性是在编译器确定的，运行时也看左边。 意味着方法会被完全覆盖，但是属性不会被覆盖。但是依然可以在子类内部通过super关键字调用直接父类中被覆盖的方法。 可以通过向上转型和向下转型来使用继承树中各个类的属性和方法。 instanceof运算符用来判断某一个对象是否是某个类或该类子类的实例，返回true或false。 java.lang.Object#getClass方法可以获取对象的运行时类名。 抽象​ 也算是面向对象的特征之一，如果有人问的话。 "},{"title":"类和对象​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#类和对象","content":"类（Class）是对一类事物的描述，是抽象的、概念上的定义； 对象（Object）是实际存在的该类事物的每个个体，也称为实例（Instance）。 "},{"title":"类的成员​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#类的成员","content":"属性​ 属性（Field）又称为成员变量，分为实例变量（没有static修饰）和类变量（有static修饰）。 方法​ 方法的重载（Overload）指的是在同一个类内同名但是参数列表不完全相同的多个方法； 方法的重写（Overwrite）指的是在子类中对父类中已有的方法进行重新实现，方法的签名相同（返回值和抛出的异常范围可以更小）。 参数的值传递：对于基本数据类型，形参（方法内可以操作的参数）就是实参的复制，对形参的改变不会影响到实参；对于引用数据类型，形参是实参内存地址的复制，对形参直接修改不会影响到实参，通过形参名指向的内存地址对该对象/数组内的成员进行操作实际上就是对实参的操作。 构造器​ 没有返回值 在创建对象的时候自动执行 可以用public/protected/private修饰 protected的构造器只能在当前包内用，其它地方不能new这个对象private的构造器只能在类内部用，不能在外部用，常用于单例模式 构造器不是方法 构造器不能被继承 代码块​ 代码块中的变量都是局部变量。 内部类​ 在 Java 中，允许在在类中定义类结构，称为内部类。内部类的名称不能与外部类的名称相同。 可以被以下关键词修饰： staticfinalabstract成员内部类可以被四种不同的权限修饰符修饰 成员内部类​ 静态内部类 可以调用外部类的静态成员，包括私有的；在外部可以直接实例化；静态内部类不会随着外部类的初始化而初始化，只有在用到的时候才会被初始化，静态内部类内的静态代码块不会随着外部类的初始化而执行。 InnerClassTest.StaticA staticA = new InnerClassTest.StaticA(); Copy 非静态内部类 可以调用外部的非静态成员，相当于外部类类名。this. 成员，包括私有的；在内部类中this指向自身，外部类类名。this可以访问外部类的this；在外部实例化非静态内部类时需要先实例化外部类，通过外部类实例化内部类。 A.B.C c = new InnerClassTest().new A().new B().new C(); Copy 局部内部类​ 定义在方法中。 局部内部类可以使用外部方法的局部变量，但是该变量必须是final的，Java 8 中在局部内部类使用的外部局部变量会自动声明为final的 Java 8 之前需要手动声明。由局部内部类和局部变量的不同生命周期所致；不能使用权限修饰符，和局部变量一样；不能使用static修饰，因此也不能包含静态成员。 匿名内部类​ 匿名内部类必须继承父类或实现接口匿名内部类只有一个对象匿名内部类的对象只能用多态形式引用 "},{"title":"关键字​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#关键字","content":"class​ 用于定义类，只能用public或者空权限修饰符。 this​ 实例本身的引用；在构造器中代表正在初始化的对象；可以在构造器中调用其它重载的构造器，必须放在构造器代码块的首行。 super​ 用于显式调用继承来的成员（成员变量/方法）；用于调用直接父类的构造器，必须在子类的构造器中使用，必须在代码块的第一行； static​ static可以用来修饰： 属性方法代码块内部类 被修饰的成员有以下特点： 随着类的加载而加载，只会加载一次优先于对象存在修饰的成员被所有该类的对象共享访问权限允许时，可以不创建对象，直接通过类名调用 final​ final可以用来修饰： 类，表示该类不能被继承方法，表示该方法不能被重写成员变量，表示该变量的值不能被修改，即为常量，必须在声明时赋值或者在构造器中赋值局部变量形参，表明形参在方法的代码块内不能被修改 abstract​ abstract可以用来修饰： 类，抽象类 抽象类不能被实例化，必须有子类继承它并且实现所有的抽象方法之后才能实例化子类如果子类没有重写所有的抽象方法，子类也必须声明为抽象类，含有抽象方法的类必须声明为抽象类不能用abstract修饰final类抽象类可以有构造器 方法，抽象方法 含有抽象方法的类必须声明为抽象类不能用abstract修饰private方法、静态方法、final方法 interface​ 用于定义接口。 接口的思想就是定义了规范，继承是「是不是」的关系，而接口是「能不能」的关系。 接口的所有成员变量默认都是public static final修饰的接口中的所有方法都默认都是public abstract修饰的接口没有构造器一个类可以实现多个接口接口也可以实现其它接口接口与实现类之间也可以表现出多态的特性 Java 8 中对接口的增强： 静态方法默认方法 如果实现了接口并继承了一个类，并且接口中有默认方法和类中的方法同名同参数列表，则接口中的默认方法会被忽略，遵循类优先原则，子类在通过super调用父类方法的时候会调用类中的方法而不是接口中的默认方法，如果需要调用接口中的默认方法可以通过接口名。super. 方法名 ()来调用。 public class InterfaceTest { public static void main(String[] args) { new C().a(); } } interface A { default void a() { System.out.println(&quot;a&quot;); } } abstract class B { public void a() { System.out.println(&quot;b&quot;); } } class C extends B implements A { @Override public void a() { super.a(); A.super.a(); } } Copy 接口可以完全取代抽象类吗？ 不能，抽象类有类的结构，比如说构造器，抽象类可以私有的成员；接口中只能定义public的成员。抽象类可以实现更多细节，接口更轻量。能用接口实现的就尽量用接口，不能用接口实现的采用抽象类。 package​ 指明本源文件中定义的类所在的包。 import​ import用于声明本源文件中用到的外部类的包位置。 java.lang包下的类不需要声明，可以直接用。 import static用于引入外部的静态成员（静态变量/静态方法），可以直接在本源文件中通过名称调用，不用再加上其所在的类名。 native​ 用来修饰方法，表明该方法不是用 Java 语言实现的，而是用底层的 C 语言或者 C++ 实现的。 "},{"title":"类的初始化顺序​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#类的初始化顺序","content":"在编译后的字节码文件中不存在构造器，转而出现了&lt;init&gt;()方法，该方法包括： 代码块中的代码显示赋值的代码构造器中的代码 其中 1 和 2 的执行顺序与代码的实际顺序相同，构造器中的代码总是最后执行。 &lt;init&gt;()方法的数量与构造函数的数量相同，调用构造方法实际上就是调用了对应的该方法。 也不存在代码块了，代码块中的代码都拷贝到每个&lt;init&gt;()方法中了。显示赋值也消失了，也同时放在该方法中执行。执行顺序与源码中的书写顺序一致。 最后才是构造器中原有的代码执行。 在有继承的情况下，先在父类中按照此顺序执行，然后再到子类中按照此顺序执行。 如果子类重写了父类的方法，则会调用子类中的该方法而不是父类中的方法。 静态代码块在类初始化的时候执行，所以优先级最高。 父类：成员变量之前的静态代码块父类：成员变量之后的静态代码块子类：成员变量之前的静态代码块子类：成员变量之后的静态代码块父类：成员变量之前的代码块父类：显式赋值父类：成员变量之后的代码块父类：构造方法子类：成员变量之前的代码块子类：显式赋值子类：成员变量之后的代码块子类：构造方法 "},{"title":"异常处理​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#异常处理","content":""},{"title":"异常概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#异常概述","content":"程序执行中发生的不正常情况称为「异常」。开发过程中的语法错误和逻辑错误不属于异常。 "},{"title":"异常体系结构​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#异常体系结构","content":" Throwable是所有异常的公共父类，只有此类才能被抛出或者抓取。 Error，Java 虚拟机无法解决的严重的问题，如 JVM 内部系统严重错误、资源耗尽等严重情况等，一般不编写针对性的代码进行处理，捕获了也没用，应该从其它方面解决这些问题；Exception，其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。 RuntimeException，运行时异常，不建议捕获，应该尽量避免。因为这些异常发生比较频繁，如果在代码中显示捕获的话不利于阅读；其它异常，在编译时就能发现并且必须处理的异常，要么捕获，要么一直抛出到最上级。 "},{"title":"常见异常​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#常见异常","content":""},{"title":"异常处理机制​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#异常处理机制","content":"try-catch-finally​ try 包裹可能发生异常的代码块。如果出现异常就会在当前执行的语句处中断。如果在catch中捕获了该类型的异常就会跳转到对应的catch代码块。如果显式抛出异常则当前方法中断，异常交给调用者处理。如果都没有则程序中断。 catch 捕获某种类型的异常，可以多个catch并列，在捕获到异常之后进行对应处理。 finaly 不管有没有发生异常，该代码段都会执行，通常用于资源清理工作，确保无论何时资源都能被正常关闭。如果该代码块里使用了return语句，那么在try或者catch代码块里的 return语句将失效，因为在执行 try代码块里的return语句之前会先执行finally代码段里的return，然后方法就终止了。还有需要注意的是，如果在finally代码块里没有return语句的情况下，修改返回变量的值是无效的，在执行finally代码块之前就已经将返回值给到return处了，再执行return的时候不会拿最新的变量值，类似于i++的机制。 try-with-resoucees​ Java 8 引入，实现AutoCloseable接口的资源可以放在try后面的括号里初始化，在之后会自动关闭；多个资源之间用分号分隔。 Java 9 增强，资源可以不在括号中初始化，在其中声明即可。 try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } catch { } Copy throws​ 写在参数列表之后，方法体之前。表明当前方法可能会抛出异常的类型，这些异常不会在该方法内被处理。告知调用者在使用此方法的时候应该对这些异常进行处理，要么捕获要么再抛出。 throw​ 在方法体内中使用，主动抛出一个异常，终止该方法。 如果是一个编译时异常就需要在throws后声明，如果是运行时异常就不用声明。 "},{"title":"自定义异常​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#自定义异常","content":"从Exception或者它的子类派生出一个新类即可。 "},{"title":"多线程​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#多线程","content":""},{"title":"多线程基本概念​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#多线程基本概念","content":"程序（Program）是一段有序执行的静态代码的集合；进程（Process）是程序的一次执行过程，有生命周期；线程（Thread）是进程的进一步细分，比进程更轻量化，在线程之间切换的开销更小，效率更高，多个线程可以共享相同的内存区域。 一个 Java 程序至少有三个线程：主线程、垃圾回收线程和异常处理线程。 并行：多个 CPU 同时执行多个任务；并发：一个 CPU 采用时间片同时执行多个任务。 "},{"title":"线程的创建和使用​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#线程的创建和使用","content":"继承 Thread 类​ 从 Thread 类中派生出一个新类，重写run方法；创建线程类的对象，调用start方法，Java 会新开一个线程，执行run方法。 实现 Runnable 接口​ 新类，实现 Runnable 接口，重写run方法；还是通过Thread类来执行，它有一个构造方法接收Runnable类型的参数；调用Thread对象的start方法来启动线程。 Callable 和 FutureTask​ Java 5 新增，可以获得线程运行完毕之后的结果，返回值具有泛型支持。 新类，实现Callable接口，重写call()方法。 用FutureTask套Callable，再用Thread套FutureTask。 可以用FutureTask的get()方法获取返回值，这个方法会一直阻塞直到得到结果。 CallableDemo cd = new CallableDemo(); FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(cd); new Thread(task).start(); log.info(&quot;Task started.&quot;); String result = task.get(); log.info(&quot;Result got： {}&quot;, result); Copy 线程池​ Java 5 中提供的线程池 API，ExecutorService和Executors。 可以手动创建线程池。 ExecutorService是接口，常见子类有ThreadPoolExecutor。 也可以使用Executors工具类来创建预先定义好设置的线程池。 Executors.newCachedThreadPool()newFixedThreadPool()newSingleThreadPool()newScheduledThreadPool() 创建线程池之后会拿到一个ExecutorService接口的对象，其实现类为ThreadPoolExecutor，其中有两个方法可以提交新任务。 submit(Runnable task)执行成功返回nullsubmit(Callable&lt;T&gt; task)有返回值execute(Runnable command)无返回值 "},{"title":"Thread 类中的常用方法​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#thread-类中的常用方法","content":"run要求子类重写，它的方法体也成为线程体start线程启动sleep(long millis)阻塞线程getName获取线程名称，默认是自动生成的，也可以在实例化对象的时候传递给构造器setName设置线程名称static currentThread获取当前线程的实例getPriority获取线程优先级，默认线程的优先级和它被创建的线程的优先级相同，主线程的默认优先级是 5setPriority设置线程优先级，范围为[1,10][1,10][1,10]，越大约高，但是执行时间还得看系统的调度策略checkAccess判断当前线程有没有权限修改目标线程stop()废弃的中断线程方法interrupt中断线程，如果在线程外部中断要确保有权限修改该线程。如果线程被其它方法阻塞的时候中断还会抛出异常join在线程外执行，阻塞当前线程，一直等到该线程执行完毕yeld放弃本次 CPU 时间 "},{"title":"线程的生命周期​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#线程的生命周期","content":"以下是操作系统概念中的线程的生命周期。 状态名\t解释\t触发条件创建\t新建但未开始\t在生成线程对象，并没有调用该对象的start()方法 就绪\t处于就绪队列\tstart()之后，但未获得 CPU 时间片 运行\t正在执行\t获得 CPU 时间片 阻塞\t处于阻塞队列\t等待资源、wait()、sleep()、suspend() 死亡\t执行完毕\trun()方法运行完毕或者调用stop()方法  JDK 中用枚举类Thread.State定义了线程的几种状态。 状态名\t解释\t触发条件NEW\t新建但未开始\tnew之后，start()之前 RUNNABLE\t可运行\t正在运行或者处于就绪队列 BLOCKED\t阻塞\t等待监视器锁或者调用wait() WAITTING\t等待\twait() TIMED_WAITTING\t可自行返回的等待状态\tsleep()、带时间的wait()、带时间的join() TERMINATED\t执行完毕\trun()方法运行完毕或者调用stop()方法 "},{"title":"线程的同步​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#线程的同步","content":"同步代码块​ synchronized（锁对象）{} Copy 规定一段代码，在任何时刻只能有一个对象运行。在运行之前会检查锁对象是否已加锁，如果没有，在运行的时候就给锁对象加锁，运行结束之前解锁。 关于锁对象，要确保它在每个实例中是同一个对象。以继承Thread方式创建的线程中就不能使用this作为锁对象，因为每个实例中的Thread对象不同；以实现Runnable接口方式创建的线程可以使用this作为锁对象，因为在创建线程的时候可以只有一个该类的实例，然后通过这唯一的实例去创建线程。并且在后一种方式中，所有线程共享数据，不需要用static修饰。 同步方法​ 用synchronized修饰方法，同一时刻只能有一个线程执行此方法。 同步方法无法自己选择锁对象。对于非静态方法，锁对象是this；对于静态方法，锁对象是当前类的Class对象。 使用的时候就要判断锁对象合不合适。 Lock​ 在 Java 5 之后提供了一种新的方式来确保线程安全，可以通过显式定义同步锁对象来实现同步。 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。ReentrantLock是该接口的实现类。  "},{"title":"线程的通信​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#线程的通信","content":"在 Object 类中定义了一些方法。 wait在被手动唤醒之前一直暂停此线程，必须由锁对象（线程监视器对象）来调用notify唤醒一个正在等待的线程，从上次暂停的地方继续执行notifyAll唤醒所有正在等待的线程，在多个生产者和多个消费者的时候注意用 wait()和sleep() Object.wait()会释放锁，Thread.sleep()不会释放锁。 生产者和消费者问题。 package org.example.thread_test; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ProducerConsumerTest { public static void main(String[] args) { ExecutorService pool = Executors.newFixedThreadPool(7); Clerk clerk = new Clerk(); Producer producer = new Producer(clerk); Consumer consumer = new Consumer(clerk); pool.execute(producer); pool.execute(consumer); pool.shutdown(); } } @Slf4j class Producer implements Runnable { private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { clerk.add(); } } } @Slf4j class Consumer implements Runnable { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { clerk.minus(); } } } @Slf4j class Clerk { private int count = 0; public static final int MAX = 20; public synchronized void add() { try { Thread.sleep(100L); } catch (InterruptedException e) { e.printStackTrace(); } if (count &lt; MAX) { log.info(&quot;生产 1，剩余 {}&quot;, ++count); notify(); } else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } public synchronized void minus() { try { Thread.sleep(100L); } catch (InterruptedException e) { e.printStackTrace(); } if (count &gt; 0) { log.info(&quot;消费 1，剩余 {}&quot;, --count); notify(); } else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } Copy "},{"title":"懒汉单例模式的线程安全问题​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#懒汉单例模式的线程安全问题","content":"常规方法，使创建对象的操作互斥，只允许创建一个对象。 class Lazy { private static Lazy INSTANCE; private Lazy() { } public static Lazy getInstance() { if (INSTANCE == null) { // 外层判断为了提高效率 // 当内层已经创建好对象之后，其它线程和创建对象的线程就不是竞争关系了 // 可以直接去取已经创建好的实例 synchronized (Lazy.class) { if (INSTANCE == null) { // 内层判断为了安全 INSTANCE = new Lazy(); } } } return INSTANCE; } } Copy 还有一种更简单的方法，利用内部类不会随着外部类的初始化而初始化的特点，完成懒汉单例。 class SimpleLazy { private SimpleLazy() { } public static SimpleLazy getInstance() { return Inner.INSTANCE; } // 内部类不会随着外部类的初始化而初始化 // 静态代码不会随着外部类的初始化而执行 // 而是在使用的时候才会初始化 private static class Inner { public static final SimpleLazy INSTANCE = new SimpleLazy(); } } Copy "},{"title":"ThreadLocal​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#threadlocal","content":"数据容器，和线程绑定。每个线程得到的值不一样。 "},{"title":"枚举类​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#枚举类","content":"Java 5 之后，有了enum关键字，可以更方便地实现枚举类。 枚举类型不能继承其它类型，因为枚举类型的每个实例实际上继承了java.lang.Enum抽象类。 protected Enum(String name, int ordinal); public final String name(); public final int ordinal(); Copy 在编译的时候编译器会将enum真正转化为Enum的子类，所以可以使用该类的方法。 并且Enum类重写了toString()方法，默认返回name属性值。 Enum类中还有一个静态方法valueOf，可以获取对应值的枚举类实例。 public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) Copy 还有一个values方法不是继承的，而是编译器添加的。它存在于每个枚举类中，能获取到该类的对应值的枚举类实例。 public static T[] values() Copy 枚举类可以实现接口，并且每个常量可以分别对接口有不同的实现。也可以统一实现接口，跟正常用法一样。 public class Test6 { public static void main(String[] args) { MyEnum.A.test(); // a MyEnum.B.test(); // b MyEnum.C.test(); // 统一实现 } } interface MyInterface { void test(); } enum MyEnum implements MyInterface { A { @Override public void test() { System.out.println(&quot;a&quot;); } }, B { @Override public void test() { System.out.println(&quot;b&quot;); } }, C; @Override public void test() { System.out.println(&quot;统一实现&quot;); } } Copy "},{"title":"注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#注解","content":"其实也是一种注释，是代码级别的注释，会被编译器处理。普通注释会被编译器直接忽略。不直接修改程序逻辑，可以通过反射读取出注解信息，根据需要作出不同行为。 "},{"title":"预定义注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#预定义注解","content":"@Override，标注在方法上，在编译时会检查这个方法是否符合重写的要求，一定确保这个方法成功重写了父类的方法。给程序员看的时候也能快速看出这是一个重写的方法。@Deprecated，标注方法，表明该方法已弃用，有更好的实现供选择。@SuppressWarnings，抑制编译时的警告信息，可以作用在类、类成员、方法参数等。会抑制在该类型作用域内的所有警告信息。value参数可以传入具体抑制哪种警告，或者传入「all」抑制所有警告信息。 "},{"title":"文档注释相关注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#文档注释相关注解","content":"@author@param@return@see@since@version@exception@throws... "},{"title":"自定义注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#自定义注解","content":"定义注解​ 属性的数据类型有限制： 基本数据类型String枚举ClassAnnotaion以上这些类型的数组 属性可以有默认值，可以通过default关键字来实现。 @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface Test7 { String value() default &quot;111&quot;; String[] name(); } Copy 元注解​ 标注在注解声明处的注解。 @Target指明注解可以标注的位置。@Retention指明注解的生命周期。 SOURCE只在源码阶段有效，就跟普通的注释一样，编译的时候丢弃CLASS在编译的时候会保存到字节码文件中，但是虚拟机不会在运行时保留，默认是这个级别RUNTIME会在运行时保留，可以通过反射读取 @Documented被 javadoc 读取。@Inherited继承的时候也会继承到注解。 使用​ 在合适位置标注，以@开头。 如果注解没有属性，不需要加括号。 如果注解只需传入一个value属性，则直接传入属性即可。 如果需要传入的属性有多个，或者传入的单个属性不是value，则需要使用键值对的形式传入对应的值。 如果传入的属性要求是数组，在数组只有一个元素的情况下可以省略花括号{}。 @Test7(value = &quot;&quot;, name = &quot;&quot;) @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface Test7 { String value(); String[] name(); } Copy 读取​ 参考反射相关知识。 "},{"title":"Java 8 注解新特性​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#java-8-注解新特性","content":"@Repeatable可重复注解​ 在 JDK8 之前如果需要重复注解的话，需要新建一个注解，其中包含目标注解的数组，通过数组来重复使用注解。 在 JDK8 中新增了一个元注解@Repeatable，还是需要一个新的注解包含目标注解的数组，但是不需要用数组的方式传递了，直接标注多个同类型的注解即可。 类型注解​ @Target的参数ElementType的枚举值多了两个： TYPE_PARAMETER：表明注解可以使用在类型变量的声明语句中，如泛型声明；TYPE_USE：表示注解能使用在任何类型的语句中，泛型、变量类型转换、抛出的异常。 "},{"title":"常用类​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#常用类","content":""},{"title":"Object​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#object","content":"Object是所有类的根父类。 equals，比较两个对象，默认行为和比较运算符==相同，都是比较内存地址，子类可以根据需要对该方法进行重写，对内容进行比对；hashCode，默认根据内存地址计算对象的哈希值，如果重写了equals方法则原则上需要重写此方法；clone，返回对象的复制，是一个protected方法，子类需要重写此方法并调用super.clone()，也可以自己实现克隆细节，并实现Cloneable接口；finalize，在对象被回收之前垃圾回收器会调用此方法，子类可以重写此方法来在被回收之前做一些事情；可以通过System.gc()或Runtime.getRuntime().gc()来通知垃圾回收器进行回收，但是否会进行回收是不确定的；toString，返回对象的字符串表示，建议所有子类重写。默认返回「类名@十六进制 hash」。getClass，获取当前对象的运行时类名。 "},{"title":"包装类​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#包装类","content":"Java 提供了 8 种基本数据类型的包装类，使得基本数据类型的变量具有类的特征。 基本数据类型\t包装类byte\tByte short\tShort int\tInteger long\tLong float\tFloat double\tDouble boolean\tBoolean char\tCharacter 其中，Byte、Short、Integer、Long、Float和Double都是Number的子类。 自动装箱与自动拆箱​ JDK 1.5 提供的自动拆箱和自动封箱的机制可以让基本数据类型和包装类自动转换。在需要的时候，自动在基本数据类型和包装类之间转换。 Integer a = 5; int b = a;` Copy 缓存​ 为了提高性能，比较常用的基本数据类型的包装类会被缓存。 通过new关键字获取的对象在堆中，直接得到的包装类在方法区中，这个才是被缓存的。 基本数据类型\t包装类\t缓存byte\tByte\t[−128,127][-128,127][−128,127] short\tShort\t[−128,127][-128,127][−128,127] int\tInteger\t[−128,127][-128,127][−128,127] long\tLong\t[−128,127][-128,127][−128,127] float\tFloat\t不缓存 double\tDouble\t不缓存 char\tCharacter\t[0,127][0,127][0,127] boolean\tBoolean\ttrue和false 常用 API​ 字符串解析​ 各个包装类都有一个parseXxx的方法，用于从字符串中解析出对应类型的值，返回包装类。 public static int parseInt(String s) throws NumberFormatException Copy Integer​ MAX_VALUEint 类型可表示的最大值，2^{31}-1231−1MIN_VALUE最小值，-2^{31}−231toBinaryString转为二进制字符串toOctalString八进制toHexString十六进制 Character​ toUpperCasetoLowerCase "},{"title":"System​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#system","content":"包含三个流： PrintStream outInputStream inPrintStream err 这是系统默认的输出流，可以通过setIn、SetOut、SetErr来替换掉系统默认的输出流。 常用方法： currentTimeMillis()arraycopy(Object src, int srcPos, Object dest, int destPos, int length)exit(int status)getProperty(String key) "},{"title":"String​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#string-1","content":"与基本数据类型的转换​ String-&gt;基本数据类型 使用各个包装类的方法，使用的时候注意可能会抛出异常 Integer.parseInt()Float.parseFloat() 基本数据类型-&gt;String String.valueOf()使用连接运算符+，1 + &quot;&quot; = &quot;1&quot; 特殊性​ 通过字面量声明的 String 对象存在常量池中，是不可变的，只要修改了字符串就会产生新对象。通过new关键字取得的字符串对象不在常量池中。 常量池里的对象可以共享，提高性能。 常量池位置​ Java 6，在方法区； Java 7，在堆中专门划分了一块区域来存储字符串常量； Java 8，在元空间（Meta space）中，类似于方法区，甚至可以独立于 JVM 存在。 底层存储结构​ Java 8，使用char[]存储； Java 9，使用byte[]存储。 不可变性​ char[]使用final修饰，意味着数组不能扩容。同时它也是私有的，外部也不能修改某一个元素的值；String 提供的所有对字符串修改的方法都会返回一个新对象。 字面量和直接创建对象的不同​ String str = new String(&quot;str&quot;); Copy 在这个过程中产生了两个对象；&quot;str&quot;是一个对象，在常量池；又通过new关键字得到一个对象，在堆。两者的char values[]指向相同的地址。具体代码在 String 的构造器中。 拼接​ String s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; String s3 = &quot;helloworld&quot;; String s4 = s1 + &quot;world&quot;; String s5 = s1 + s2; String s6 = &quot;hello&quot; + &quot;world&quot;; System.out.println(s3 == s4); // false System.out.println(s3 == s5); // false System.out.println(s3 == s6); // true Copy 只要有变量参与的拼接，结果都在堆中。s6在编译期间就可以确定结果，所以存在常量池中。 如果给 s1 和 s2 加上final修饰，那么结果都为true。 常用方法​ equals(Object anObject)equalsIgnoreCase(String anotherString)compareTo(String anotherString)compareToIgnoreCase(String str)intern()把字符串放入常量池，并返回引用length()isEmpty()concat(String str)与另一个字符串相连接，相当于+trim()移除开头和结尾的空白字符substring(begin, end)返回子字符串，索引从 0 开始，包含包含左边不包含右边。左闭右开toCharArray()转为字符数组getBytes()转为字节数组 字典排序​ String 实现了Comparable接口，但是默认是按照 Unicode 编码值排序。 java.lang.Collator类实现了Comparator接口，可以选择各地的语言习惯来排序。 在有拼音排序的需求的时候可以采用这个方法来实现。 Collator collator = Collator.getInstance(Locale.CHINESE); int compare = collator.compare(&quot;差&quot;, &quot;啊&quot;); System.out.println(compare); Copy "},{"title":"StringBuffer​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#stringbuffer","content":"可变字符序列。线程安全。效率更低。而StringBuilder相反。默认容量是 16。 没有重写equals方法，比较的是内存地址。 "},{"title":"StringBuilder​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#stringbuilder","content":"可变字符序列，Java 5 新增，非线程安全。默认长度是 16，在需要的时候会自动扩容到原来长度的 2 倍再加上 2。 没有重写equals方法，比较的是内存地址。 appendinsertdelete "},{"title":"Math​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#math","content":"abs绝对值三角函数sqrt平方根pow幂运算round四舍五入ceil返回比参数大的最近一个整数floor返回比参数小的最近一个整数 "},{"title":"Random​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#random","content":"nextInt(int)，随机返回一个在[0,i−1][0,i-1][0,i−1]之间的数。 // 返回一个 [left, right] 之间的数 public static int randomInt(int left, int right) { Random random = new Random(); return random.nextInt(right - left + 1) + left; } Copy "},{"title":"BigInteger​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#biginteger","content":"支持更大的范围，多了一些运算方法。 "},{"title":"BigDecimal​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#bigdecimal","content":"精度更高。注意 buyo addsubtractmultiplydivide "},{"title":"日期时间​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#日期时间","content":""},{"title":"旧日期时间​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#旧日期时间","content":"Date​ 除了下面两个构造器，其它的都过时了。 Date()当前日期获得对象Date(long date)毫秒时间戳转为日期 其中大部分方法也已经过时，可以被Calendar或者DateFormat中的方法替换。 java.sql.Date是 java.util.Date的子类，无特殊需要的情况下均用java.util.Date。 Calendar​ 这是一个抽象类，可以使用它的实现类GregorianCalendar。可以通过Calendar.getInstance()来获取它的实例。 getInstance()获取实现类的实例getInstance(Locale aLocale)getInstance(TimeZone zone)get(int field)通过常量值来获取当前日历对象的某个字段值，比如年份 TimeZone​ 抽象类，可以用静态方法getTimeZone来获取实现类的实例。 getTimeZone(String ID)getAvailableIDs()获取所有时区 id DateFormat​ 这也是一个抽象类，用的是SimpleDateFormat。 SimpleDateFormat(String pattern)构造器，出入格式化字符串format(Date date)将日期对象格式化，返回字符串parse(String source)按照格式将字符串解析为日期对象 "},{"title":"新日期时间​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#新日期时间","content":"Java 8 引入了新的日期时间 API。新的对象是不可变的，修改会产生新对象。 新引入了另一套处理日期时间的体系，Date 可以通过toInstant()方法转为新 API。 LocalDate​ yyyy-MM-dd格式的日期。 LocalTime​ 只有时间。 LocalDateTime​ 日期时间。 static now()基于现在的时间创建对象static of()给定日期时间创建对象getMonthgetXxxwithMonth修改月份并返回一个新对象withXxxplusXxx加时间minusXxx减时间isLeapYear是否是闰年format格式化，返回字符串static parse给定字符串和格式解析为时间对象 Duration​ 时间之间的间隔。更精确。 Period​ 日期之间的间隔。 Instant​ 瞬时时间。可以精确到纳秒。从 1970 年的开始算的。没有其它任何上下文信息。 ZonedDateTime​ 带时区的时间。 TemporalAdjuster​ 时间调整期，这是一个接口。在TemporalAdjusters中有许多方法可以得到它的实例。 DateTimeFormatter​ 格式化器。可以用来格式化日期或从字符串解析出日期时间。 ofPattern "},{"title":"工具类​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#工具类","content":""},{"title":"Arrays​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#arrays","content":"copyOf System.arraycopy() sort "},{"title":"Collections​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#collections","content":"Collection 相关的工具类，其中包含了大量的静态方法，方法的参数或者返回值是 Collection。 "},{"title":"Objects​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#objects","content":""},{"title":"Spliterators​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#spliterators","content":""},{"title":"Files​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#files","content":""},{"title":"Paths​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#paths","content":""},{"title":"常用接口​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#常用接口","content":""},{"title":"Comparable​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#comparable","content":"自然排序。需要比较的对象自身实现此接口。String及包装类都实现了此接口。 public int compareTo(T o); Copy "},{"title":"Compartor​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#compartor","content":"定制排序。作为一个比较器，参数需要放入两个对比的对象。 int compare(T o1, T o2); Copy "},{"title":"Serializable​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#serializable","content":""},{"title":"集合​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#集合","content":" "},{"title":"Collection​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#collection","content":"是单列数据结构的父接口。 for 循环遍历​ 通过size()方法得到集合的长度，通过元素下标遍历，下标从 0 开始。 迭代器遍历​ 调用Iterable#iterator()方法来得到迭代器对象，每次调用都会得到一个新的迭代器对象。 Iterator&lt;E&gt; iterator() 迭代器是一次性使用的，元素的顺序不能保证，只能向后遍历，不能回溯。Java 8 新加入了forEachRemaining方法，可以用函数式接口完成遍历。 boolean hasNext()E next()void remove()void forEachRemaining(Consumer&lt;? super E&gt; action) 在迭代器的过程中不能使用集合本身的有关元素修改的操作如add()和remove()，不然迭代器在下次迭代的时候会抛出异常，这样做的是为了避免同步问题。 在AbstractList中有一个modCount变量，在涉及到对列表元素进行修改的方法中会将modCount++。在迭代器Itr构造的时候会保存当前的modCount值为expectedModCount，在每次迭代和remove()之前都会比对这两个值，如果不相等则意味着在迭代器之外有操作对列表元素进行了修改，为了避免同步问题就会抛出ConcurrentModificationException异常。 如果没有调用next()直接调用remove()，或者在调用了next()之后调用了两次remove()，都会抛出IllegalStateException异常。迭代器Ite中维护了一个lastRet变量，默认是-1，在调用next()之后会更新为当前元素的下标，在调用remove()之后会更新为-1，在调用remove()之前会对其进行检查，如果从来没有调用过next()或者调用两次remove()的时候会抛出异常。 for-each 循环​ Java 5 中新增的语法糖，实际上调用的是迭代器的方法，所以有和迭代器一样的限制。数组也可以用这种方式遍历。注意遍历过程中的元素变量只是局部变量。 for(Person p: persons){ System.out.println(p); } Copy "},{"title":"List​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#list","content":"Vector出现较早（Java 1.0），是线程安全的，效率低ArrayList出现较晚（Java 1.2），是非线程安全的，效率高LinkedList的数据结构是双向链表，其它两者的数据结构是数组，因此对于频繁的插入、删除操作，LinkedList的效率更高 "},{"title":"Set​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#set","content":"无序、不可重复的数据结构。底层用的是Map，只用了 key 的那一列。 HashSet，无序，线程不安全，可以存储null值，底层用HashMapLinkedHashSet，元素可以按照添加的顺序遍历，是HashSet的子类，底层用LinkedHashMapTreeSet，可以对添加的对象进行排序，底层用TreeMap "},{"title":"Queue​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#queue","content":"LinkedList是Deque的实现类，可以当作栈或队列使用。 \tThrows exception\tReturns special valueInsert\tadd(e)\toffer(e) Remove\tremove()\tpoll() Examine\telement()\tpeek() 有一个子接口Deque。 这些方法可以当作栈使用。 Stack Method\tEquivalent Deque Methodpush(e)\taddFirst(e) pop()\tremoveFirst() peek()\tpeekFirst() 这些方法可以当作双向队列使用。 \tFirst Element (Head)\tFirst Element (Head)\tLast Element (Tail)\tLast Element (Tail)\tThrows exception\tSpecial value\tThrows exception\tSpecial value Insert\taddFirst(e)\tofferFirst(e)\taddLast(e)\tofferLast(e) Remove\tremoveFirst()\tpollFirst()\tremoveLast()\tpollLast() Examine\tgetFirst()\tpeekFirst()\tgetLast()\tpeekLast() "},{"title":"Map​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#map","content":"是双列数据结构的顶层接口。Map 的底层也是数组，每个位置放的都是一个Entry，其中包含了 key 和 value。 Hashtable，Java 1.0 引入，当时还没有Map接口，后来 Java 1.2 抽取 Map 接口，Hashtable是线程安全的，其中table是小写，key 不能是nullProperties，Hashtable的子类，用于读取和写入.properties文件，内容也是键值对的形式，key 和 value 都是String类型HashMap，Map的主要实现类，非线程安全，key 可以为nullLinkedHashMap，存储key的时候不仅仅存储 key 的内容，而是存储了一个双向链表的节点，可以按照元素加入的顺序来遍历TreeMap，底层用红黑树，是排序二叉树的一种 "},{"title":"泛型​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#泛型","content":"可以在编译期间进行类型检查，更安全。避免了强制类型转换，更方便。 "},{"title":"泛型类/接口​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#泛型类接口","content":"class/interface 类名&lt;T1, T2&gt; extends .... { T1 t1; T2 t2; public T1 fn(T2 t2){ } } Copy 如果在实例化时没有指定泛型，则认为此泛型类型为Object静态方法/静态成员不能用类声明的泛型 "},{"title":"泛型方法​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#泛型方法","content":"只有声明了泛型参数列表的方法才是泛型方法，泛型方法声明的泛型参数列表只能在这个方法中使用。不论其所在的类是否是泛型类。 //修饰符 泛型 返回值类型 方法名 参数列表 public &lt;T extends Object&gt; T[] toArray(T ...a); Copy "},{"title":"类型通配符​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#类型通配符","content":"&lt;?&gt;任意类型，除了null外不让存，可以取，取出来是Object类型的&lt;? extends Xxx&gt;必须是继承此类&lt;T extends Number &amp; Serializable&gt;，可以有多个限制，但是父类只能有一个，并且必须写在第一位，后面可以跟多个接口&lt;? super Xxx&gt;必须是此类的父类 "},{"title":"I/O​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#io","content":"流的分类： 操作数据单位 字节流字符流 数据的流向 输入流输出流 流的角色 节点流处理流  \tByte Based Input\tByte Based Output\tCharacter Based Input\tCharacter Based OutputBasic\tInputStream\tOutputStream\tReader InputStreamReader\tWriter OutputStreamWriter Arrays\tByteArrayInputStream\tByteArrayOutputStream\tCharArrayReader\tCharArrayWriter Files\tFileInputStream RandomAccessFile\tFileOutputStream RandomAccessFile\tFileReader\tFileWriter Pipes\tPipedInputStream\tPipedOutputStream\tPipedReader\tPipedWriter Buffering\tBufferedInputStream\tBufferedOutputStream\tBufferedReader\tBufferedWriter Filtering\tFilterInputStream\tFilterOutputStream\tFilterReader\tFilterWriter Parsing\tPushbackInputStream StreamTokenizer PushbackReader LineNumberReader Strings StringReader\tStringWriter Data\tDataInputStream\tDataOutputStream Data - Formatted PrintStream PrintWriter Objects\tObjectInputStream\tObjectOutputStream Utilities\tSequenceInputStream  表格内容来自 Java IO Tutorial (jenkov.com)。 "},{"title":"File​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#file","content":"代表一个文件或目录。 "},{"title":"RandomAccessFile​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#randomaccessfile","content":"支持随机读写的文件。对象中维护了一个指针，所有对文件的读写都相对于当前的指针。 "},{"title":"转换流​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#转换流","content":"下面的两个类可以将字节流转换为字符流。 InputStreamReaderOutputStreamWriter "},{"title":"打印流​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#打印流","content":"PrintStream，是OutputStream的子类PrintWriter，是Writer的子类 System.in、System.out和System.err都是PrintStream。 PrintWriter少了一些参数为byte[]的方法，不能直接写出字节，其它方法都差不多。 以上两者的输出方法都不会抛出 I/O 异常。 "},{"title":"数据流​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#数据流","content":"DataInputStreamDataOutputStream 将基本数据类型和String持久化和读入。 "},{"title":"对象流​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#对象流","content":"ObjectInputStreamObjectOutputStream 将基本数据类型和String持久化和读入。 对象的序列化和反序列化操作。 在序列化和反序列化的过程中会忽略掉静态成员变量和用transient修饰的成员变量。 要求被操作的类实现java.io.Serializable或java.io.Externalizable接口。 private static final long serialVersionUID用于标识当前对象的版本号，如果不显式声明的话系统会根据类的结构自动计算一个并写入到序列化的结果中。在反序列化的时候会将内存中加载的类的serialVersionUID和序列化结果中的serialVersionUID对比，如果不相同则抛出InvalidClassException异常。 如果显式声明了该字段，并且两个类结构不相同的情况下，反序列化的过程中会尽量读取变量值。如果新增了字段则该字段为默认值，如果删除了字段则忽略该字段；如果更改了字段的类型则会抛出InvalidClassException异常。 在反序列化的过程中可能会抛出ClassNotFoundException。 "},{"title":"NIO​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#nio","content":"Java 1.4 引入，更高效的流操作。 "},{"title":"NIO 2​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#nio-2","content":"Java 7 引入，对 NIO 进行了扩展。 "},{"title":"Path​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#path","content":""},{"title":"Paths​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#paths-1","content":""},{"title":"Files​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#files-1","content":""},{"title":"网络编程​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#网络编程","content":""},{"title":"InetAddress​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#inetaddress","content":""},{"title":"ServerSocket​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#serversocket","content":"TCP 服务端。 "},{"title":"Socket​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#socket","content":"TCP 客户端。 "},{"title":"DatagramSocket​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#datagramsocket","content":"UDP，不分服务端与客户端。 非面向连接，不可靠的。 "},{"title":"DatagramPacket​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#datagrampacket","content":"UDP 数据包。 "},{"title":"URL​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#url","content":""},{"title":"反射​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#反射","content":"Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 "},{"title":"获取 Class 实例的方式​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#获取-class-实例的方式","content":"Object.classnew Object().getClass()Class.forName(&quot;com.example.A&quot;)&lt;当前类&gt;.class.getClassLoader().loadClass(&quot;com.example.A&quot;) "},{"title":"Class 对象的类型​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#class-对象的类型","content":"class类interface接口[]数组，只要数据类型和维度相同就是同一种 Classenum枚举@interface注解基本数据类型void "},{"title":"动态代理​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#动态代理","content":"使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 JDK 提供的动态代理要求被代理类必须实现接口。 "},{"title":"Proxy​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#proxy","content":"java.lang.reflect.Proxy是专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException Copy 创建代理对象的过程就是创建了一个实现了接口的子类对象，并没有创建被代理的对象。 public class ProxyTest { public static void main(String[] args) { Handler handler = new Handler(); handler.setInstance(new A()); Object instance = Proxy.newProxyInstance(A.class.getClassLoader(), A.class.getInterfaces(), handler); ((Inter) instance).say(&quot;hello&quot;); } } class Handler implements InvocationHandler { private Inter instance; public void setInstance(Inter instance) { this.instance = instance; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { for (Class&lt;?&gt; anInterface : proxy.getClass().getInterfaces()) { System.out.println(anInterface); } System.out.println(method); args[0] = &quot;replace&quot;; return instance == null ? null : method.invoke(instance, args); } } Copy "},{"title":"新特性​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#新特性","content":""},{"title":"Java 7​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#java-7","content":"switch 支持 String​ try-with-resources​ NIO 2​ 泛型推断​ "},{"title":"Java 8​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#java-8","content":"函数式（Functional）接口​ 单方法接口。   Lambda 表达式​ 简化 SAM（Single Abstract Method）接口实现的语法糖。 （形参列表）-&gt;{Lambda 体} Copy 如果 Lambda 体里面只有一句话，则可以省略{}以及里面的分号；如果形参列表中形参类型是已知的，那么数据类型可以省略；如果形参列表只有一个形参，并且数据类型可以省略，则可以省略括号；如果只有一句ruturn语句，可以省略return；如果没有形参，()不能省略。 方法引用与构造器引用​ 当 Lambda 体的实现是调用一个现有的方法来实现，并且抽象方法的参数列表与该方法的参数列表对象，那么就可以使用方法引用来简化。 list.forEach(num -&gt; System.out.println(num)); list.forEach(System.out::println); Copy 如果第一个形参是调用方法的，剩下的都作为此方法的参数，也可以使用方法引用。 Arrays.sort(arr, (e1, e2) -&gt; {e1.compareToIgnoreCase(e2)}); Arrays.sort(arr, String::compareToIgnoreCase); Copy 构造器引用，当 Lambda 的方法体是通过创建对象实现的，并且形参列表一致。 Supplier&lt;String&gt; s = String::new; // String[]::new 数组构造器 Copy Stream API​ 数据加工流。 Stream 不负责存储数据，它只负责对数据进行处理Stream 不会改变源对象，每次处理都会返回一个有结果的新 StreamStream 是延迟执行的，在获取结果的时候才会执行之前的操作方法 创建​ &lt;集合对象&gt;.stream()Arrays.stream(arr)static &lt;T&gt; Stream&lt;T&gt; of(T... values)static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)产生一个无限流static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; f)无限流 中间操作​ Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)Stream&lt;T&gt; distinct()Stream&lt;T&gt; limit(long maxSize)Stream&lt;T&gt; skip(long n)static concat()合并两个流Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)对每个元素执行操作，相当于 forEach，但是不是终止操作Stream&lt;T&gt; sorted()Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)对每个元素执行操作，返回该函数返回的元素组成的流&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper) 终结操作​ void forEach(Consumer&lt;? super T&gt; action)long count()boolean allMatch(Predicate&lt;? super T&gt; predicate)boolean anyMatch(Predicate&lt;? super T&gt; predicate)boolean noneMatch(Predicate&lt;? super T&gt; predicate)Optional&lt;T&gt; findFirst()返回第一个元素Optional&lt;T&gt; findAny()返回任意一个Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)相当于 JS 中的 reduce，从左到右依次处理元素值，identity 是初始值，每次 accumulator 的返回值会累加到 identity 上，最后返回该值。&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)把流中的数据收集起来，在Collectors中有许多方法来提供Collectoer的实现类。 Optional​ 单值容器。 public static &lt;T&gt; Optional&lt;T&gt; of(T value)存值public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)可以存 null，如果是 null 则返回空 Optionalstatic &lt;T&gt; Optional&lt;T&gt; empty()直接返回一个空的容器public boolean isPresent()public T get()public void ifPresent(Consumer&lt;? super T&gt; consumer)public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)public T orElse(T other)如果不是空的返回容器中的值，如果是空的返回另一个值public T orElseGet(Supplier&lt;? extends T&gt; other)如果是空的执行方法，返回该方法的返回值public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)public &lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper) 接口中的默认方法和静态方法​ 在之前的接口笔记中有介绍。 新的日期时间 API​ 在之前的笔记中有提及。 "},{"title":"Java 9​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#java-9","content":"模块化系统​ 在src目录下用module-info.java文件来声明模块信息。 通过module、export和requires关键字来声明模块信息。 交互式编程环境 jShell​ 类似于python和node的命令行交互式编程环境。 接口私有方法​ Java 9 中接口方法可以用private修饰。 匿名实现类使用泛型​ 在 Java 8 中，匿名实现类不能声明泛型，Java 9 中可以。  局部变量类型推断​ 使用var关键字，在代码块中声明变量时可以省略掉变量的类型。 "},{"title":"Java 10​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#java-10","content":""},{"title":"Java 11​","type":1,"pageTitle":"Java","url":"docs/notes/java/java#java-11","content":""},{"title":"EditorConfig","type":0,"sectionRef":"#","url":"docs/notes/utility/editorconfig","content":"","keywords":""},{"title":"简介​","type":1,"pageTitle":"EditorConfig","url":"docs/notes/utility/editorconfig#简介","content":"EditorConfig1 配置文件被许多优秀的代码编辑器默认支持，只要.editorconfig文件存在于项目的根目录下，它就会被编辑器读取并应用。 将项目文件格式写入名为.editorconfig的配置文件，如文件编码、换行风格、缩进风格等，以便多个开发人员在项目里保持一致的编码风格。 "},{"title":"示例​","type":1,"pageTitle":"EditorConfig","url":"docs/notes/utility/editorconfig#示例","content":"# EditorConfig is awesome: https://EditorConfig.org root = true [*] end_of_line = lf charset = utf-8 insert_final_newline = true trim_trailing_whitespace = true indent_style = space indent_size = 4 [{*.ts, *.js}] indent_size = 2 Copy 用#标注注释； 配置可以分段，在[]之中声明要匹配的文件，可以用{}来声明多种匹配规则，用英文逗号,分隔这些规则； *，匹配任意字符串，除了/；**，匹配任意字符串；?，匹配单个字符；[name]，匹配name中的任意单个字符，即n、a、m和e；[!name]，匹配不出现在name中的单个字符；{s1, s2, s3}，联合多个匹配；{1..9}，匹配任意1至9之间的数字。 用key=value的形式定义属性，常用的一些属性如下。 配置项\t可选值\t备注indent_style\ttab/space\t缩进风格 indent_size\t数字\t空格缩进数量 end_of_line\tlf/cr/crlf\t换行符风格 charset\tutf-8/...\t文件编码 trim_trailing_whitespace\ttrue/false\t移除行尾空白字符 insert_final_newline\ttrue/false\t文件永远以空行结尾 root\ttrue/false\t该属性表名此配置文件是最顶层的配置文件，不会再往上层寻找配置文件了 可以在每个文件夹层级都定义配置文件，在进行格式化文件的时候，EditorConfig 会从当前目录至上级目录一直寻找.editorconfig文件，直到文件系统的根目录或者到某个包含root=true的配置文件为止。最终生效的配置文件是将所有寻找到的配置文件合并后的结果，路径短的配置内容会覆盖路径长的配置内容。 EditorConfig↩ "},{"title":"tmux","type":0,"sectionRef":"#","url":"docs/notes/utility/tmux","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#前言","content":"tmux 是一个终端复用器，能让你在一个终端里分屏出多个窗格，还能保存你的终端会话。尤其是在 SSH 连接到远程服务器工作的时候，网络情况不好的情况下 SSH 连接可能会意外断开，此时在该 SSH 会话中运行的命令也会被中断；在使用了 tmux 之后，只要 tmux 进程不结束，任务就不会中断，待恢复 SSH 连接后，tmux 可以让你快速恢复到之前的工作现场。 "},{"title":"快捷键说明​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#快捷键说明","content":"tmux 的快捷键操作都需要先按下前缀快捷键，默认的前缀快捷键是Ctrl+b，需要先按下此快捷键后松开，然后再按下后续指令。所有的快捷键操作均需要在 tmux 会话中按下才能生效。 如分离会话的快捷键是Ctrl+bd，你需要先按下Ctrl+b，松开键盘，再按下d。其它快捷键同理。 在会话中，使用Ctrl+b?快捷键来展示所有的快捷键，按q退出帮助页面。 "},{"title":"多会话​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#多会话","content":""},{"title":"启动​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#启动","content":"tmux，新建一个会话，默认名称是以数字序号，从 0 开始tmux new -s session_name，新建一个会话并命名为「session_name」 "},{"title":"退出​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#退出","content":"会话中不存在进程时会话会自动关闭，使用exit命令或者Ctrl+d关闭当前 shelltmux kill-session -t &lt;会话编号/会话名称&gt;，杀死会话 "},{"title":"分离​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#分离","content":"可以手动分离会话，在 SSH 断开的时候也会分离会话，只要会话中有进程该会话就不会自动关闭。 在会话中，使用Ctrl+bd分离当前会话 "},{"title":"返回​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#返回","content":"tmux ls，列出所有会话Ctrl+bs，列出所有会话tmux attach -t &lt;会话编号/会话名称&gt;，返回会话tmux switch -t &lt;会话编号/会话名称&gt;，切换会话 "},{"title":"重命名​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#重命名","content":"tmux rename-session -t &lt;会话编号/会话名称&gt; &lt;新的会话名称&gt;Ctrl+b$，重命名当前会话 "},{"title":"多窗格（pane）​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#多窗格pane","content":""},{"title":"划分窗格​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#划分窗格","content":"tmux split-window，向下划分窗格（垂直）Ctrl+b% ，向下划分窗格tmux split-window -h，向右划分窗格（水平）Ctrl+b&quot; ，向下划分窗格 "},{"title":"切换光标​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#切换光标","content":"tmux select-pane -U ，光标切换到上一窗格Ctrl+b↑tmux select-pane -D ，光标切换到下一窗格Ctrl+b↓tmux select-pane -L ，光标切换到左一窗格Ctrl+b←tmux select-pane -R ，光标切换到右一窗格Ctrl+b→ "},{"title":"移动窗格​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#移动窗格","content":"Ctrl+bq ，显示窗格编号tmux swap-pane -U，把当前窗格与上一个窗格交换位置Ctrl+b{ ，把当前窗格与上一个窗格交换位置tmux swap-pane -D，把当前窗格与下一个窗格交换位置Ctrl+b} ，把当前窗格与下一个窗格交换位置 "},{"title":"其它操作​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#其它操作","content":"Ctrl+bz ，当前窗格全屏显示，再按一次还原。在全屏模式下Ctrl+bx ，关闭当前窗格Ctrl+b! ，把当前窗格拆分为一个独立窗口Ctrl+b[ ，开启复制模式，可以用用方向键或滚轮上下滚动，q退出。 "},{"title":"多窗口（window）​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#多窗口window","content":"一个会话中可以存在多个窗口，每个窗口中可以有多个窗格。 tmux new-window，新建窗口tmux new-window -n &lt;窗口名称&gt;，新建窗口Ctrl+bc ，新建窗口tmux select-window -t &lt;窗口名称&gt;，切换到指定名称的窗口Ctrl+bp ，切换到上一个窗口Ctrl+bn ，缺环到下一个窗口Ctrl+bnumber ，切换到指定序号的窗口 "},{"title":"参考资料​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#参考资料","content":"Tmux 使用教程 - 阮一峰的网络日志Gentle Guide to Get Started With tmux | Pragmatic Pineapple 🍍 "}]