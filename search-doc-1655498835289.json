[{"title":"用 KMS 激活 Windows 和 Office","type":0,"sectionRef":"#","url":"blog/activate-windows-and-office-with-kms","content":"","keywords":""},{"title":"激活 Windows​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#激活-windows","content":"只能激活 VL 版本的系统，零售版不能通过这种方式激活。 使用管理员权限运行cmd。 slmgr /skms kms.03k.org slmgr /ato  "},{"title":"激活 Office​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#激活-office","content":"进入 Office 安装目录，用管理员权限执行命令。 # C:\\Program Files (x86)\\Microsoft Office\\Office16 cscript ospp.vbs /sethst:kms.03k.org cscript ospp.vbs /act  "},{"title":"KMS 服务器收集​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#kms-服务器收集","content":"在上面命令中的 KMS 服务器失效的时候可以尝试下面列表中的其它 KMS 服务器。 kms.03k.orgkms.v0v.bid "},{"title":"自建 KMS 服务器​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#自建-kms-服务器","content":"或者也可以自己搭建 KMS 服务器，难度不高，通过 Docker 可以快速部署。 teddysun/kms - Docker Image | Docker Hub "},{"title":"其它激活方式​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#其它激活方式","content":"云萌 Windows 10 激活工具 - 首页 "},{"title":"参考资料​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#参考资料","content":"本站上线 KMS 服务~一句命令激活 windows/office | 零散坑知识分享 "},{"title":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","type":0,"sectionRef":"#","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh","content":"","keywords":""},{"title":"补充​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#补充","content":"oh-my-posh 项目已被重构，现在由 Go 语言实现，详情见 Github。 文章中所使用的版本现已被重命名为 oh-my-posh2，由 PowerShell 实现，详情见 Github。 oh-my-posh3 的安装请参考 Windows Terminal + PWSH + oh my posh3 + PSReadLine 打造一个好用的终端，下面的内容已过时。 "},{"title":"前言​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#前言","content":"Windows 中自带的终端使用体验确实说不上好，尝试了许多组合也感觉都不顺手。这次试试微软亲自出的 Windows Terminal1，再加上 oh-my-posh2 插件。 "},{"title":"正文​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#正文","content":""},{"title":"安装 Windows Terminal​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#安装-windows-terminal","content":"Windows Terminal 提供多种安装方式，你可以在 Microsoft Store 中安装；可以自行在该项目的 Github 仓库 1 中上下载安装程序；虽然官方文档未提及，但是你也可以用 Scoop3 安装： scoop install windows-terminal  "},{"title":"安装 oh-my-posh​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#安装-oh-my-posh","content":"oh-my-posh 是针对 Windows PowerShell 设计的主题引擎，类似于 zsh 和 Oh My Zsh 的关系。它可以让你的命令行更强大。 打开 PowerShell，输入以下命令安装： Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser  安装完成之后还更改 PowerShell 的用户配置，让它每次启动的时候自动加载 oh-my-posh 插件；执行以下命令： if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE  不出意外的话接下来会出现记事本，你需要在里面写上以下内容： Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradox  保存该文件，重新打开 PowerShell 你就能看到一个发生改变了的 PowerShell 。  oh-my-posh 提供了几组预设的主题供你选择，你可以通过 Set-Theme 命令来更改当前主题，可选的值有 Agnoster/Paradox/Sorin/Darkblood/Avit/Honukai/Fish/Robbyrussell。  这个主题设置只在当前会话生效，为了每次启动 PowerShell 的时候都能加载你想要的主题，你还需要修改以下用户配置文件，就像上一个步骤中做的一样，只需要修改 Set-Theme 命令的部分即可。 "},{"title":"用上微软的 Cascadia Code 字体​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#用上微软的-cascadia-code-字体","content":"或许你已经发现了有些字符显示不正常，那是因为默认的字体没有内嵌这些字符的形状，你还需要换一个字体。 微软的另一个开源项目，Cascadia Code4 就是一款适用于终端和代码展示的字体，你可以使用 Scoop 来安装它；安装字体的时候需要使用到管理员权限，你可以使用 sudo 命令，或者用管理员权限重新打开 PowerShell，再执行安装。 在安装之前，你可能需要添加一下 nerd-fonts 仓库，因为字体软件的元信息都存放于这个仓库中。 scoop bucket add nerd-fonts  在 Scoop 的仓库中存在着好几个版本的 Cascadia Code，其中： Cascadia-Code是原版不带 Powerline 字符的；Cascadia-PL是微软出品的，自带 Powerline 字符的；CascadiaCode-NF是 Nerd Fonts5 项目出品的，后期补丁了大量 Powerline 字符。 没有特殊需求的话可以选择官方出的轻量级的 Cascadia-PL，执行以下命令： sudo scoop install Cascadia-PL  安装完成之后还需设置以下，指定 Windows Terminal 使用该字体。 目前 Windows Terminal 没有专门的设置界面，所有的配置项都在 profiles.json 配置文件里；在配置文件的对应地方设置 fontFace 的值为 Cascadia Code PL： // ... &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles &quot;fontFace&quot;: &quot;Cascadia Code PL&quot; }, // ...  保存配置文件后就能使配置文件生效；此时所有字符应该能正常显示了。  "},{"title":"集成 Git Bash​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#集成-git-bash","content":"首先将 Git 安装目录下的 bin 目录加入 Path 环境变量，如果你是用 Scoop 安装的 Git，则可以忽略此步骤，因为 Scoop 已经帮你完成了这个工作；然后修改 Windows Terminal 的配置文件，在 profiles-&gt;list 中新增一条配置： // ... &quot;list&quot;: [ { &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff4411}&quot;, &quot;name&quot;: &quot;Git Bash&quot;, &quot;commandline&quot;: &quot;bash.exe&quot;, &quot;hidden&quot;: false, &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot; } ] // ...  注意 JSON 的语法格式，在列表中不要少加或者多加逗号。保存配置文件之后就能在 Windows Terminal 中快捷启动 Git Bash 了。  "},{"title":"后记​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#后记","content":"新的 Windows Terminal 使用体验还是挺不错的，颜值也 OK，折腾一下也挺好用的。 microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place!↩JanDeDobbeleer/oh-my-posh2: A prompt theming engine for Powershell↩lukesampson/scoop: A command-line installer for Windows.↩microsoft/cascadia-code: This is a fun, new monospaced font that includes programming ligatures and is designed to enhance the modern look and feel of the Windows Terminal.↩ryanoasis/nerd-fonts: Iconic font aggregator, collection, &amp; patcher. 3,600+ icons, 50+ patched fonts: Hack, Source Code Pro, more. Glyph collections: Font Awesome, Material Design Icons, Octicons, &amp; more↩ "},{"title":"CentOS 网络配置","type":0,"sectionRef":"#","url":"blog/configuring-centos-network","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#前言","content":"每次装 CentOS 后无法上网都要去搜教程，现在记下来以后就不用到处去搜了（滑稽）。 "},{"title":"启用网卡​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#启用网卡","content":"ifconfig eth0 up  顺便一提，关闭网卡的命令是ifconfig eth0 down。 "},{"title":"编辑网络配置文件​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#编辑网络配置文件","content":"vi /etc/sysconfig/network-scripts/ifcfg-eth0  按i进入编辑模式，按ESC进入命令模式。命令模式中输入:w保存，:q退出，:wq即为退出并保存。 打开应该是下面这个样子。 DEVICE=eth0 HWADDR=08:00:27:A6:5D:89 TYPE=Ethernet UUID=db391271-1cdf-4df2-b040-12f259d5e361 ONBOOT=no NM_CONTROLLED=yes BOOTPROTO=dhcp  ONBOOT为是否开机启动，值可为 yse/no；BOOTPROTO为获取 IP 地址的方式，值可为 dhcp/static/bootp； ONBOOT修改为yes，BOOTPROTO按需修改，其他的不需要修改，下面是示例。 "},{"title":"两种获取 IP 的方式​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#两种获取-ip-的方式","content":""},{"title":"动态获取 IP（dhcp）​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#动态获取-ipdhcp","content":"DEVICE=eth0 HWADDR=08:00:27:A6:5D:89 TYPE=Ethernet UUID=db391271-1cdf-4df2-b040-12f259d5e361 ONBOOT=yes #开机启动 NM_CONTROLLED=yes BOOTPROTO=dhcp #动态  "},{"title":"静态获取 IP（static）​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#静态获取-ipstatic","content":"DEVICE=eth0 HWADDR=08:00:27:A6:5D:89 TYPE=Ethernet UUID=db391271-1cdf-4df2-b040-12f259d5e361 ONBOOT=yes #开机启动 NM_CONTROLLED=yes BOOTPROTO=static #静态 IPADDR=192.168.233.234 #IP 地址 NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.233.1 #网关  static 方式还要手动设置 DNS。 vi /etc/resolv.conf  "},{"title":"重启网络服务​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#重启网络服务","content":"service network restart  "},{"title":"使用 Vant Weapp 自定义微信小程序 TabBar","type":0,"sectionRef":"#","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#前言","content":"微信小程序原生的 TabBar 虽然设置简单，但是样式不好看，也不能使用字体图标，但是微信小程序有自定义 TabBar 的机制。 Vant WeApp1 是有赞出品的针对微信小程序的一套开源组件库，结合 van-tabbar2 和微信的自定义 TabBar 机制 3 可以实现一套比较好看的 TabBar。 "},{"title":"新建 custom-tab-bar 组件​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#新建-custom-tab-bar-组件","content":"如图所示，在微信小程序工程文件夹根目录下新建一个名为 custom-tab-bar 的组件。  其中各个文件中的代码如下： { &quot;component&quot;: true, &quot;usingComponents&quot;: { &quot;van-tabbar&quot;: &quot;@vant/weapp/tabbar/index&quot;, &quot;van-tabbar-item&quot;: &quot;@vant/weapp/tabbar-item/index&quot; } }  // custom-tab-bar/index.js Component({ /** * 组件的属性列表 */ properties: {}, /** * 组件的初始数据 */ data: { active: -1, list: [{ icon: &quot;search&quot;, text: &quot;搜索&quot;, url: &quot;/pages/index/index&quot;, }, { icon: &quot;question-o&quot;, text: &quot;答题&quot;, url: &quot;/pages/question/index&quot;, }, { icon: &quot;ellipsis&quot;, text: &quot;关于&quot;, url: &quot;/pages/user/index&quot;, }, ], }, /** * 组件的方法列表 */ methods: { onChange(event) { wx.switchTab({ url: this.data.list[event.detail].url, }); }, init() { const { route } = getCurrentPages().pop(); const active = this.data.list.findIndex( (item) =&gt; item.url === `/${route}` ); console.log(&quot;active:&quot;, active); this.setData({ active, }); }, }, });  &lt;!-- custom-tab-bar/index.wxml --&gt; &lt;van-tabbar active=&quot;{{ active }}&quot; bind:change=&quot;onChange&quot;&gt; &lt;van-tabbar-item wx:for=&quot;{{list}}&quot; wx:key=&quot;index&quot; icon=&quot;{{item.icon}}&quot;&gt; {{item.text}} &lt;/van-tabbar-item&gt; &lt;/van-tabbar&gt;  "},{"title":"启用自定义 TabBar 设置​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#启用自定义-tabbar-设置","content":"修改 app.js 中 tabBar 设置，设置 custom 为 true。其中 list 中的对象只需保留 path 属性。  "},{"title":"在每个 Tab 页中配置​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#在每个-tab-页中配置","content":"在开启了自定义 TabBar 设置后，可以在每个页面中通过 getTabBar() 获取 TabBar 组件实例。 现在需要在每个 Tab 页中设置当前 Tab 页图标高亮。 可以在每个 Tab 页的 onShow() 生命周期方法中调用 TabBar 的 init() 方法，修改当前激活页，来高亮当前 Tab 页的图标。 /** * 生命周期函数 -- 监听页面显示 */ onShow: function () { this.getTabBar().init(); },  Vant - 轻量、可靠的移动端组件库 (gitee.io)↩Tabbar 标签栏 - Vant Weapp↩自定义 tabBar | 微信开放文档↩ "},{"title":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","type":0,"sectionRef":"#","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#前言","content":"Vuepress1 是一个基于 Vue 的静态网站生成器；Github Pages2 是 Github 提供的免费的静态网站托管服务；Github Actions3 是 Github 仓库中集成的 CI/CD4 服务。 Vuepress 是一个 Node.js 项目，它可以根据配置将 Markdown 文件转为 HTML 文件。你可以将输出的静态文件托管在 Github Pages 中，这样你就得到了一个可以访问的域名来展示这些静态的 HTML 文件。 传统的做法是在本地安装好 Noed.js 环境，自己手动构建项目之后将构建产物上传到 Github 仓库，从而触发 Github Pages 的构建。现在可以利用 Github Actions 来代替手工劳动，Github Actions 可以自动被触发，它运行在 Github 提供的虚拟环境中，可以执行一系列任务从而代替重复枯燥的手动构建和部署的步骤。 "},{"title":"创建 Github 仓库​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#创建-github-仓库","content":"在创建的 Github 仓库时要注意仓库名称，假如你的用户名是 foo。 如果你创建了一个名为foo.github.io的仓库，你将可以通过https://foo.github.io来访问此仓库的 Github Pages 内容； 如果你创建其他名称的仓库如bar，你可以通过https://foo.github.io/bar/来访问此仓库的 Github Pages 内容。 你可以根据你期望的访问方式来选择仓库名称。 "},{"title":"配置 Github Actions​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#配置-github-actions","content":"Github Actions 的配置文件应该放在项目根目录下的.github/workflows/文件夹中，你可以在一个项目中配置多个 Actions。配置文件是 YAML 格式，文件名形如*.yml。 每一个 Action 中可以包括多个 job，每个 job 可以包括多个 step。在 step 中你可以直接运行命令，或者引用其他人编写好的 Action 脚本。在本文的配置文件中，我们引用了 github-pages-deploy-action5 来完成 Github Pages 部署，而不用关系其实现细节。 完成本文目标的 Github Actions 配置文件内容如下。 name: &quot;github actions build and deploy gh-pages&quot; on: push: branches: - master jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2.3.1 with: persist-credentials: false - name: install and build run: | npm install npm run build - name: Deploy uses: JamesIves/github-pages-deploy-action@4.1.4 with: BRANCH: gh-pages FOLDER: docs/.vuepress/dist  其中的一些关键配置解释如下。 on.push.branches，在推送到master分支时触发此 Action；jobs.build-and-deploy，在一个 Action 中可以有多个 job，这是其中的一个，名称是自己取的；每个任务可以有多个 step；jobs.build-and-deploy.steps[0]，用actions/checkout检出仓库内容；jobs.build-and-deploy.steps[1]，执行npm命令安装开发环境；jobs.build-and-deploy.steps[2]，用JamesIves/github-pages-deploy-action部署docs/.vuepress/dist文件夹中的内容到gh-pages分支中。 在编写好配置文件后可以提交并推送文件至 master 分支，这会自动触发 Action 的执行，并且你可以在 Actions 栏目中查看执行日志。  "},{"title":"配置 Github Pages​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#配置-github-pages","content":"我们的构建产物放在 gh-pages 分支，我们需要告诉 Github Pages 源文件位置。 在 Github 仓库的 Settings 栏目中，从左侧的设置导航栏找到 Pages 设置。在这里你可以设置 gh-pages 为数据源。  如果没出错的话，在配置完成之后你就可以通过 Github Pages 给你提供的域名来访问你的静态网站了。 首页 | VuePress↩GitHub Pages | Websites for you and your projects, hosted directly from your GitHub repository. Just edit, push, and your changes are live.↩Learn GitHub Actions - GitHub Docs↩什么是 CI/CD？一文带你理解 CI 持续集成和 CD 持续交付/部署 - 红帽↩JamesIves/github-pages-deploy-action: Automatically deploy your project to GitHub Pages using GitHub Actions. This action can be configured to push your production-ready code into any branch you'd like.↩ "},{"title":"Debian 配置备份","type":0,"sectionRef":"#","url":"blog/debian-environment-backup","content":"","keywords":""},{"title":"软件源​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#软件源","content":"debian | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror apt edit-sources  # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free  apt update  "},{"title":"小工具​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#小工具","content":"apt install curl wget tmux bat htop btop exa neofetch trash-cli  "},{"title":"alias​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#alias","content":"alias bat='batcat' alias ll='exa -lha --modified --created --time-style long-iso --group-directories-first' alias dc='docker-compose'  "},{"title":"docker​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#docker","content":"wget https://get.docker.com/ -O get-docker.sh # sh get-docker.sh --mirror Aliyun sh get-docker.sh systemctl enable docker  "},{"title":"docker-compose​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#docker-compose","content":"Releases · docker/compose # wget https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-linux-x86_64 -O /opt/docker-compose wget https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-linux-x86_64 -O /opt/docker-compose chmod u+x /opt/docker-compose ln -s /opt/docker-compose /usr/local/sbin/docker-compose  "},{"title":"lazydocker​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#lazydocker","content":"Releases · jesseduffield/lazydocker # wget https://ghproxy.com/https://github.com/jesseduffield/lazydocker/releases/download/v0.12/lazydocker_0.12_Linux_x86_64.tar.gz wget https://github.com/jesseduffield/lazydocker/releases/download/v0.12/lazydocker_0.12_Linux_x86_64.tar.gz mkdir ~/lazydocker tar -zxvf lazydocker_0.12_Linux_x86_64.tar.gz -C ~/lazydocker mv ~/lazydocker/lazydocker /opt/lazydocker chmod u+x /opt/lazydocker ln -s /opt/lazydocker /usr/local/sbin/lazydocker trash-put ~/lazydocker # rm -rf ~/lazydocker  brew install lazydocker  # ~/.config/jesseduffield/lazydocker/config.yml reporting: &quot;off&quot; gui: returnImmediately: true commandTemplates: serviceLogs: '{{ .DockerCompose }} logs --timestamps --follow --tail 500 {{ .Service.Name }}' viewServiceLogs: '{{ .DockerCompose }} logs --tail 500 --follow {{ .Service.Name }}' containerLogs: docker logs --timestamps --follow --tail 500 {{ .Container.ID }} viewContainerLogs: docker logs --timestamps --follow --tail 500 {{ .Container.ID}}  "},{"title":"croc​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#croc","content":"Releases · schollz/croc # wget https://ghproxy.com/https://github.com/schollz/croc/releases/download/v9.5.0/croc_9.5.0_Linux-64bit.deb wget https://github.com/schollz/croc/releases/download/v9.5.0/croc_9.5.0_Linux-64bit.deb dpkg -i croc_9.5.0_Linux-64bit.deb  brew install croc  "},{"title":"bat​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#bat","content":"Releases · sharkdp/bat # wget https://ghproxy.com/https://github.com/sharkdp/bat/releases/download/v0.18.3/bat_0.18.3_amd64.deb wget https://github.com/sharkdp/bat/releases/download/v0.18.3/bat_0.18.3_amd64.deb dpkg -i bat_0.18.3_amd64.deb  apt install bat # alias bat='batcat'  brew install bat  "},{"title":"glance​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#glance","content":"pip3 install glance  "},{"title":"Docker 穿透防火墙的问题","type":0,"sectionRef":"#","url":"blog/docker-and-system-firewall","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Docker 穿透防火墙的问题","url":"blog/docker-and-system-firewall#前言","content":"有些服务只需要在本地访问，不需要向外暴露端口，不然会有安全隐患，总有一大堆机器扫描你的端口，尝试接入你的服务。 通过 Docker 暴露的端口，即使没有在防火墙中手动放行，在外部还是可以访问到。 "},{"title":"解决办法​","type":1,"pageTitle":"Docker 穿透防火墙的问题","url":"blog/docker-and-system-firewall#解决办法","content":"在进行端口映射的时候指定监听地址为127.0.0.1，如127.0.0.1:3000:80。在没指定的情况下，如3000:80，监听地址为0.0.0.0。 这在使用docker run命令和docker-compose命令的时候都可以生效。 docker run命令示例如下。 docker run -p 127.0.0.1:80:80 nginx  使用docker-compose命令时，docker-compose.yml内容示例如下。 version: '3.3' services: nginx: ports: - '127.0.0.1:80:80' image: nginx  "},{"title":"参考资料​","type":1,"pageTitle":"Docker 穿透防火墙的问题","url":"blog/docker-and-system-firewall#参考资料","content":"无视系统防火墙的 docker - 博客 - binsitedocker 无视防火墙问题总结 - Icharle | Don't forget your first thoughtsdocker 开放的端口是如何实现绕过防火墙的？ - 知乎Docker 与 IPtables - 简书 "},{"title":"以容器的方式暴露 Docker Remote API 并启用 TLS","type":0,"sectionRef":"#","url":"blog/enable-docker-remote-api-with-tls-protection-via-container","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"以容器的方式暴露 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection-via-container#前言","content":"之前在「开启 Docker Remote API 并启用 TLS」1 中记录过 Docker 暴露 Remote API 并配置 TLS 支持，虽然其中引用了别人的脚本来简化证书的签发步骤，但是在证书签发完成之后还是需要对 Docker 的启动命令进行修改，还是一个比较繁琐的步骤。 后来我发现了 docker-remote-api-tls2 项目，它提供了一个 Docker 镜像，在运行镜像之后它会自动完成证书签发和 API 转发步骤。 "},{"title":"部署​","type":1,"pageTitle":"以容器的方式暴露 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection-via-container#部署","content":"可以通过 Docker Compose 方便地启动这个容器，下面是docker-compose.yml文件的内容。 version: &quot;3&quot; services: api: image: kekru/docker-remote-api-tls:v0.3.0 ports: - 2376:443 environment: - CREATE_CERTS_WITH_PW=dockercompose - CERT_EXPIRATION_DAYS=3650 - CA_EXPIRATION_DAYS=36500 - CERT_HOSTNAME=192.168.229.129.nip.io volumes: - /root/compose/docker-remote-api-with-tls/certs:/data/certs - /var/run/docker.sock:/var/run/docker.sock:ro restart: unless-stopped  有以下几点需要注意： 第 6 行，容器内的端口是 443，需要映射到容器外 2376 端口；第 8 行，CREATE_CERTS_WITH_PW设置证书密码；第 9 行，CERT_EXPIRATION_DAYS设置证书过期时间，默认 365 天；第 10 行，CA_EXPIRATION_DAYS设置 CA 证书过期时间，默认 900 天；第 11 行，CERT_HOSTNAME设置域名，如果没有域名可以用 nip.io3 来得到一个可以解析到任意 IP 的域名。形如192.168.229.129.nip.io的域名会被解析至192.168.229.129；还有其他形式的域名可以在 nip.io 网站中查看；第 13 行，挂载证书目录，首次启动时证书会被自动创建并存放在此目录中；第 14 行，挂载docker.sock。 通过docker compose up -d启动容器。根据配置，证书会被自动创建在/root/compose/docker-remote-api-with-tls/certs目录中。 该目录的结构如下： certs/ ├── ca-cert.pem ├── ca-key.pem ├── client │ ├── ca.pem │ ├── cert.pem │ └── key.pem ├── server-cert.pem └── server-key.pem  其中，客户端需要的证书文件存放在client目录中。此时 Docker Remote API 已经暴露在 2376 端口，客户端可以使用证书文件来通过认证。 如果需要重新签发证书文件，只需要清空certs文件夹并重启容器即可。 "},{"title":"补充​","type":1,"pageTitle":"以容器的方式暴露 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection-via-container#补充","content":"国内的 IP 请使用已备案域名，不然可能会被阻断，导致连接不上。 开启 Docker Remote API 并启用 TLS↩kekru/docker-remote-api-tls: Docker Image that forwards to the Docker API Socket and requires TLS Client authentication↩nip.io - wildcard DNS for any IP Address↩ "},{"title":"获取天翼光猫 F412 超级管理员帐号密码","type":0,"sectionRef":"#","url":"blog/get-super-admin-password-of-f412","content":"","keywords":""},{"title":"开启 telnet 服务​","type":1,"pageTitle":"获取天翼光猫 F412 超级管理员帐号密码","url":"blog/get-super-admin-password-of-f412#开启-telnet-服务","content":"控制面板 -&gt; 所有控制面板项 -&gt; 程序和功能 -&gt; 启用或关闭 Windows 功能。 "},{"title":"获取帐号密码​","type":1,"pageTitle":"获取天翼光猫 F412 超级管理员帐号密码","url":"blog/get-super-admin-password-of-f412#获取帐号密码","content":"打开 cmd，输入命令：telnet 192.168.1.1登录帐号：root登录密码：Zte521输入命令：sendcmd 1 DB p UserInfo "},{"title":"开启 Docker Remote API 并启用 TLS","type":0,"sectionRef":"#","url":"blog/enable-docker-remote-api-with-tls-protection","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#前言","content":"Portainer1 是一款 Docker 可视化管理面板，它不仅可以管理本地的 Docker 实例，还可以通过 Docker Remote API 访问管理远程 Docker 资源。Docker Remote API 就是通过 HTTP 协议暴露 Docker 资源，启用 TLS 可以实现远程访问鉴权。 Docker 的官方文档提供了详细的开启 Docker Remote API 和开启 TLS 的教程 2。但是在签发证书的过程中涉及到的命令比较多，且繁琐，我就从网络上寻找到了别人写好的签发证书的脚本 3，可以很方便地替代纯手工操作。 本文中的操作都在 CentOS 7 中完成。 "},{"title":"签发证书​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#签发证书","content":"将脚本命名为auto-tls-certs.sh。其中需要配置的内容有： CODE，作为文件名的后缀，用于区分文件；IP，机器的公网 IP 地址；PASSWORD，证书密码。 脚本内容如下： #!/bin/bash # # ------------------------------------------------------------- # 自动创建 Docker TLS 证书 # ------------------------------------------------------------- # 以下是配置信息 # --[BEGIN]------------------------------ CODE=&quot;tx&quot; IP=&quot;1.1.1.1&quot; PASSWORD=&quot;pass&quot; COUNTRY=&quot;CN&quot; STATE=&quot;BEIJING&quot; CITY=&quot;BEIJING&quot; ORGANIZATION=&quot;Org&quot; ORGANIZATIONAL_UNIT=&quot;Dev&quot; COMMON_NAME=&quot;$IP&quot; EMAIL=&quot;.&quot; # --[END]-- # Generate CA key openssl genrsa -aes256 -passout &quot;pass:$PASSWORD&quot; -out &quot;ca-key-$CODE.pem&quot; 4096 # Generate CA openssl req -new -x509 -days 365 -key &quot;ca-key-$CODE.pem&quot; -sha256 -out &quot;ca-$CODE.pem&quot; -passin &quot;pass:$PASSWORD&quot; -subj &quot;/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$COMMON_NAME/emailAddress=$EMAIL&quot; # Generate Server key openssl genrsa -out &quot;server-key-$CODE.pem&quot; 4096 # Generate Server Certs. openssl req -subj &quot;/CN=$COMMON_NAME&quot; -sha256 -new -key &quot;server-key-$CODE.pem&quot; -out server.csr echo &quot;subjectAltName = IP:$IP,IP:127.0.0.1&quot; &gt;&gt; extfile.cnf echo &quot;extendedKeyUsage = serverAuth&quot; &gt;&gt; extfile.cnf openssl x509 -req -days 365 -sha256 -in server.csr -passin &quot;pass:$PASSWORD&quot; -CA &quot;ca-$CODE.pem&quot; -CAkey &quot;ca-key-$CODE.pem&quot; -CAcreateserial -out &quot;server-cert-$CODE.pem&quot; -extfile extfile.cnf # Generate Client Certs. rm -f extfile.cnf openssl genrsa -out &quot;key-$CODE.pem&quot; 4096 openssl req -subj '/CN=client' -new -key &quot;key-$CODE.pem&quot; -out client.csr echo extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf openssl x509 -req -days 365 -sha256 -in client.csr -passin &quot;pass:$PASSWORD&quot; -CA &quot;ca-$CODE.pem&quot; -CAkey &quot;ca-key-$CODE.pem&quot; -CAcreateserial -out &quot;cert-$CODE.pem&quot; -extfile extfile.cnf rm -vf client.csr server.csr chmod -v 0400 &quot;ca-key-$CODE.pem&quot; &quot;key-$CODE.pem&quot; &quot;server-key-$CODE.pem&quot; chmod -v 0444 &quot;ca-$CODE.pem&quot; &quot;server-cert-$CODE.pem&quot; &quot;cert-$CODE.pem&quot; # 打包客户端证书 mkdir -p &quot;tls-client-certs-$CODE&quot; cp -f &quot;ca-$CODE.pem&quot; &quot;cert-$CODE.pem&quot; &quot;key-$CODE.pem&quot; &quot;tls-client-certs-$CODE/&quot; cd &quot;tls-client-certs-$CODE&quot; tar zcf &quot;tls-client-certs-$CODE.tar.gz&quot; * mv &quot;tls-client-certs-$CODE.tar.gz&quot; ../ cd .. rm -rf &quot;tls-client-certs-$CODE&quot; # 拷贝服务端证书 mkdir -p /etc/docker/certs.d cp &quot;ca-$CODE.pem&quot; &quot;server-cert-$CODE.pem&quot; &quot;server-key-$CODE.pem&quot; /etc/docker/certs.d/  使用sh auto-tls-certs.sh命令来生成证书，并且生成好的证书会被自动打包为.tar.gz归档，非常方便。下面的图片展示了执行脚本后生成的文件列表。  "},{"title":"配置 Docker​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#配置-docker","content":"只需关注.pem文件，把证书找个专门的位置存放。 mkdir /etc/.docker cp ~/docker-cert/*.pem /etc/.docker/  修改 Docker 启动文件。 nano /lib/systemd/system/docker.service  修改Service下的ExecStart配置。 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -D -H tcp://0.0.0.0:2376 --tlsverify --tlscacert=/etc/.docker/ca-tx.pem --tlscert=/etc/.docker/server-cert-tx.pem --tlskey=/etc/.docker/server-key-tx.pem   重启 Docker。 systemctl daemon-reloadservice docker restart  "},{"title":"开放端口​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#开放端口","content":"在防火墙、安全组中放行 2376 端口。 "},{"title":"测试​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#测试","content":"把证书的压缩包tls-client-certs-tx.tar.gz下载到本机，解压得到证书文件。  用curl命令测试，如果有 JSON 格式的信息输出则配置成功。 curl https://你的 IP/info --cert cert-tx.pem --key key-tx.pem --cacert ca-tx.pem   "},{"title":"用 Portainer 连接​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#用-portainer-连接","content":"Portainer 是一款非常好用的 Docker 可视化管理工具，通过暴露 Docker Remote API 可以远程连接并管理 Docker 资源。 在Endpoints页面中点击Add endpoint，Environment type选择Docker。 在对应的输入框中填写 IP 地址和端口号，开启 TLS，选择三个对应的证书文件。  Documentation↩Protect the Docker daemon socket | Docker Documentation↩Docker 开启 TLS 访问，更加安全 - 实用教程 - 高亚轩的 BLOG↩ "},{"title":"Linuxbrew：Linux 上的 Homebrew","type":0,"sectionRef":"#","url":"blog/linuxbrew-the-homebrew-on-linux","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Linuxbrew：Linux 上的 Homebrew","url":"blog/linuxbrew-the-homebrew-on-linux#前言","content":"Homebrew1 是一款用 Ruby 编写的、针对 macOS 系统的包管理器。后来又更新了对 Linux 的支持，现在你可以在你的 Linux 系统中引入一个新的包管理器 Linuxbrew。 Linuxbrew 可以是对系统中默认包管理器的补充。有些需要的软件包并不收录在官方的软件仓库中，这种情况下就需要你自己下载或编译二进制文件，自己安装。Linuxbrew/Homebrew 的软件包收录范围广、更新频率高，可以简化你安装软件包的过程。 "},{"title":"安装依赖​","type":1,"pageTitle":"Linuxbrew：Linux 上的 Homebrew","url":"blog/linuxbrew-the-homebrew-on-linux#安装依赖","content":"Linuxbrew 的安装和使用的过程依赖 Git。Linuxbrew 在安装软件包时可能会从源码在本机上编译二进制文件，所以需要用到 GCC 和 glibc。 如果你的操作系统是Debian或其派生的发行版，可以用apt来安装这些软件包。 apt install build-essential procps curl file git  如果你使用的操作系统是 Red Hat 系的，你可以使用yum来安装这些软件包。 sudo yum groupinstall 'Development Tools' sudo yum install procps-ng curl file git sudo yum install libxcrypt-compat # needed by Fedora 30 and up  这些安装命令参考自 Homebrew 文档中的 Homebrew on Linux 部分 2。 "},{"title":"安装 Linuxbrew​","type":1,"pageTitle":"Linuxbrew：Linux 上的 Homebrew","url":"blog/linuxbrew-the-homebrew-on-linux#安装-linuxbrew","content":"Linuxbrew 本身和其安装的软件包都存放在用户目录下，所以安装和使用 Linuxbrew 不要求 root 权限。实际上出于安全考虑，Linuxbrew 禁止你用 root 权限运行它，因为软件包的安装脚本在 root 权限下可能会破坏你的系统（不管是有意还是无意的）。 Linuxbrew 推荐你将它安装在 linuxbrew 的用户目录下，该目录位于/home/linuxbrew/.linuxbrew，Linuxbrew 本身和它所安装的软件包都会存放于此目录中。 首先创建一个名为 linuxbrew 的用户，并配置其用户目录。 useradd -s /bin/bash linuxbrew mkdir /home/linuxbrew chown linuxbrew /home/linuxbrew  切换到 linuxbrew 用户，执行安装脚本。 su - linuxbrew -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;  配置环境变量。将 Linuxbrew 的可执行文件目录加入PATH，并配置一些和 Linuxbrew 相关的环境变量。修改/etc/profile需要 root 权限，你需要退出到 root 用户。 echo $(/home/linuxbrew/.linuxbrew/bin/brew shellenv) &gt;&gt; /etc/profile source /etc/profile  测试。运行下面的命令来测试 Linuxbrew 是否能正常工作，如果得到「Your system is ready to brew.」的提示则证明你的安装过程如期完成。如果你的 Linuxbrew 不能正常运行，它应该会给你提示。brew 要求用非 root 权限运行，所以你需要在使用 brew 命令的时候先切换到 linuxbrew 用户。其安装的软件包可以在 root 用户下运行。 su - linuxbrew -c brew doctor  "},{"title":"安装软件包​","type":1,"pageTitle":"Linuxbrew：Linux 上的 Homebrew","url":"blog/linuxbrew-the-homebrew-on-linux#安装软件包","content":"在使用brew命令之前你需要先切换到 Linuxbrew 用户，但是通过 Linuxbrew 安装的软件包是可以供所有用户使用的。 下面的命令用于安装一个名为 hello 的软件包，其提供了一个名为hello的可执行文件，用于在控制台输出「Hello, world!」。 su - linuxbrew -c brew install hello  你可以使用brew search命令来搜索软件包；或者在网页 Homebrew Formulae3 中搜索软件包，但是并不是所有软件包都适用于 Linux。 "},{"title":"进阶使用​","type":1,"pageTitle":"Linuxbrew：Linux 上的 Homebrew","url":"blog/linuxbrew-the-homebrew-on-linux#进阶使用","content":"Linuxbrew 其实就是 Homebrew，如果你使用过 Homebrew，那么你可以直接使用 Linuxbrew，就像在 macOS 上一样。 如果你没有用过 Homebrew，你可以参考一下brew help命令和brew commands命令的帮助以及 Homebrew 的官方文档 4。 The Missing Package Manager for macOS (or Linux) — Homebrew↩Homebrew on Linux — Homebrew Documentation↩homebrew-core — Homebrew Formulae↩Documentation — Homebrew Documentation↩ "},{"title":"为《求生之路 2》制作动态喷漆","type":0,"sectionRef":"#","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#前言","content":" 动态的喷漆也是这个游戏的乐趣之一，尝试自己制作一下动态喷漆，将 GIF 图片转换为可以在游戏中使用的动态喷涂文件。 文中使用的工具和成品可以从 这里 下载。 "},{"title":"准备工作​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#准备工作","content":"一张 GIF 图片；GIF 图片分解工具，用于把动态图的每一帧分解出来，文中使用的是 GifSplitter1；VTFEdit2，核心工具，用于制作 VTF 格式的动态图。 "},{"title":"分解 GIF​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#分解-gif","content":"这里使用的是 GifSplitter，目的是将 GIF 图片的每一帧都分解出来；其他功能类似的软件和在线工具都可以。  "},{"title":"制作 VTF​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#制作-vtf","content":"打开 VTFEdit，点击左上角的「导入」按钮，选择并导入上一步中分离出来的所有图片。  接下来设置贴图尺寸，选中「限定贴图尺寸」，高度和宽度都设置为 128，其他设置保持默认。  再切换到「信息」页中，查看文件大小；要确保其小于 512KB，否则无法喷出。如果文件太大的话，就把要导入的图片删除一些，再重复这些步骤，直至满足条件。 再满足条件之后就可以保存了，保存的时候注意不要使用中文文件名，不然在游戏里浏览文件的时候中文名会乱码。  "},{"title":"在游戏中导入​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#在游戏中导入","content":"打开游戏，在游戏设置中依次找到「导入喷漆图案」，选择上一步中制作好的 VTF 文件。  "},{"title":"后记​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#后记","content":"整个制作过程也不复杂，核心工具是 VTFEdit；至于分解 GIF 的工具就很多了，可以很灵活地选择其他软件来完成这个任务。 最重要的是控制文件大小，不能超过限制，不然在游戏中无法使用。如果文件大小太大的话可以考虑在分解出的图片中删除一些图片，来达到减小文件大小的目的。比如可以隔帧删除，每隔一张图片就删除一张图片，应该会很有效。 GifSplitter - Break GIF animation down into individual image frames↩VTFEdit - Valve Developer Community↩ "},{"title":"挂载腾讯云 COS 到本地文件夹","type":0,"sectionRef":"#","url":"blog/mount-tencent-cos-on-local-file-system","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#前言","content":"2022-06-18 更新：本文中的解决办法有更好的方案，请查看 使用 s3fs 挂载腾讯云 COS 中的内容。 腾讯云提供了一个软件 cosfs 用于挂载 COS 到本地，可以使用标准的文件操作命令来操作 COS 中的内容。由于后端是云存储而不是真正的本地存储，所以有些操作的性能比较低。不推荐通过此种方式在其中修改文件内容或文件名称，仅仅下载文件和上传新文件的操作还是可以的。 腾讯云内网访问 COS 的下载流量不计费，可以通过腾讯云服务器把 COS 内容挂载到服务器，然后通过别的途径在外网下载，例如用 Rclone 通过 SFTP 把 COS 的内容复制到外网的机器，这样就不计下载流量的费用了，但是 API 调用次数还是要收费的。 文中所涉及的操作系统是 Debian，应该也适用于其他 Debian 系的操作系统。 "},{"title":"安装软件​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#安装软件","content":"cosfs1 依赖于 fuse，首先安装 fuse。 apt install fuse  安装 cosfs，官方提供了deb和rpm格式的安装包，Debian 系统用deb格式的，下载安装包之前可以先去 发布页面 2 检查一下是否有新版本。 # wget https://ghproxy.com/https://github.com/tencentyun/cosfs/releases/download/v1.0.19/cosfs_1.0.19-ubuntu20.04_amd64.deb wget https://github.com/tencentyun/cosfs/releases/download/v1.0.19/cosfs_1.0.19-ubuntu20.04_amd64.deb dpkg -i cosfs_1.0.19-ubuntu20.04_amd64.deb  "},{"title":"编写配置文件​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#编写配置文件","content":"配置文件应该存放在/etc/passwd-cosfs中。其中可以有多行，每行的格式如下。 &lt;BucketName-APPID&gt;:&lt;SecretId&gt;:&lt;SecretKey&gt;  例如你可以这样写。 examplebucket-1250000000:AKIDHTVVaVR6e3****:PdkhT9e2rZCfy6****  同时需要更改该文件的权限。 chmod 640 /etc/passwd-cosfs  "},{"title":"挂载​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#挂载","content":"先创建一个挂载点。 mkdir /mnt/cos  挂载，其中ourl指定了地域链接。 cosfs examplebucket-1250000000 /mnt/ -ourl=http://cos.ap-guangzhou.myqcloud.com  挂载之后就可以像对待普通文件系统的方式来操作 COS 中的文件了。 "},{"title":"取消挂载​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#取消挂载","content":"umount /mnt/cos  "},{"title":"局限性​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#局限性","content":"该方法有一定 局限性 3，只在特定情况下好用，使用时要考虑性能问题。 随机或者追加写文件会导致整个文件的重写；元数据操作，例如 list directory，性能较差，因为需要远程访问 COS 服务器；文件/文件夹的 rename 操作不是原子的；多个客户端挂载同一个 COS bucket 时，依赖用户自行协调各个客户端的行为。例如避免多个客户端写同一个文件等等；不支持 hard link；不适合用在高并发读/写的场景，这样会让系统的 load 升高。 对象存储 COSFS 工具 - 工具指南 - 文档中心 - 腾讯云↩Releases · tencentyun/cosfs↩tencentyun/cosfs↩ "},{"title":"使用 s3fs 挂载腾讯云 COS 中的内容","type":0,"sectionRef":"#","url":"blog/mount-tencent-cos-using-s3fs","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"使用 s3fs 挂载腾讯云 COS 中的内容","url":"blog/mount-tencent-cos-using-s3fs#前言","content":"之前写过一篇文章关于挂载腾讯云 COS 内容到本地，其中使用到了一款名为 cosfs 的软件，后来我发现该软件是 s3fs 的一个分支。并且腾讯云 COS 兼容 S3 的 API，所以索性直接用 s3fs 算了。 之前那篇文章中也缺失了开机自动挂载的部分，我最近发现了一个内含 s3fs 的 Docker 镜像，可以通过 Docker 容器自动启动来实现开机自动挂载。 "},{"title":"项目介绍​","type":1,"pageTitle":"使用 s3fs 挂载腾讯云 COS 中的内容","url":"blog/mount-tencent-cos-using-s3fs#项目介绍","content":"docker-s3fs-client1 提供了内嵌 s3fs 的 Docker 镜像，该镜像可以把远程的 Amazon S3 仓库的内容挂载到容器中。 腾讯云 COS 兼容 Amazon S3 的 API，所以可以使用 s3fs 挂载腾讯云 COS 中的内容。 "},{"title":"使用示例​","type":1,"pageTitle":"使用 s3fs 挂载腾讯云 COS 中的内容","url":"blog/mount-tencent-cos-using-s3fs#使用示例","content":"接下来使用 Docker Compose 来配置并部署 docker-s3fs-client 容器。 s3fs/docker-compose.yml version: '3.8' services: s3fs: image: efrecon/s3fs restart: unless-stopped cap_add: - SYS_ADMIN security_opt: - 'apparmor:unconfined' devices: - /dev/fuse volumes: - /mnt/s3fs:/opt/s3fs/bucket:rshared environment: AWS_S3_BUCKET: xxxx-xxxxxx AWS_S3_ACCESS_KEY_ID: xxxxxxxxxxxxxxxxxx AWS_S3_SECRET_ACCESS_KEY: xxxxxxxxxxxxxxxxxx AWS_S3_URL: https://cos.ap-shanghai.myqcloud.com  在docker-compose.yml的volumes部分中，/mnt/s3fs:/opt/s3fs/bucket:rshared意味把宿主机mnt/s3fs文件夹挂载到容器里，你可能需要提前手动创建该文件夹；/opt/s3fs/bucket是固定的，并且rshared也是必不可少的。 docker-compose.yml中配置的环境变量看名称一般都知道什么意思，在挂载腾讯云 COS 的时候可以参考其 相关文档 2。 执行以下命令来启动容器，注意在包含docker-compose.yml的s3fs文件夹中执行。 docker-compose up -d  如果配置正确的话，容器正常启动后就能在宿主机中正常访问腾讯云 COS 的内容了。 根据上面的配置，可以在宿主机的mnt/s3fs目录中访问被挂载的腾讯云 COS 的内容。如果不能正确访问请查看容器日志排查错误。 efrecon/docker-s3fs-client: Alpine-based s3fs client: mount from container, make available to other containers↩对象存储 在兼容 S3 的第三方应用中使用 COS 的通用配置 - 最佳实践 - 文档中心 - 腾讯云↩ "},{"title":"Nodebrew：Node.js 安装以及版本切换","type":0,"sectionRef":"#","url":"blog/nodebrew-the-nodejs-version-manager","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#前言","content":"在许多 Linux 包管理器中 Node.js 的版本比较混乱，或者在官方软件仓库中不存在 Node.js 软件包；自己动手安装又比较繁琐；在某些情况下需要切换 Node.js 版本就更麻烦了，这时 Nodebrew1 就派上用场了。 Nodebrew 是 Node.js 版本管理器，用 Perl 编写，可以简化你关于 Node.js 安装、卸载、版本管理等过程。 Nodebrew 没有为 Windows 而设计，不支持在 Windows 使用。 "},{"title":"安装​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#安装","content":"Nodebrew 的安装过程就是把 Perl 脚本下载到本地，然后将其所在的目录加入PATH中。 "},{"title":"安装位置​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#安装位置","content":"你可以通过设置环境变量NODEBREW_ROOT来指定 Nodebrew 的安装位置。当然你也可以省略这一步骤，如果没有这个环境变量，Nodebrew 会默认安装在$HOME/.nodebrew。 "},{"title":"通过安装脚本安装​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#通过安装脚本安装","content":"执行下面的命令来下载 Nodebrew 到本地。 curl -L git.io/nodebrew | perl - setup  之后你还需要将其加入到PATH中。你需要将下面的命令（二选一）加入到你的 Shell 配置文件中，例如/etc/profile、~/.profile或~/.bashrc等文件。 # Node.js 安装在用户目录，每个用户独立 export PATH=$HOME/.nodebrew/current/bin:$PATH  # Node.js 安装在统一目录，所有用户共用 # 请修改 NODEBREW_ROOT 为你期望的安装位置 export NODEBREW_ROOT=/somewhere export PATH=$NODEBREW_ROOT/current/bin:$PATH  使用下面的命令重载配置文件，配置文件的路径就是你上一步骤中修改的配置文件的路径。或者你也可以直接重新登录终端来使配置生效。 source /etc/profile  使用下面的命令来初始化 Nodebrew 文件夹。 nodebrew setup_dirs  "},{"title":"通过 Homebrew 来安装​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#通过-homebrew-来安装","content":"Homebrew2 是一个包管理器，由 Ruby 编写，可以在 macOS 或 Linux 平台上运行。 使用下面的命令来通过brew命令安装 Nodebrew。 brew install nodebrew  之后你还需要将其加入到PATH中。你需要将下面的命令（二选一）加入到你的 Shell 配置文件中，例如/etc/profile、~/.profile或~/.bashrc等文件。 # Node.js 安装在用户目录，每个用户独立 export PATH=$HOME/.nodebrew/current/bin:$PATH  # Node.js 安装在统一目录，所有用户共用 export NODEBREW_ROOT=$HOMEBREW_PREFIX/var/nodebrew export PATH=$NODEBREW_ROOT/current/bin:$PATH  使用下面的命令重载配置文件，配置文件的路径就是你上一步骤中修改的配置文件的路径。或者你也可以直接重新登录终端来使配置生效。 source /etc/profile  使用下面的命令来初始化 Nodebrew 文件夹。 nodebrew setup_dirs  "},{"title":"使用​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#使用","content":"使用下面的命令来安装并使用最新稳定版的 Node.js。之后node和npm命令就可以用了。 nodebrew install stable nodebrew use stable  更多使用帮助请参考其 Github 仓库 1 页面和命令行中提供的说明信息。 hokaccha/nodebrew: Node.js version manager↩The Missing Package Manager for macOS (or Linux) — Homebrew↩ "},{"title":"Proxmox VE 安装后配置","type":0,"sectionRef":"#","url":"blog/proxmox-ve-post-installation","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#前言","content":"Proxmox VE 基于 Debian，所以和 Debian 的操作还是有很多一样的地方。 "},{"title":"系统软件源镜像​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#系统软件源镜像","content":"执行命令。 apt edit-sources  替换内容，这里使用了 清华大学开源软件镜像站 1。 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free  或者使用 阿里巴巴开源镜像站点 2 deb http://mirrors.aliyun.com/debian/ bullseye main non-free contrib # deb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contrib deb http://mirrors.aliyun.com/debian-security/ bullseye-security main # deb-src http://mirrors.aliyun.com/debian-security/ bullseye-security main deb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib # deb-src http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib deb http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib # deb-src http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib  "},{"title":"Proxmox VE 软件源镜像​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#proxmox-ve-软件源镜像","content":"这里使用了 清华大学开源软件镜像站 3 echo &quot;deb https://mirrors.tuna.tsinghua.edu.cn/proxmox/debian bullseye pve-no-subscription&quot; &gt; /etc/apt/sources.list.d/pve-no-subscription.list  删除 pve-enterprise 源。 # rm /etc/apt/sources.list.d/pve-enterprise.list trash-put /etc/apt/sources.list.d/pve-enterprise.list  "},{"title":"更新​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#更新","content":"apt update apt upgrade  "},{"title":"安装一些小工具​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#安装一些小工具","content":"apt install curl wget tmux bat htop btop exa neofetch trash-cli  "},{"title":"配置别名​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#配置别名","content":"alias bat='batcat' alias ll='exa -lha --modified --created --time-style long-iso --group-directories-first'  "},{"title":"CT 模板镜像​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#ct-模板镜像","content":"直接从 清华大学开源软件镜像站 4 复制下载链接到 Web 控制台下载。 "},{"title":"Windows VirtIO 驱动​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#windows-virtio-驱动","content":"从 Proxmox VE wiki5 中可以找到下载地址。 "},{"title":"挂载点​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#挂载点","content":"// TODO 补充local-lvm的位置 local：/var/lib/vz/local-lvm：``其它硬盘：/mnt/pve/*虚拟机配置文件：/etc/pve/nodes/pve debian | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror↩debian 镜像-debian 下载地址-debian 安装教程 - 阿里巴巴开源镜像站↩proxmox | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror↩Index of /proxmox/images/system/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror↩Windows VirtIO Drivers - Proxmox VE↩ "},{"title":"配置 oh-my-zsh","type":0,"sectionRef":"#","url":"blog/oh-my-zsh","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#前言","content":"oh-my-zsh1 是 zsh2 的一款插件管理器，提供了很多 zsh 的插件和主题。 zsh 的优点是兼容 bash 语法，可以在日常工作中替换掉 bash，并且可以享受 zsh 的很多特性。 "},{"title":"安装​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#安装","content":"安装 oh-my-zsh 之前需要先安装 zsh 和 git，oh-my-zsh 依赖它们在能正常工作。 在 zsh 中执行以下命令安装 oh-my-zsh。 sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;  安装脚本就是帮你克隆了 oh-my-zsh 的仓库到~/.oh-my-zsh，并且给你新建了一个~/.zshrc文件模板，用于在 zsh 启动时加载 oh-my-zsh。 你之前的.zshrc文件内容被转移到.zshrc.pre-oh-my-zsh，现在的.zshrc的内容是全新的，如果你之前在用户配置文件里做了重要配置，你需要将.zshrc.pre-oh-my-zsh里的内容附加到现在的.zshrc之后，以确保之前的功能正常使用。 "},{"title":"主题​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#主题","content":"oh-my-zsh 默认自带了许多主题，这些主题文件存放在~/.oh-my-zsh/themes/文件夹下。你可以在 oh-my-zsh 主题 wiki3 中参考这些主题的预览图。 编辑.zshrc文件，修改ZSH_THEME配置，执行exec zsh命令或重启终端即可看到新主题的效果。 ZSH_THEME=&quot;robbyrussell&quot;  "},{"title":"第三方主题​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#第三方主题","content":"除了默认自带的主题外，你还可以使用第三方主题，如 Dracula4 主题。 下面的命令用于克隆 Dracula 主题的仓库到本地的~/zsh-dracula文件夹。 git clone https://github.com/dracula/zsh.git ~/zsh-dracula  你可以手动复制~/zsh-dracula下的dracula.zsh-theme文件和lib文件夹至~/.oh-my-zsh/custome/themes/文件夹下来完成主题的安装。 也可以使用以下命令创建一个主题的软连接到主题文件夹，来完成主题的安装。 ln -s ~/zsh-dracula/dracula.zsh-theme $ZSH_CUSTOM/themes/dracula.zsh-theme  在安装完成之后编辑.zshrc文件，修改ZSH_THEME配置，执行exec zsh命令或重启终端即可看到新主题的效果。 ZSH_THEME=&quot;dracula&quot;  "},{"title":"插件​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#插件","content":"oh-my-zsh 默认自带了许多插件，这些插件文件存放在~/.oh-my-zsh/plugins/文件夹下。你可以在 oh-my-zsh 插件 wiki5 中查阅默认插件的目录和文档。 编辑.zshrc文件，修改plugins配置，把插件名称写入其中即可启用插件，每个插件名称之间用空格或换行分隔，不要用逗号。注意过多的插件会影响启动时间。执行exec zsh命令或重启终端即可让配置文件生效。 plugins=(git theme)  下面记录一些自用的插件。 "},{"title":"git6​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#git","content":"默认启用的插件，提供了一些 Git 命令的别名和 Git 相关的常用命令，详情可参考其文档 6。 "},{"title":"theme7​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#theme","content":"用命令预览主题，不需要修改配置文件。 theme，随机加载主题lstheme，列出所有主题theme &lt;name&gt;，预览指定主题 "},{"title":"z8​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#z","content":"提供一个z命令用于常用目录快速跳转，日常中可以替换掉cd，在通过z命令切换目录后下次切换只需要输入部分文件名。 下面的命令演示了z plug命令切换到~/.oh-my-zsh/plugins目录。 /usr/bin$ z plug # Even 'z p' might suffice ~/.oh-my-zsh/plugins$  "},{"title":"safe-paste9​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#safe-paste","content":"防止粘贴进终端的多行代码直接执行。 "},{"title":"sudo10​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#sudo","content":"按两次ESC为你当前的命令或前一次命令加上sudo前缀。 "},{"title":"第三方插件​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#第三方插件","content":""},{"title":"zsh-syntax-highlighting11​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#zsh-syntax-highlighting","content":"命令语法高亮。 克隆仓库。 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting  编辑.zshrc文件，修改plugins配置，加上zsh-syntax-highlighting。 plugins=(git theme zsh-syntax-highl3ighting)  "},{"title":"zsh-autosuggestions12​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#zsh-autosuggestions","content":"根据历史命令和命令提示插件来给你输入建议。 克隆仓库。 git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions  编辑.zshrc文件，修改plugins配置，加上zsh-autosuggestions。 ohmyzsh/ohmyzsh: 🙃 A delightful community-driven (with 1900+ contributors) framework for managing your zsh configuration. Includes 300+ optional plugins (rails, git, macOS, hub, docker, homebrew, node, php, python, etc), 140+ themes to spice up your morning, and an auto-update tool so that makes it easy to keep up with the latest updates from the community.↩Installing ZSH · ohmyzsh/ohmyzsh Wiki↩Themes · ohmyzsh/ohmyzsh Wiki↩Dark theme for Zsh and 223+ apps — Dracula↩Plugins · ohmyzsh/ohmyzsh Wiki (github.com)↩ohmyzsh/plugins/git at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/themes at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/z at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/safe-paste at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/sudo at master · ohmyzsh/ohmyzsh↩zsh-users/zsh-syntax-highlighting: Fish shell like syntax highlighting for Zsh.↩ "},{"title":"优雅地重载 Caddyfile","type":0,"sectionRef":"#","url":"blog/reload-caddyfile-gracefully","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"优雅地重载 Caddyfile","url":"blog/reload-caddyfile-gracefully#前言","content":"修改 Caddyfile 之后不需要重新启动 Caddy 服务，Caddy 提供了caddy reload命令可以重新加载配置文件。 记录两个脚本用于格式化 Caddyfile 并重载配置文件。脚本的内容可能需要根据实际情况作某些修改。 "},{"title":"Docker​","type":1,"pageTitle":"优雅地重载 Caddyfile","url":"blog/reload-caddyfile-gracefully#docker","content":"如果你使用docker命令启动 Caddy 容器，可以使用下面的脚本来让 Caddy 重新加载配置文件。该脚本内容参考于 Caddy Docker 镜像文档 1。 #!bin/bash caddy_container_id=$(docker ps | grep caddy | awk '{print $1;}') docker exec -w /etc/caddy $caddy_container_id caddy fmt --overwrite Caddyfile docker exec -w /etc/caddy $caddy_container_id caddy reload  "},{"title":"Docker Compose​","type":1,"pageTitle":"优雅地重载 Caddyfile","url":"blog/reload-caddyfile-gracefully#docker-compose","content":"如果你使用docker-compose命令启动 Caddy 容器，可以使用下面的脚本来让 Caddy 重新加载配置文件。该脚本需要和docker-compose.yml位于同一目录下，并在该目录下执行此脚本。 #!bin/bash docker-compose exec -w /etc/caddy caddy caddy fmt --overwrite Caddyfile docker-compose exec -w /etc/caddy caddy caddy reload  Caddy - Official Image | Docker Hub↩ "},{"title":"重置 MySQL root 密码","type":0,"sectionRef":"#","url":"blog/reset-mysql-root-password","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#前言","content":"注意：如果你的数据库中存有重要数据，请在保证机器离线的情况下进行以下的操作，最稳妥的办法就是拔掉网线！ "},{"title":"方法一：修改配置文件​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#方法一修改配置文件","content":""},{"title":"开启安全模式​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#开启安全模式","content":"修改 MySQL 的配置文件。 vi /etc/my.cnf  在[mysqld]段里加上一行skip-grant-tables，保存并退出。 "},{"title":"重新启动 MySQL​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#重新启动-mysql","content":"service mysqld restart  "},{"title":"修改密码​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#修改密码","content":"mysql -uroot use mysql; update user set Password=password('newpass') where User='root'; flush privileges; exit;  "},{"title":"关闭安全模式​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#关闭安全模式","content":"将第一步在 MySQL 配置文件里加入的skip-grant-tables删掉。 "},{"title":"完成​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#完成","content":"重启 MySQL 之后就可以用新密码登录了。 service mysqld restart  "},{"title":"方法二：通过命令行传递参数​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#方法二通过命令行传递参数","content":""},{"title":"停止 MySQL​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#停止-mysql","content":"service mysqld stop  "},{"title":"以不检查权限的方式启动 MySQL​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#以不检查权限的方式启动-mysql","content":"mysqld --skip-grant-tables &amp;  "},{"title":"修改密码​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#修改密码-1","content":"mysql -uroot  use mysql; update user set Password=password('newpass') where User='root'; flush privileges; exit;  "},{"title":"完成​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#完成-1","content":"用正常的方式重启 MySQL 之后就可以用新密码登录了。 service mysqld restart  "},{"title":"restic：轻量、跨平台的增量备份工具","type":0,"sectionRef":"#","url":"blog/restic-backup-tool","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#前言","content":"restic 是一款用 Go 语言实现的备份工具，具有跨平台运行、增量备份和历史版本备份的特性。 restic 可以使用本地位置或网络位置作为存储库。 有很多情况会导致数据丢失，比如 VPS 提供商跑路、机房失火、设备丢失以及人员误操作等，所以数据备份是一项很重要的工作。重要数据必须要备份。 "},{"title":"概念介绍​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#概念介绍","content":"restic 不直接备份文件，它会把文件分为固定大小的块，把这些文件块存入存储库。 restic 的每次备份都称为一个快照，快照里保存了对一个或多个文件块的引用。当多次备份相同文件的时候可以引用相同的文件块，不会占用很多空间；当文件变化不大的时候，也不需要对变化后的文件再完整备份一次，只需要在存储库中加入变化的文件块即可。 所以 restic 可以做到增量备份和多版本备份，并且空间占用也不多。 restic 在 Github1 开源。 "},{"title":"安装 restic​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#安装-restic","content":"restic 是一个单文件的可执行程序，没有其它依赖。你可以手动从其 Github Releases2 页下载可执行程序；你也可以通过包管理器安装 restic；restic 也可以通过 Docker 运行。安装细节可以参考其官方文档中的 Installation3 部分。 在 restic 正确安装后，你可以得到一个restic命令。 ➜ ~ restic restic is a backup program which allows saving multiple revisions of files and directories in an encrypted repository stored on different backends. Usage: restic [command] Available Commands: backup Create a new backup of files and/or directories cache Operate on local cache directories cat Print internal objects to stdout check Check the repository for errors copy Copy snapshots from one repository to another diff Show differences between two snapshots dump Print a backed-up file to stdout find Find a file, a directory or restic IDs forget Remove snapshots from the repository generate Generate manual pages and auto-completion files (bash, fish, zsh) help Help about any command init Initialize a new repository key Manage keys (passwords) list List objects in the repository ls List files in a snapshot migrate Apply migrations mount Mount the repository prune Remove unneeded data from the repository rebuild-index Build a new index recover Recover data from the repository not referenced by snapshots restore Extract the data from a snapshot self-update Update the restic binary snapshots List all snapshots stats Scan the repository and show basic statistics tag Modify tags on snapshots unlock Remove locks other processes created version Print version information Flags: --cacert file file to load root certificates from (default: use system certificates) --cache-dir directory set the cache directory. (default: use system default cache directory) --cleanup-cache auto remove old cache directories -h, --help help for restic --insecure-tls skip TLS certificate verification when connecting to the repo (insecure) --json set output mode to JSON for commands that support it --key-hint key key ID of key to try decrypting first (default: $RESTIC_KEY_HINT) --limit-download int limits downloads to a maximum rate in KiB/s. (default: unlimited) --limit-upload int limits uploads to a maximum rate in KiB/s. (default: unlimited) --no-cache do not use a local cache --no-lock do not lock the repository, this allows some operations on read-only repositories -o, --option key=value set extended option (key=value, can be specified multiple times) --password-command command shell command to obtain the repository password from (default: $RESTIC_PASSWORD_COMMAND) -p, --password-file file file to read the repository password from (default: $RESTIC_PASSWORD_FILE) -q, --quiet do not output comprehensive progress report -r, --repo repository repository to backup to or restore from (default: $RESTIC_REPOSITORY) --repository-file file file to read the repository location from (default: $RESTIC_REPOSITORY_FILE) --tls-client-cert file path to a file containing PEM encoded TLS client certificate and private key -v, --verbose n be verbose (specify multiple times or a level using --verbose=n, max level/times is 3) Use &quot;restic [command] --help&quot; for more information about a command.  "},{"title":"查看命令帮助​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#查看命令帮助","content":"在使用restic及其子命令时，可以通过使用--help参数来获取一些帮助文档。 restic --help restic backup --help restic ls --help restic snapshots --help  在学习和使用 restic 的过程中，你也可以查看其线上文档 4 来获取帮助。 "},{"title":"初始化存储库​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#初始化存储库","content":"resitc 不使用配置文件，它会从环境变量中获取配置项。所以你可以通过export命令把配置项放入当前 Shell 会话的环境变量中。 在使用 restic 进行数据备份之前你需要先确定一个目录作为存储库，并用 restic 初始化这个目录。 这里需要使用两个配置项。 RESTIC_REPOSITORY：存储库位置。可以是本地位置，也可以是网络位置；RESTIC_PASSWORD：存储库密码。 下面是使用本地存储库的例子。 export RESTIC_REPOSITORY=&quot;/Volumes/extra/restic&quot; export RESTIC_PASSWORD=&quot;pass&quot;  需要注意的是，使用export暴露的环境变量只在当前 Shell 会话生效，当你重启 Shell 后这些环境变量就不存在了。 # 初始化存储库 restic init  存储库只需初始化一次，并且 restic 对存储库相关的操作都需要存储库的密码，你要保管好存储库密码。 "},{"title":"备份数据​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#备份数据","content":"使用restic backup命令来备份数据。 restic backup [flags] FILE/DIR [FILE/DIR] ...  # 下面的命令用于把 /data 目录下的文件做备份。每次备份都会生成一个快照。 restic backup ~/data  "},{"title":"查询快照记录​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#查询快照记录","content":"使用restic snapshots命令来查看快照记录，每个快照都有一个 ID。 restic snapshots [flags] [snapshotID ...]  "},{"title":"查看快照内容​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#查看快照内容","content":"使用restic ls命令来查看快照中的内容。 restic ls [flags] snapshotID [dir...]  # 列出快照中的所有目录和文件，会递归列出目录中的内容 restic ls 9e73578b # 可以用`latest`代替最新的快照 ID，列出最近的一次快照中的内容 restic ls latest # 列出快照中`/`目录下的内容，不会递归子文件夹 restic ls 9e73578b / # 列出快照中`/data`目录下的内容，不会递归子文件夹 restic ls 9e73578b /data  "},{"title":"恢复数据​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#恢复数据","content":"使用restic restore命令来从快照恢复数据。 restic restore [flags] snapshotID  # 恢复快照里的内容至 ~/restore-target 目录 restic restore -t ~/restore-target 9e73578b # 恢复快照里的内容至 ~/restore-target 目录，只恢复快照中的 /data/file1 内容 restic restore -t ~/restore-target -i /data/file1 9e73578b  "},{"title":"删除快照​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#删除快照","content":"使用restic forget命令来删除快照。 restic forget [flags] [snapshot ID] [...]  # 删除 ID 为 9e73578b 的快照 restic forget 9e73578b  可以设置淘汰策略来批量删除历史快照。 # 使用淘汰策略批量删除快照 restic forget --keep-last 12 --keep-hourly 24 --keep-daily 7 --keep-weekly 4 --keep-monthly 12  上面的命令定义了一些淘汰策略，不满足此策略的快照会被删除。 永远保留最新的 12 个快照；对于过去 24 小时的快照，每个小时都保留一个最新的快照；对于过去的 7 天，每天都保留一个最新的快照；对于过去的 4 周，每周都保留一个最新的快照；对于过去的 12 个月，每个月都保留一个最新的快照。 删除快照并不会释放存储库的存储空间，因为删除快照只是删除了对文件块的引用，文件块是不会被删除的。 使用restic prune命令来检查所有的文件块并删除没有被任何快照引用的文件块，从而释放存储库的空间。也可以在使用restic forget命令时加上--prune参数，restic 在删除快照之后会紧跟着执行prune命令。 # 扫描所有文件块，删除没有被任何一个快照引用的文件块 restic prune # 在 forget 之后自动执行 prune 命令来释放空间 restic forget --prune --keep-last 12 --keep-hourly 24 --keep-daily 7 --keep-weekly 4 --keep-monthly 12  "},{"title":"多机器共用存储库​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#多机器共用存储库","content":"如果你有多个机器需要备份数据，可以共用一个存储库。 每个快照都有一个 Host 属性，对应着实施备份操作的主机名（Hostname）。默认情况下 restic 直接读取系统中的 Hostname，你也可以通过--host或-H参数手动指定主机名。该参数可用于许多命令，如backup、snapshots或forget等命令中。 快照和快照之间是没有继承关系的，你删除之前的快照不会影响到之后的快照。 在使用restic forget命令使用淘汰策略删除快照时，如果不指定主机名会对分别对所有主机下的快照分别执行淘汰策略；如果指定了主机名则只会对对应主机名的快照执行淘汰策略。 "},{"title":"后记​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#后记","content":"做了备份也不是一劳永逸的。你可能还需要异地多备份，仅仅备份在本地是不方便也是不安全的。 使用对象存储服作为存储库是一个不错的选择，基本上所有的对象存储服务器都兼容 Amazon S3 的 API，都可以作为 restic 的存储库使用。 对象存储的收费项目有下载流量费用、API 调用费用和存储空间费用。上传流量一般是不收费的，同时 API 调用费用和存储空间费用都不高。下载流量费用收费较高，但是在进行备份的时候没有多少下载流量，在紧急情况下恢复文件的时候可以买限时流量包包来降低下载流量的费用。花点钱赎回自己的数据总比数据都消失了要好。 有些对象存储在内网的下载流量也不收费，比如腾讯云的对象存储在腾讯云服务器中使用的话，下载流量就不计费，只收 API 调用的费用，你可以通过腾讯云的服务器来中转对象存储中的内容。关于此内容可以参考「挂载腾讯云 COS 到本地文件夹」5。 在数据备份到对象存储之后，可以定期从对象存储中下载数据到本地的移动硬盘中，达成异地备份。存储库迁移可以使用rclone工具，把对象存储中的所有内容复制到本地即可完成迁移，rclone可以只复制有变化的内容并且删除多余的内容。 要定期做数据恢复测试，检查备份是否正常，是否能按期望恢复数据。备份不测试，等于没备份。 restic/restic: Fast, secure, efficient backup program↩Releases · restic/restic↩Installation — restic 0.13.1 documentation↩Restic Documentation — restic 0.13.1 documentation↩挂载腾讯云 COS 到本地文件夹↩ "},{"title":"Scoop：Windows 包管理器","type":0,"sectionRef":"#","url":"blog/scoop-the-windows-package-manager","content":"","keywords":""},{"title":"引入 Scoop​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#引入-scoop","content":"包管理器用于管理软件的生命周期：安装软件及其依赖，配置软件环境变量、更新软件和卸载软件。 Scoop1 是 Windows 上的一款包管理器，它是用 PowerShell 编写的，它可以帮助使用者特别是开发人员管理软件环境，快速构建开发环境。常用的开发工具都可以通过 Scoop 安装和管理。 Scoop 的本质是一系列 PowerShell 脚本的集合，所以运行 Scoop 需要 PowerShell 环境。并且它是针对 Windows 系统设计的，不具有跨平台性。 Scoop 对软件的管理功能依赖于提前定义好的针对每个软件包的配置文件，这些文件为 JSON 格式，称为 Manifest，由众多开发者维护，并托管在 Github。一个 Manifest 对应一个软件，其中包含了该软件的下载地址、安装/卸载脚本和其它必要信息。存放 Manifest 的仓库被称为 Bucket，对应一个 Git 仓库。Manifest 和 Bucket 是 Scoop 中的核心概念。 Scoop 对 Manifest 和 Bucket 的管理依赖于 Git。目前 Scoop 的官方 Bucket 托管在 GitHub。 Scoop 安装软件的过程依赖于 7-zip 和其它类型的解包软件如 innounp，Scoop 会将安装包里的文件解压至软件安装目录。.zip、.7z、.msi和大部分的.exe文件都能解包，软件的安装过程都是自动的，并不是传统的可视化界面方式，不需要人工干预，都由 Scoop 自动管理，程序文件放在统一的位置。软件开发者并不需要专门为 Scoop 制作专门的安装包，通用的软件安装程序都可以通过 Scoop 安装。 通过 Scoop 安装的软件大多是「绿色软件」，即不会写入注册表、不会创建桌面快捷方式，软件单独运行，不会有过多的依赖。Scoop 会根据 Manifest 中的信息为软件创建开始菜单中的快捷方式、创建命令链接、配置环境变量，通过 Scoop 安装软件不会污染系统环境。 "},{"title":"安装前准备​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#安装前准备","content":"Scoop 的安装和使用都需要访问到 Github，考虑到国内网络情况的特殊性，请你自备代理软件以确保能正常访问 GitHub。 大部分的命令行应用不会读取系统代理设置，所以有些情况下及时你启动了代理软件命令行应用也不会通过代理软件访问网络，你可能需要手动设置命令行环境的代理。 在 PowerShell 中，你可以执行以下命令来设置代理，请酌情替换其中的地址和端口号。 $Env:http_proxy=&quot;http://127.0.0.1:11223&quot; $Env:https_proxy=&quot;http://127.0.0.1:11223&quot;  该命令只在当前会话生效，当你关闭了 PowerShell 再次打开一个新的会话时则你需要再次执行该命令才能让代理设置生效。 你可以将这些命令写入$PROFILE文件来避免在每次新会话中重复执行命令的工作。PowerShell 在每次会话启动之后都会执行一次$PROFILE配置文件中的命令。 以下命令用于创建并用记事本打开$PROFILE文件。 if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE  在打开的记事本中写入设置代理的命令，保存该文件，并重新打开 PowerShell 即可生效。 $Env:http_proxy=&quot;http://127.0.0.1:11223&quot; $Env:https_proxy=&quot;http://127.0.0.1:11223&quot;  "},{"title":"前提​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#前提","content":"Scoop 依赖以下系统环境才能正常工作。 PowerShell 5+.NET Framework 4.5+ 对于现代的 Windows 10 系统来说，这些条件已自动满足，对于较为古老的 Windows 7 系统用户来说，你可能需要手动升级 PowerShell 到PowerShell 5，并安装.NET Framework 4.5。 Scoop 依赖 Git 和 7-zip 来完成基本的工作，但是你不需要手动安装这些软件。你只需要确保良好的网络环境。 "},{"title":"设置安装位置​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#设置安装位置","content":"// TODO 补充此章节，还有各个步骤的截图 "},{"title":"安装 Scoop​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#安装-scoop","content":"接下来的命令都在 PowerShell 中执行。 下面的命令用于允许执行外部 PowerShell 脚本。你可能看到提示信息，请输入「Y」并按下回车键。 Set-ExecutionPolicy RemoteSigned -scope CurrentUser  下面的命令用于安装 Scoop。 Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')  在安装完成之后你将得到一个新的可执行命令scoop。下面的命令用于安装 7-zip 和 Git。 scoop install 7zip git  等待命令执行完毕之后你就可以在命令行中使用7z和git命令，Scoop 已经为你配置好了环境变量和命令链接。 在安装好 Git 之后你需要为 Git 设置代理，以下命令用来为 Git 设置代理，请酌情替换其中的地址和端口号。 git config --global http.proxy http://127.0.0.1:11223 git config --global https.proxy http://127.0.0.1:11223  对 Git 的设置是永久性的，以下命令用于取消为 Git 设置代理，使用时请去掉注释前缀。 # git config --global --unset http.proxy # git config --global --unset https.proxy  下面的命令用于添加extras软件仓库。 scoop bucket add extras  "},{"title":"Scoop 的目录结构​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#scoop-的目录结构","content":"// TODO 补充此章节，还有各个步骤的截图 "},{"title":"Scoop 软件管理命令​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#scoop-软件管理命令","content":"命令\t示例\t备注scoop search &lt;关键词&gt;\tscoop search firefox\t搜索和关键词相关的软件包 scoop info &lt;包名&gt;\tscoop info firefox\t查看软件包信息 scoop install &lt;包名&gt;\tscoop install nodejs-lts adopt8-hotspot\t安装指定软件，可以一次性安装多个软件，用空格分割这些软件名 scoop uninstall &lt;包名&gt;\tscoop uninstall nodejs-lts\t卸载指定软件 scoop reinstall &lt;包名&gt;\tscoop reinstall nodejs-lts\t重新安装指定软件 scoop reset &lt;包名&gt;\tscoop reset python\t重新执行软件安装后脚本，以解决冲突 scoop list 列出所有已安装软件 scoop list &lt;关键词&gt;\tscoop list node\t列出和关键词相关的已安装软件 scoop status 查询更新信息 scoop update &lt;包名&gt;\tscoop update vscode\t更新指定的软件 scoop update 更新 Scoop 和所有仓库信息 "},{"title":"Scoop 仓库管理命令​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#scoop-仓库管理命令","content":"仓库相关命令均以scoop bucket开始。 命令\t示例\t备注scoop bucket known 列出知名软件仓库 scoop bucket add &lt;知名仓库名&gt;\tscoop bucket add jetbrains\t添加知名软件仓库，不用输入仓库地址 scoop bucket add &lt;别名&gt; &lt;仓库地址&gt;\tscoop bucket add bobo2334 https://github.com/bobo2334/scoop-bucket.git\t添加第三方软件仓库 scoop bucket rm &lt;别名&gt;\tscoop bucket rm nerd-fonts\t移除软件仓库 scoop bucket list 列出所有已添加的软件仓库 "},{"title":"卸载 Scoop​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#卸载-scoop","content":"如果 Scoop 不能让你满意的话，你可以用下面的命令来移除 Scoop。这将会删除所有你用 Scoop 安装的软件，最后删除 Scoop 它自身。 scoop uninstall scoop  Scoop↩ "},{"title":"使用 restic 定时备份文件","type":0,"sectionRef":"#","url":"blog/restic-scheduled-backup","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#前言","content":"restic 不会在后台运行，没有定时备份的功能。如果你有定时备份文件的需求，你可以使用 lobaro/restic-backup-docker 项目，这个项目提供了一个 Docker 镜像，可以很方便地使用 restic 定时进行文件备份。 "},{"title":"项目介绍​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#项目介绍","content":"lobaro/restic-backup-docker1 是一个 Docker 镜像，镜像中包含 restic2 和 cron，可以通过 cron 来定时执行 restic 的备份任务。容器的配置都可以通过设置环境变量来完成。你需要进行如下配置，正确配置后就可以定期执行 restic 的备份任务了。 把要备份的文件和目录挂载到容器中/data目录下；配置好 restic 相关的环境变量；配置 cron 表达式。 "},{"title":"使用示例​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#使用示例","content":"下面演示使用 Docker Compose 配置运行 restic-backup-docker 容器，定时备份文件到腾讯云 COS 中。 restic-backup-docker/docker-compose.yml version: '3'services: restic: image: lobaro/restic-backup-docker hostname: a-computer.local restart: unless-stopped volumes: - ./excludes.txt:/var/excludes.txt:ro - caddy_data:/data/caddy_data:ro - mysql_data:/data/mysql_data:ro environment: TZ: Asia/Shanghai BACKUP_CRON: 0 */6 * * * RESTIC_REPOSITORY: s3:https://cos.ap-shanghai.myqcloud.com/xxxxx-xxxxxxxxxx AWS_ACCESS_KEY_ID: xxxxxxxxxx AWS_SECRET_ACCESS_KEY: xxxxxxxxxx RESTIC_PASSWORD: xxxxxxxxxx RESTIC_JOB_ARGS: --limit-upload 5000 --exclude-file /var/excludes.txt RESTIC_FORGET_ARGS: --prune --keep-last 12 --keep-hourly 24 --keep-daily 7 --keep-weekly 4 --keep-monthly 12volumes: caddy_data: external: true mysql_data: external: true 创建excludes.txt文本文件，作为 restic 的--exclude-file参数内容。restic 在备份过程中会忽略掉匹配这些规则的文件。 注意以#开头的行会被视为注释，如果你想排除某个以#开头的文件或文件夹，请使用\\#来转义。 restic-backup-docker/excludes.txt *log* *cache* tmp \\#recycle  docker-compose.yml文件中的hostname设置容器的主机名，restic 在进行备份的时候会用上主机名，表名此次备份是从哪台主机上创建的。 接下来对docker-compose.yml文件中的environment部分进行说明： TZ，设置容器内的时区，格式为 IANA time zone3；BACKUP_CRON，执行备份任务的 cron 表达式，0 */6 * * *表示每 6 小时执行一次。可以使用一些 在线工具 4 来验证 cron 表达式；RESTIC_REPOSITORY，restic 备份目的地，这里备份到腾讯云的 COS 中，腾讯云 COS 兼容 Amazon S3 协议。具体可以参考 腾讯云 COS 文档 5 和 restic 文档 6。容器在启动时候会检测该仓库是否用 restic 初始化过，如果没有的话则会自动初始化仓库；AWS_ACCESS_KEY_ID，腾讯云 COS 相关配置；AWS_SECRET_ACCESS_KEY，腾讯云 COS 相关配置；RESTIC_PASSWORD，restic 仓库的密码；RESTIC_JOB_ARGS，执行restic backup命令时附加的额外参数，详情可参考 restic 文档 7；RESTIC_FORGET_ARGS，执行restic forget命令时附加的额外参数，详情可参考 restic 文档 8。 接下来对docker-compose.yml文件中的volumes部分进行说明： ./excludes.txt:/var/excludes.txt:ro，挂载excludes.txt；caddy_data:/data/caddy_data:ro，挂载caddy_data卷到容器内/data目录下；mysql_data:/data/mysql_data:ro，挂载mysql_data卷到容器内/data目录下；/root:/data/root:ro，挂载/root目录到容器内/data目录下。 "},{"title":"启动容器​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#启动容器","content":"在restic-backup-docker目录下执行命令。 # 验证 docker-compose.yml 文件的格式是否正确 docker-compose config # 启动容器 docker-compose up -d  "},{"title":"测试配置​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#测试配置","content":"# 手动执行一次备份任务 docker-compose exec restic backup # 查看 restic 的备份历史 docker-compose exec restic restic snapshots # 查看上一次`restic backup`命令的结果 docker-compose exec restic cat /var/log/backup-last.log # 查看最近一次失败的`restic backup`命令的结果 docker-compose exec restic cat /var/log/backup-error-last.log # 查看 cron 日志 docker-compose logs -f docker-compose exec restic cat /var/log/cron.log # 在容器内启动一个 Shell，方面执行其他命令 docker-compose exec restic sh  "},{"title":"更多用法​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#更多用法","content":"lobaro/restic-backup-docker 还有很多其他用法，例如： 在容器内自动挂载 NFS 目录；在容器内使用restic mount命令；在备份前后执行自定义脚本。 本文中并没有涵盖所有的用法说明，关于更多用法请参考 lobaro/restic-backup-docker9。 lobaro/restic-backup-docker - Docker Image | Docker Hub↩restic：轻量、跨平台的增量备份工具↩Noda Time | Time zones↩Crontab.guru - The cron schedule expression editor↩对象存储 在兼容 S3 的第三方应用中使用 COS 的通用配置 - 最佳实践 - 文档中心 - 腾讯云↩Preparing a new repository — restic 0.13.1 documentation↩Backing up — restic 0.13.1 documentation↩Removing backup snapshots — restic 0.13.1 documentation↩lobaro/restic-backup-docker: A docker container to automate backups with restic↩ "},{"title":"Scoop：用 aria2 加速下载","type":0,"sectionRef":"#","url":"blog/scoop-with-aria2-for-multi-thread-download","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Scoop：用 aria2 加速下载","url":"blog/scoop-with-aria2-for-multi-thread-download#前言","content":"aria21 是一款流行的多线程下载器。Scoop 在默认情况下使用单线程下载，你可以通过安装 aria2 来让 Scoop 支持多线程下载。 "},{"title":"安装 aria2​","type":1,"pageTitle":"Scoop：用 aria2 加速下载","url":"blog/scoop-with-aria2-for-multi-thread-download#安装-aria2","content":"在 PowerShell 中执行用下面的命令来安装 aria2。 scoop install aria2  不需要多余配置，Scoop 在执行下载动作前会检测你是否安装了 aria2，如果检测到你已经安装了 aria2 则自动调用其进行多线程下载。 "},{"title":"配置 aria2​","type":1,"pageTitle":"Scoop：用 aria2 加速下载","url":"blog/scoop-with-aria2-for-multi-thread-download#配置-aria2","content":"在 Scoop 中有一些关于 aria2 的配置 2，在某些情况下你可能想了解。 配置项\t默认值\t说明aria2-enabled\ttrue\t是否启用 aria2 aria2-warning-enabled\ttrue\t是否在每次下载之前输出提示信息，内容为 aria2 下载的说明 aria2-retry-wait\t2\taria2 重试等待时间，单位为秒 aria2-split\t5\t下载时使用的链接数 aria2-max-connection-per-server\t5\t每个服务器的最大连接数 aria2-min-split-size\t5M\t最小分段大小，如果将要下载的文件大小小于该参数的 2 倍，则下载的过程中不会对文件进行分段 aria2-options 其它需要传递给 aria2 的参数，可以参考 aria2 的文档 3 你可以通过scoop config命令来更改这些配置项的值。 例如你想停止使用 aria2 进行多线程下载，你可以通过执行下面的命令实现。 scoop config aria2-enabled false  aria2/aria2: aria2 is a lightweight multi-protocol &amp; multi-source, cross platform download utility operated in command-line. It supports HTTP/HTTPS, FTP, SFTP, BitTorrent and Metalink.↩ScoopInstaller/Scoop: A command-line installer for Windows.↩aria2c(1) — aria2 1.36.0 documentation↩ "},{"title":"Gitea：轻量级自建 Git 服务","type":0,"sectionRef":"#","url":"blog/self-hosted-git-service-gitea","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#前言","content":"最近发生了一些事件：Github 封禁某些国家用户的账号；Gitee 公开仓库变私有，公开需通过审核。 这些大平台提供的服务看起来也不是那么可靠。这时候你可以自建一个 Git 服务平台自用，自己保管数据。 "},{"title":"为什么选择 Gitea​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#为什么选择-gitea","content":"下面列出了 Gitea1 的优点。 Gitea 占用资源低，300MB 内存足以满足个人使用，其在官方网页上的介绍说明在树莓派上足以运行；用 Go 语言实现，可以部署在很多平台上，并且不会有依赖问题；安装方便，使用 Docker 可以直接部署；外部依赖少，可以使用 SQLite 作为数据库，个人使用完全足够，数据迁移也方便；开源；功能丰富，仓库有 Issues、Pull Requests、Projects、Releases、Wiki 以及 Activity 等板块；并且可以设置 Webhooks、Push Mirrow、镜像仓库等。用户界面模仿 Github，学习成本低，使用体验良好；有完整的用户和组织系统。 Gitea 没有集成 CI/CD 工具，因为 CI/CD 工具比较耗资源。 "},{"title":"安装​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#安装","content":"可以使用 Docker Compose 快速部署 Gitea 实例。 以下是docker-compose.yml的内容示例。 version: &quot;3&quot; services: server: image: gitea/gitea restart: unless-stopped ports: - 127.0.0.1:13000:3000 - 127.0.0.1:2222:22 volumes: - data:/data volumes: data:  以下是对docker-compose.yml文件的简短说明。 ports：容器的 3000 端口为 Web UI 的监听端口；容器的 22 端口为 SSH 端口，用于 SSH 方式访问 Git 仓库；volumes：Gitea 的数据都保存在容器内的/data目录中，包括所有 Git 仓库的文件都保存在此目录中。 "},{"title":"反向代理以及 HTTPS 配置​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#反向代理以及-https-配置","content":"可以使用 Web 服务器对 Gitea 的 Web UI 进行反向代理，通过域名暴露在公网中。 下面是使用 Caddy 进行反向代理的示例，这是 Caddyfile 的部分内容。Caddy 会自动申请域名证书并配置 HTTPS。 *.iuok.me { tls { dns cloudflare xxxxxx } @gitea host gitea.iuok.me handle @gitea { reverse_proxy localhost:13000 import hsts } handle { abort } }  "},{"title":"初次设置​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#初次设置","content":"在浏览器中输入你的 Gitea 域名进行访问，初次访问的时候会进入设置页面。 可以选择是否开启 SSH，如果把 SSH 端口设置为 0 则意味关闭 SSH 访问。 完成安装后如果再需要更改某些设置需要手动在配置文件中更改，配置文件位于容器中的/data/gitea/conf/app.ini。配置文件的配置细节可以参考其官方文档 2。 "},{"title":"使用​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#使用","content":"如果你只想自己一个人用的话需要设置不允许新用户注册，并且把自己的账号和仓库都设置为私有的；公共的仓库可以在主页被访客浏览。 使用体验和 Github 差不多。 "},{"title":"双因素认证​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#双因素认证","content":"为了提高账户的安全性，可以设置账户的双因素认证。 在「Settings」-&gt;「Security」-&gt;「Two-Factor Authentication」中可以开启双因素认证。使用支持 TOTP 的令牌软件都可以生成登录令牌；如 Authy、Google Authenticator 或 Bitwarden 等软件。 开启之后在登录时除了输入密码之外，还会要求你输入一个动态验证码，该验证码随时间变化。 开了双因素认证之后在使用 HTTPS 方式访问 Git 仓库时就不能用原来的密码了，需要你单独生成一个 Access Token 来访问仓库。Access Token 需要在「Settings」-&gt;「Applications」-&gt;「Manage Access Tokens 」中创建。 "},{"title":"镜像仓库​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#镜像仓库","content":"在 Gitea 中可以创建镜像仓库，用于定时从源仓库中同步内容。 在创建仓库的时候选择迁移仓库，在迁移选项中勾选「This repository will be a mirror」即可创建一个镜像仓库。 只有创建仓库的时候可以选择创建镜像仓库，不可以把现有仓库改为镜像仓库；镜像仓库之后可以改为普通仓库。 "},{"title":"数据备份​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#数据备份","content":"自建的服务要做好数据备份工作，因为 VPS 提供商也不一定可靠，也有可能发生意外事故，导致数据丢失。 Gitea 的数据文件结构比较简单，直接备份 Docker Volume 对应的目录即可。 默认情况下，Docker Volume 位于/var/lib/docker/volume下，备份docker-compose.yml中对应的数据卷中的内容即可。 可以使用 restic 备份到其它服务商提供的对象存储中；注意要异地备份，备份在本机无意义。 恢复数据的时候手动创建 Volume，把备份内容还原，然后再启动 Gitea 容器即可。 Gitea↩Documentation - Docs↩ "},{"title":"自建 Zerotier 行星节点","type":0,"sectionRef":"#","url":"blog/self-hosted-zerotier-controller","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"自建 Zerotier 行星节点","url":"blog/self-hosted-zerotier-controller#前言","content":"自建 ZeroTier Planet 行星服务器可以解决两个问题： 官方免费版本有 50 个设备连接数的限制提升网络稳定性 "},{"title":"运行项目​","type":1,"pageTitle":"自建 Zerotier 行星节点","url":"blog/self-hosted-zerotier-controller#运行项目","content":"使用docker-compose可以快速运行项目。docker-compose.yml的内容如下。 version: '3' services: ztncui: image: keynetworks/ztncui restart: unless-stopped ports: - '3000:3000' environment: MYADDR: 172.38.38.38 HTTP_ALL_INTERFACES: &quot;yes&quot; ZTNCUI_PASSWD: PASS TZ: Asia/Shanghai volumes: - ztncui:/opt/key-networks/ztncui/etc/ - zerotier-one:/var/lib/zerotier-one/ volumes: ztncui: null zerotier-one: null  其中一些环境变量需要设置。 MYADDR：机器的公网 IP 地址HTTP_ALL_INTERFACES：监听所有网络接口ZTNCUI_PASSWD：设置admin用户的密码。 ztncui和zerotier-one两个 Volume 持久化配置信息，防止重新创建容器后丢失配置。 在当前目录下用docker-compose up -d启动容器。 防火墙需要放行3000端口。 "},{"title":"网络配置​","type":1,"pageTitle":"自建 Zerotier 行星节点","url":"blog/self-hosted-zerotier-controller#网络配置","content":"访问IP:3000可以进入网页管理 UI，也可以用反响代理服务器来转发此端口的流量，并用域名和 HTTPS 访问。用户名是admin，密码是你之前配置的环境变量ZTNCUI_PASSWD的值。 控制面板的使用方法和操作逻辑和官方控制面板差不多。 在底部的导航栏中点击「Networks」，再点击Add network创建一个网络。给网络起一个名字之后你就能在「Networks」中看见你刚刚创建的网络了。  点击该网络名就能进入该网络设置的设置页面。  点击「Easy setup」按钮为网络设置网段。在该页面中点击「Generate network address」按钮可以随机生成网段，点击「Submit」按钮保存信息。  点击「Private」按钮设置私有网络/公开网络。  点击「Routes」按钮设置静态路由。  "},{"title":"客户端​","type":1,"pageTitle":"自建 Zerotier 行星节点","url":"blog/self-hosted-zerotier-controller#客户端","content":"使用各个平台的原生客户端直接可以连接到自建网络。Network ID 填自己的就行了。 客户端在加入私有网络的时候需要在网络管理页面手动批准认证；勾选对应的「Authorized」列选框即可。  "},{"title":"参考资料​","type":1,"pageTitle":"自建 Zerotier 行星节点","url":"blog/self-hosted-zerotier-controller#参考资料","content":"ZeroTier Planet 行星服务器，一键私有部署，可突破 50 台设备限制 - 小众软件Jonnyan404/zerotier-planet: 一分钟自建 zerotier-planetkey-networks/ztncui: ZeroTier network controller UIkey-networks/ztncui-containerized: A Docker image that contains ZeroTier One and ztncui to set up a standalone ZeroTier network controller with a web user interface in a container. "},{"title":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","type":0,"sectionRef":"#","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#前言","content":"在用 IntelliJ IDEA 运行 Java Web 项目时，在 Tomcat 的日志输出区域会出现乱码，效果如下图所示。 在网络上查了一些资料 1，记录下解决办法。  "},{"title":"原因分析​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#原因分析","content":"可能是因为 IDEA 控制台中所采用的字符编码与 Tomcat 输出所采用的字符编码不一致，导致了出现乱码。 IDEA 控制台输出采用的是 GBK 编码，Tomcat 输出采用的是 UTF-8 编码。 "},{"title":"解决办法​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#解决办法","content":""},{"title":"法一：修改 IDEA 控制台输出编码为 UTF-8​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#法一修改-idea-控制台输出编码为-utf-8","content":"在 IDEA 的上方工具栏中，依次选择Help-&gt;Edit Custome VM Options...。  在vmoptions中添加如下一行参数，之后重启 IDEA。 -Dfile.encoding=UTF-8  该文件实际位于C:\\Users\\&lt;用户名&gt;\\AppData\\Roaming\\JetBrains\\IntelliJIdea2020.3\\idea64.exe.vmoptions，所以直接修改此文件应该也可行。  "},{"title":"法二：修改 Tomcat 输出编码为 GBK​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#法二修改-tomcat-输出编码为-gbk","content":"在 Tomcat 安装位置下的 conf 文件中存在logging.properties配置文件。 修改其中的配置，将java.util.logging.ConsoleHandler.encoding的属性由UTF-8改为GBK。 保存之后重启 Tomcat 即可。  "},{"title":"结果​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#结果","content":"两种方法均可以解决问题。  idea tomcat 乱码问题的解决及相关设置 - 行而思 - 博客园↩ "},{"title":"通过代理连接 SSH 服务器","type":0,"sectionRef":"#","url":"blog/ssh-under-proxy","content":"","keywords":""},{"title":"正文​","type":1,"pageTitle":"通过代理连接 SSH 服务器","url":"blog/ssh-under-proxy#正文","content":"下面的命令用于通过 SOCKS5 代理连接到 SSH 服务器。其中127.0.0.1:7890是本地 SOCKS5 代理的地址和端口号。 ssh -oProxyCommand=&quot;nc -x 127.0.0.1:7890 %h %p&quot; root@198.198.198.198  "},{"title":"参考资料​","type":1,"pageTitle":"通过代理连接 SSH 服务器","url":"blog/ssh-under-proxy#参考资料","content":"透过代理连接 SSH [Lainme's Blog] "},{"title":"SSH 密钥登录","type":0,"sectionRef":"#","url":"blog/ssh-certificate-authentication","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#前言","content":"SSH 默认采用密码登录，这种方法有很多缺点，简单的密码不安全，复杂的密码不容易记忆，每次手动输入也很麻烦。密钥登录是比密码登录更好的解决方案。1 "},{"title":"生成秘钥​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#生成秘钥","content":"可以用 OpenSSH 中的ssh-keygen命令行工具来生成秘钥。-t参数指定了加密方式，通常为rsa或dsa。 ssh-keygen -t rsa  生成的密钥文件默认就会是~/.ssh/id_rsa（私钥）和~/.ssh/id_rsa.pub（公钥）。 也可以用 PuTTY 中提供的 PuTTY Key Generator（puttygen.exe）2 来用可视化用户界面来生成秘钥文件。  "},{"title":"把公钥放在服务器上​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#把公钥放在服务器上","content":"用户公钥保存在~/.ssh/authorized_keys文件中，如果该文件不存在，你可以手动创建一个。 然后将公钥的文本内容放入其中，每行一个。 "},{"title":"关闭密码登录​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#关闭密码登录","content":"编辑/etc/ssh/sshd_config文件，找到对应的配置项并修改。 # 不允许密码直接登录 PasswordAuthentication no # 不允许空密码登录 PermitEmptyPasswords no # 不允许交互式密码登录 ChallengeResponseAuthentication no # 不允许 root 用户使用密码登录 PermitRootLogin prohibit-password # 使用秘钥登录 PubkeyAuthentication yes  重启sshd，让配置生效。 sudo systemctl restart sshd  "},{"title":"测试配置是否生效​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#测试配置是否生效","content":"使用ssh命令连接远程服务器，使用-i参数传递私钥文件。 ssh -i .\\centos7\\.vagrant\\machines\\default\\virtualbox\\private_key vagrant@192.168.33.12  "},{"title":"参考资料​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#参考资料","content":"How To Configure SSH Key-Based Authentication on a Linux Server | DigitalOcean14.3. Using OpenSSH Certificate Authentication Red Hat Enterprise Linux 6 | Red Hat Customer Portal SSH 密钥登录 - SSH 教程 - 网道↩Download PuTTY: latest release (0.76)↩ "},{"title":"iterm2 对 tmux 的特殊支持","type":0,"sectionRef":"#","url":"blog/tmux-integration-in-iterm2","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"iterm2 对 tmux 的特殊支持","url":"blog/tmux-integration-in-iterm2#前言","content":"tmux1 是一款非常好用的终端复用工具，它可以帮助你快速地保存和恢复工作现场。 使用 tmux 的时候有许多快捷键需要记忆，并且窗格切换和窗格的上下滚动并不方便；tmux 的快捷键还可能和其它软件的快捷键有冲突。 iterm22 是 macOS 中的一个终端模拟器软件，它对 tmux 有独家支持，可以在控制模式下运行 tmux。在这个模式中，tmux 会话表现和本地终端一样，可以使用 iterm2 的快捷键来进行多窗口和多窗格分隔，用鼠标切换窗口和窗格，并且用鼠标滚轮上下滚动窗格也能正常工作，不需要进 tmux 的复制模式来滚动窗格。 "},{"title":"使用​","type":1,"pageTitle":"iterm2 对 tmux 的特殊支持","url":"blog/tmux-integration-in-iterm2#使用","content":"不论是在本地使用 tmux，还是通过 ssh 使用远端的 tmux，iterm2 都支持使用 tmux 的控制模式。 tmux 的控制模式通过附加-CC参数来开启。 如tmux -CC命令会开启一个新的 tmux 会话，并启用控制模式，之后你的 iterm 会打开一个新的窗口，用于展示 tmux 会话；该窗口的表现和没使用 tmux 时一样，你不需要通过快捷键或 tmux 命令来新建多窗口和多窗格。使用 iterm2 的快捷键Command+D和Command+Shift+D来分隔窗格，使用Command+N来新建 Tab，使用Command+N来新建窗口。 使用如下命令来附加到一个已存在的 tmux 会话。 tmux ls tmux -CC attach -t 0  下面的命令用于创建一个名为main的会话，如果该会话存在的话则直接恢复该会话。 tmux -CC new -A -s main  或者在通过 SSH 连接到服务器的时候直接执行此命令，直接打开一个 tmux 会话。 ssh -t root@1.1.1.1 'tmux -CC new -A -s main'  "},{"title":"参考资料​","type":1,"pageTitle":"iterm2 对 tmux 的特殊支持","url":"blog/tmux-integration-in-iterm2#参考资料","content":"tmux Integration Best Practices · Wiki · George Nachman / iterm2 · GitLab tmux | 我的学习笔记↩tmux Integration - Documentation - iTerm2 - macOS Terminal Replacement↩ "},{"title":"UFW：简单易上手的防火墙规则管理工具","type":0,"sectionRef":"#","url":"blog/ufw","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#前言","content":"UFW 是一款在 Debian 系系统中可用的防火墙规则管理工具，可以帮助你快速配置各种服务的端口访问权限，而不用书写冗长的 iptables 规则命令。 "},{"title":"安装​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#安装","content":"可以使用apt快速安装。 apt install ufw  "},{"title":"启用/禁用​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#启用禁用","content":"使用以下命令来启用 UFW，并且会随着系统开启而启动。 ufw enable  使用以下命令来停止 UFW。 ufw disable  "},{"title":"默认行为​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#默认行为","content":"使用ufw default命令来配置默认行为，以下两条是 UFW 初始化的默认行为；默认拒绝所有入流量，允许所有出流量。 ufw default deny incoming ufw default allow outgoing  你可以使用ufw default命令来覆盖默认行为，使用allow/deny和incoming/outgoing/routed组合。 使用下面的命令来查看当前的默认行为。 ufw status verbose   "},{"title":"添加规则​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#添加规则","content":""},{"title":"放行/禁止端口​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#放行禁止端口","content":"以下命令用于放行 53 端口的 TCP 和 UDP 流量。 ufw allow 53  以下命令用于仅放行 53 端口的 TCP 流量。 ufw allow 53/tcp  以下命令用于仅放行 53 端口的 UDP 流量。 ufw allow 53/udp  还可以一次放行一个范围内的端口。 ufw allow 1000:2000/tcp  禁止命令就是用deny替代allow。 ufw deny 53 ufw deny 53/tcp ufw deny 53/udp ufw deny 1000:2000/tcp  "},{"title":"放行/禁止 IP​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#放行禁止-ip","content":"ufw allow from 1.2.3.4 ufw deny from 1.2.3.4  "},{"title":"删除规则​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#删除规则","content":"使用ufw delete命令来删除一条之前添加的规则。 ufw delete allow 53 ufw delete deny from 1.2.3.4  或者使用下面的命令列出添加的规则并编号，通过编号删除规则。 ufw status numbered ufw delete 2   "},{"title":"常用服务端口​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#常用服务端口","content":"在添加或删除关于端口的规则时，除了手动指出端口号之外，还可以通过服务名称来放行/禁止端口。 ufw allow ssh ufw deny ssh ufw delete allow ssh ufw delete deny ssh  服务名和端口号定义在/etc/services文件中。在其中有关ssh服务的部分是这样写的。 ssh 22/tcp # SSH Remote Login Protocol  UFW 会根据此文件内容管理端口。 常用的服务名称有ssh、http和https等。 "},{"title":"参考资料​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#参考资料","content":"Uncomplicated Firewall (ufw) - Debian WikiUFW - Community Help WikiUncomplicated Firewall - WikipediaAn Introduction to Uncomplicated Firewall (UFW) - Linux.comUFW Tutorial: How To Set Up a Firewall with UFW on Ubuntu 20.04 | ArubaCloud.comHow To Set Up a Firewall with UFW on Ubuntu 20.04 | DigitalOcean "},{"title":"在 HTML 中使用 Unicode 代码","type":0,"sectionRef":"#","url":"blog/use-unicode-in-html","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#前言","content":"在某些情况下需要在 HTML 中嵌入特殊符号，但是 HTML 实体中并不包含这些符号，或是该实体符号不能被浏览器正确渲染，可以通过 Unicode 代码代替这些字符，以达到在网页中正确渲染该字符的目的。HTML 实体代码和字符对应的 Unicode 代码可以参考 HTML Standard1。 "},{"title":"声明网页编码​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#声明网页编码","content":"为了能在网页中正常显示 Unicode 字符，该网页必须使用 Unicode 编码，如 UTF-8。可在meta标签里声明网页编码，并确保 HTTP 头也使用此编码。 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;  "},{"title":"使用 HTML 实体​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#使用-html-实体","content":"在 HTML Standard1 中可以看到该符号的名字是Aacute;，可以在其前方加上&amp;来表示 HTML 命名字符。 Á &lt;p&gt;&amp;Aacute;&lt;/p&gt;  但是并不是所有的命名字符都能被渲染出来，比如字符{。 &amp;lbrace; &lt;p&gt;&amp;lbrace;&lt;/p&gt;  "},{"title":"使用 Unicode 代码​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#使用-unicode-代码","content":"可以使用十六进制编码。 { &lt;p&gt;&amp;#x0007B;&lt;/p&gt;  也可以使用十进制编码。 { &lt;p&gt;&amp;#123;&lt;/p&gt;  "},{"title":"参考资料​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#参考资料","content":"HTML、CSS、JS 对 unicode 字符的不同处理 - 我是小茗同学 - 博客园HTML Unicode UTF-8 HTML Standard↩ "},{"title":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","type":0,"sectionRef":"#","url":"blog/use-pwsh-and-oh-my-posh3-on-windows","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#前言","content":"在 macOS 中用 zsh 配合 oh-my-zsh 可以打造出一个用的很舒服的终端，其实在 Windows 中也可以。 在 Windows 中可以用 pwsh1 和 oh-my-posh2 打造出一个好用的终端。 Windows 自带的 PowerShell 版本低，所以需要额外安装一个新版本的 pwsh，而不是用系统提供的。 oh-my-posh3 现在已基于 Go 语言重构，是一个跨平台的命令行工具，安装和配置方式和 oh-my-posh2 相比有些变化。 终端软件用的是 Windows Terminal3，这是一个现代化的、可自定义的好看的终端模拟器。 历史命令提示是通过 PowerShell 的 PSReadLine4 模组实现的。 "},{"title":"前置条件​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#前置条件","content":"Scoop5 是 Windows 上的一款基于 PowerShell 的包管理器，接下来的软件都是用 Scoop 安装的，因为它能很方便地管理软件和配置环境变量。Scoop 的安装及使用不在本文的讨论范围内。 由于多数软件来源于 Github，在网络不好的情况下可能会安装失败，请自行配置网络代理。 以下命令用于在 PowerShell 中配置代理，请自行替换地址和端口号。 $Env:http_proxy=&quot;http://127.0.0.1:11223&quot;; $Env:https_proxy=&quot;http://127.0.0.1:11223&quot;  Scoop 基于 Git，为了让 Scoop 能正常工作，请参考以下命令用于配置 Git 的代理。 git config --global http.proxy http://127.0.0.1:11223 git config --global https.proxy https://127.0.0.1:11223  "},{"title":"安装 pwsh​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-pwsh","content":"scoop install pwsh  "},{"title":"安装 Windows Terminal​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-windows-terminal","content":"scoop install windows-terminal  "},{"title":"安装 Cascadia Code 字体​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-cascadia-code-字体","content":"部分命令行字符需要正确配置字体才能正常显示，安装字体需要管理员权限，注意授权提示。 更多命令行字符字体可参考 nerd-fonts6 项目。 scoop install sudo scoop bucket add nerd-fonts sudo scoop install CascadiaCode-NF-Mono  "},{"title":"在 Windows Terminal 中集成 pwsh​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#在-windows-terminal-中集成-pwsh","content":"在 Window Terminal 中添加一个新的终端配置。命名为「PWSH」，命令为pwsh。设置字体为「CaskaydiaCove NF」。     保存此配置，在「启动」选项卡中把刚刚新增的「PWSH」配置文件设置为默认配置文件。  打开 PWSH，配置完成。  "},{"title":"安装 oh-my-posh3​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-oh-my-posh3","content":"目前，在 oh-my-posh 的官方文档中使用的安装命令为scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json，请不要使用该命令。 oh-my-posh3 已存在于 Scoop 的 main 仓库中，请安装此软件包，后面的配置命令跟包名有关。 scoop install oh-my-posh3  接下来编写 PWSH 的用户配置，以下命令用于创建一个配置文件并用记事本打开。该配置文件的作用是在每次 pwsh 初始化的时候自动执行其中的命令。 if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE  在弹出的记事本里写入 oh-my-posh 的初始化命令，该命令会在每次 pwsh 初始化的时候执行。 $env:POSH_GIT_ENABLED = $true oh-my-posh --init --shell pwsh --config &quot;$(scoop prefix oh-my-posh3)\\themes\\wopian.omp.json&quot; | Invoke-Expression  重新打开终端就能看到一个带主题的 PowerShell，如果有些字符显示不出来就是字体没有配置好。  "},{"title":"配置历史命令提示​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#配置历史命令提示","content":"在 PWSH 中执行命令，安装 PSReadLine 模组。在安装时请输入「Y」来确认安装。以下命令用于安装 PSReadLine，请在 PWSH 中执行而不是在 PowerShell 中。 Install-Module PSReadLine   然后编辑$PROFILE文件，在每次终端打开的时候对PSReadLine进行初始化。 notepad $PROFILE  在配置文件中附加上以下内容。 Set-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录 Set-PSReadlineKeyHandler -Key Tab -Function Complete # 设置 Tab 键补全 Set-PSReadLineKeyHandler -Key &quot;Ctrl+d&quot; -Function MenuComplete # 设置 Ctrl+d 为菜单补全和 Intellisense Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo # 设置 Ctrl+z 为撤销 Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向上键为后向搜索历史记录 Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward # 设置向下键为前向搜索历史纪录  保存配置文件，重启终端，就能看到一个带历史命令提示的终端了。  "},{"title":"更改 oh-my-posh 的主题​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#更改-oh-my-posh-的主题","content":"oh-my-posh 提供了多套主题可供选择，在 PWSH 中执行以下命令对所有主题进行预览。 Get-ChildItem -Path &quot;$(scoop prefix oh-my-posh3)\\themes\\*&quot; -Include '*.omp.json' | Sort-Object Name | ForEach-Object -Process { $esc = [char]27 Write-Host &quot;&quot; Write-Host &quot;$esc[1m$($_.BaseName)$esc[0m&quot; Write-Host &quot;&quot; oh-my-posh --config $($_.FullName) --pwd $PWD Write-Host &quot;&quot; }   其中以.omp结尾的是主题文件的名称，如果需要使用某个主题就替换掉$PROFILE文件中初始化命令中的配置文件名就可以了。 以下命令用于用记事本打开$PROFILE文件。 notepad $PROFILE  在打开的记事本中你会看到 oh-my-posh 的初始化命令。 oh-my-posh --init --shell pwsh --config &quot;$(scoop prefix oh-my-posh3)\\themes\\wopian.omp.json&quot; | Invoke-Expression  将你中意的主题名称替换命令中的wopian.omp，保存该配置文件然后重启终端就可以看到新主题的效果了。 "},{"title":"更改 Windows Terminal 的配色​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#更改-windows-terminal-的配色","content":"在 Windows Terminal 中默认有多套配色方案可选，这里推荐一套自定义的配色方案，来自于 Dracula7。 在 Windows Terminal 的设置页面中，点击「打开 JSON 文件」，在该文件的schemes数组中添加一个配色方案对象。 &quot;schemes&quot;: [ { &quot;name&quot;: &quot;Dracula&quot;, &quot;cursorColor&quot;: &quot;#F8F8F2&quot;, &quot;selectionBackground&quot;: &quot;#44475A&quot;, &quot;background&quot;: &quot;#282A36&quot;, &quot;foreground&quot;: &quot;#F8F8F2&quot;, &quot;black&quot;: &quot;#21222C&quot;, &quot;blue&quot;: &quot;#BD93F9&quot;, &quot;cyan&quot;: &quot;#8BE9FD&quot;, &quot;green&quot;: &quot;#50FA7B&quot;, &quot;purple&quot;: &quot;#FF79C6&quot;, &quot;red&quot;: &quot;#FF5555&quot;, &quot;white&quot;: &quot;#F8F8F2&quot;, &quot;yellow&quot;: &quot;#F1FA8C&quot;, &quot;brightBlack&quot;: &quot;#6272A4&quot;, &quot;brightBlue&quot;: &quot;#D6ACFF&quot;, &quot;brightCyan&quot;: &quot;#A4FFFF&quot;, &quot;brightGreen&quot;: &quot;#69FF94&quot;, &quot;brightPurple&quot;: &quot;#FF92DF&quot;, &quot;brightRed&quot;: &quot;#FF6E6E&quot;, &quot;brightWhite&quot;: &quot;#FFFFFF&quot;, &quot;brightYellow&quot;: &quot;#FFFFA5&quot; } ]  保存该 JSON 文件，重启 Windows Terminal，在 PWSH 的外观配置中选择新添加的 Dracula 配色方案。前文中我用的配色方案就是 Dracula。  "},{"title":"在 VS Code 里使用​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#在-vs-code-里使用","content":"在 VS Code 的配置文件settings.json中加入以下配置。 &quot;terminal.integrated.profiles.windows&quot;: { &quot;Windows PowerShell&quot;: { &quot;path&quot;: &quot;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe&quot; }, &quot;PWSH&quot;: { &quot;path&quot;: &quot;pwsh&quot; } }, &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;PWSH&quot;, &quot;terminal.integrated.fontFamily&quot;: &quot;'CaskaydiaCove NF'&quot;  PowerShell/PowerShell: PowerShell for every system!↩Home | Oh My Posh↩microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place!↩PowerShell/PSReadLine: A bash inspired readline implementation for PowerShell↩Scoop↩Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher↩Dark theme for Windows Terminal and 218+ apps — Dracula↩ "},{"title":"使用 Caddy 自动申请泛域名证书","type":0,"sectionRef":"#","url":"blog/wildcard-certificates-with-caddy","content":"","keywords":""},{"title":"泛域名证书​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#泛域名证书","content":"在 Caddy 中书写 Matcher 时可以使用通配符，如*.example.com，Caddy 会自动为你申请泛域名证书，但是需要合适的配置。 *.example.com包括foo.example.com、bar.example.com等其它二级域名，但是不包括顶级域名example.com；同时不包括其它等级的域名，只包括同等级域名。 通配符*只能放在最左边，如*.example.com、*.foo.example.com和*.bar.example.com等；不能写为foo.*.example.com。 "},{"title":"需要做的事情​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#需要做的事情","content":"不像单域名证书可以使用文件验证的方式来完成申请，泛域名证书要求 DNS 验证，这要求你得有权限修改该域名的 DNS 记录，并且你的 DNS 服务商要被 Caddy 支持才可以。 Caddy 对 DNS 的修改功能是由 Caddy 的 DNS 模组实现的，使用模组可以很方便地扩展 Caddy。你可以在 caddy-dns 的仓库列表 1 中查看你的 DNS 服务商是否受支持。 Caddy 的官方 Docker 镜像 2 并不包括任何模组，只有原版的 Caddy，如果需要使用带模组的镜像话需要自己构建。Caddy 提供了 xcaddy3 工具来帮助你编译带模组的 Caddy，并且也提供了使用示例 2，参考这些说明可以很方便地构建自己的 Caddy 镜像。 下文中记录了我用过的两个 DNS 服务商模组，分别是 Cloudflare 和 DNSPod。 "},{"title":"Cloudflare 例子​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#cloudflare-例子","content":""},{"title":"编写 Dockerfile​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#编写-dockerfile","content":"Dockerfile文件内容如下，用于构建 Docker 镜像。 FROM caddy:builder AS builder RUN xcaddy build --with github.com/caddy-dns/cloudflare FROM caddy COPY --from=builder /usr/bin/caddy /usr/bin/caddy  每行命令的解释如下。 使用caddy:builder镜像，起别名为builder，该镜像中包含了go环境和xcaddy工具；使用xcaddy来编译caddy，并使用--with参数指定附加的模组，该参数可以重复使用，意味着你可以附加多个模组，这里使用了github.com/caddy-dns/cloudflare4；使用原版的caddy镜像；复制在builder镜像中你自己编译的caddy覆盖掉原版caddy，并使用此镜像作为最终镜像。 "},{"title":"获取 Cloudflare Token​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#获取-cloudflare-token","content":"在 Cloudflare 的 API Tokens5 页面中创建一个 API Token。  选择使用编辑 DNS 模板来创建 API Token。  在 Zone Resources 中选择目标域名。  确认之后会给你生成一个 Token，你需要保存它。 "},{"title":"编写 Caddyfile​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#编写-caddyfile","content":"Caddyfile文件内容如下，作为 Caddy 的配置文件。 { email example@gmail.com } *.example.com { tls { dns cloudflare &lt;CF_API_TOKEN&gt; } @foo host foo.example.com handle @foo { reverse_proxy localhost:1000 } @bar host bar.example.com handle @bar { reverse_proxy localhost:2000 } handle { abort } } example.com { reverse_proxy localhost:3000 } foo.bar.example.com { reverse_proxy localhost:4000 }  1-3：全局配置区块，其中email指定申请证书时用的邮箱，写你自己的邮箱；5-23：*.example.com泛域名配置； 7：指定 DNS 服务商为 Cloudflare 并且配置 Cloudflare 的 API Token，替换&lt;CF_API_TOKEN&gt;为你自己的；10-18：使用具名 Matcher 和handle指令来配置每个使用泛域名证书的站点；20-22：其它未定义的域名直接丢弃连接，这需要写在所有站点后面。 25-31：其它不匹配泛域名的域名配置，还和正常使用一样。 "},{"title":"使用 Docker Compose 运行​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#使用-docker-compose-运行","content":"docker-compose.yml文件内容如下，用于快速运行容器。 version: &quot;3&quot; services: caddy: build: . restart: unless-stopped network_mode: host volumes: - data:/data - ./Caddyfile:/etc/caddy/Caddyfile volumes: data:  当前的目录结构如下。 caddy ├── Dockerfile ├── Caddyfile └── docker-compose.yml  在 caddy 目录下运行命令。Docker Compose 会根据 Dockerfile 构建镜像并运行。 docker-compose up --build -d  "},{"title":"DNSPod 例子​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#dnspod-例子","content":"和使用 Cloudflare 差不多。 "},{"title":"编写 Dockerfile​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#编写-dockerfile-1","content":"FROM caddy:builder AS builder RUN go env -w GOPROXY=https://goproxy.cn,direct RUN xcaddy build --with github.com/caddy-dns/dnspod FROM caddy COPY --from=builder /usr/bin/caddy /usr/bin/caddy  这个 Dockerfile 文件的内容和使用 Cloudfalre 时 Dockerfile 的内容有些许不同。 第 2 行指定了go get使用国内代理，因为我的这台服务器在国内，在下载依赖的时候遇到了一些网络问题，如果你在使用go get的时候也遇到了网络问题可以试试添加这行命令，在xcaddy build命令之前；第 3 行使用xcaddy来编译caddy，并使用--with参数指定附加的模组，该参数可以重复使用，意味着你可以附加多个模组，这里使用了github.com/caddy-dns/dnspod6； "},{"title":"获取 DNSPod Token​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#获取-dnspod-token","content":"在 DNSPod API 密钥页面 7 中生成一个 Token，在生成 Token 之后你需要保存下来，它只会完整地显示一次，以后都不能完整地查看了。  需要注意的是 DNSPod Token 使用时有些不一样，你申请的密钥有 ID 和 Token，在使用时需要把两者组合起来，中间用英文逗号分隔，如&lt;id&gt;,&lt;token&gt;，在使用时你需要将内容替换为自己的 ID 和 Token，更多说明请参考 DNSPod 的 API 使用文档 8。 "},{"title":"编写 Caddyfile​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#编写-caddyfile-1","content":"{ email example@gmail.com } *.example.com { tls { dns dnspod &lt;DNSPOD_TOKEN&gt; } @foo host foo.example.com handle @foo { reverse_proxy localhost:1000 } @bar host bar.example.com handle @bar { reverse_proxy localhost:2000 } handle { abort } } example.com { reverse_proxy localhost:3000 } foo.bar.example.com { reverse_proxy localhost:4000 }  第 7 行不一样，指定了 DNS 服务商为dnspod，并且你需要替换掉&lt;DNSPOD_TOKEN&gt;为你自己的。需要注意 DNSPod 的 API Token 格式特殊，是由 ID 和 Token 组合在一起，并用英文逗号分隔。 其它内容和使用 Cloudflare 时一样，请参考上文。 "},{"title":"使用 Docker Compose 运行​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#使用-docker-compose-运行-1","content":"和使用 Cloudflare 时一样，请参考上文。 "},{"title":"后记​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#后记","content":"更多使用帮助请参考其官方文档 9，镜像构建出错请查看构建日志，Caddy 运行时出错请查看 Caddy 镜像的日志。 caddy-dns↩Caddy - Official Image | Docker Hub↩caddyserver/xcaddy: Build Caddy with plugins↩caddy-dns/cloudflare: Caddy module: dns.providers.cloudflare↩API Tokens | Cloudflare↩caddy-dns/dnspod↩API 密钥 - DNSPod-免费智能 DNS 解析服务商 - 电信网通教育网，智能 DNS↩密钥管理 - DNSPod 服务与支持↩Common Caddyfile Patterns — Caddy Documentation↩ "},{"title":"Zerotier 异地组网","type":0,"sectionRef":"#","url":"blog/zerotier","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#前言","content":"Zerotier1 是一个优秀的异地组网解决方案。其优点是组网灵活、不需要更改现有网络结构，支持 P2P 和转发。 Zerotier 使用也不是没有限制，免费版本的最多加入 50 个客户端，不过对于个人来说肯定够用了。 "},{"title":"控制台​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#控制台","content":"在控制台 2 注册并登陆。 在创建网络后会得到一个 Network ID，此 ID 是唯一的，是客户端加入此网络所需的唯一参数。  在网络管理页面中，Access Control 控制客户端认证方式，如果选择PRIVATE则每个客户端的加入都需要在此页面经由你允许。  在 IPv4 Auto-Assign 中，可以对客户端的 IP 段进行配置，不和你原来的网络地址冲突即可。  在 Members 中你可以管理该网络下的所有客户端，勾选客户端对应的Auth?选框即可让客户端加入此网络。每个客户端在加入的时候会自动分配一个 IP 地址，你还可以手动分配客户端的 IP 地址。  在多个客户端加入网络后，即使处于不同的网络环境下，客户端都可以通过分配到的 IP 互相访问。 "},{"title":"客户端​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#客户端","content":"Zerotier 在常用平台上都有客户端，有图形化的有命令行的。  "},{"title":"自动 NAT​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#自动-nat","content":"在前面的方案中， 如果多个机器互相访问就需要每个机器都安装 Zerotier 客户端并加入同一个网络。 借助 OpenWrt 和 Zerotier 可以暴露整个局域网到 Zerotier 网络中，只需要 OpenWrt 中的 Zerotier 加入网络即可。 勾选「自动允许客户端 NAT」即可。  许多 OpenWrt 的发行版都集成了此软件包。可以参考如下 Telegram 频道： Telegram: Contact @OpenWRTcnTelegram: Contact @aixiaoshaoTelegram: Contact @passwallOpenWRT233 OpenWrt 不需要作为你的主路由，它可以通过 LAN 口接入你现有的局域网，关闭 LAN 口的 DHCP 服务，作为旁路由使用。 你还需要在 Zerotier 控制台中配置静态路由。  在添加静态路由的时候Destination填局域网的网络地址，(Via)为下一跳地址，即 OpenWrt 路由器的 Zerotier 地址。 上面的静态路由配置将192.168.10.0/24局域网和192.168.11.0/24局域网暴露在 Zerotier 网络中。172.22.39.15和172.22.105.60分别是两个 OpenWrt 路由器在 Zerotier 网络中的地址，这两个路由器均配置了自动允许客户端 NAT。 这样做的优点是管理方便，不需要在每个机器上安装客户端并且加入网络。并且即使你在使用移动网络的时候可以直接访问到家里局域网的 IP，并且还是通过局域网 IP 访问，并不需要修改软件配置。 大致的网络拓扑图如下。在外使用移动网络的情况下，你可以使用192.168.10.0/24或192.168.11.0/24网段的内网地址访问局域网 A 或局域网 B 内的资源。 如果局域网 A 中的某台设备需要访问局域网 B 中的资源，还是需要在该设备上安装 Zerotier 客户端，并且加入统一 Zerotier 网络，然后就可以通过192.168.11.0/24的内网 IP 地址来访问局域网 B 中的资源了。  ZeroTier – Global Area Networking↩ZeroTier Central↩ "},{"title":"VPS 相关书签","type":0,"sectionRef":"#","url":"docs/bookmarks/vps","content":"","keywords":""},{"title":"监控​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#监控","content":"欢迎来到古博 PING - 古博 PING "},{"title":"脚本​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#脚本","content":""},{"title":"aff​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#aff","content":"VPS 百科Telegram: Contact @vpscangVPS 大全 - 你的 VPS 仓库，提供 VPS 列表，库存，机房，价格等信息美国 vps 低至月付 1 刀，低价之王，超高性价比，VirMach 官方测速地址，各机房测试 IP – V2RaySSR 综合网TCM VPS 测评--云主机 VPS 交流推荐 "},{"title":"工具​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#工具","content":"Fake Person: male| Fake Person Generator/Fake Name GeneratorReggy - Chrome Web Store "},{"title":"有意思的项目","type":0,"sectionRef":"#","url":"docs/bookmarks/interesting-projects","content":"有意思的项目 名称\t备注\t标签\t链接restic\tGo 语言实现的、跨平台的、支持多种备份目的地类型的备份工具。\t备份\trestic/restic: Fast, secure, efficient backup program autorestic\t在 Docker 容器中定时运行 restic 备份任务。\t备份\tcupcakearmy/autorestic: Config driven, easy backup cli for restic. duplicati\tC# 语言实现的、跨平台的、支持多种备份目的地类型和备份策略的备份工具，有一个基于 Web 的 GUI。\t备份\tduplicati/duplicati: Store securely encrypted backups in the cloud! MinIO\t自建对象存储服务，兼容 Amazon S3 协议。\t存储\tminio/minio: High Performance, Kubernetes Native Object Storage ZFile\t基于 Java 的在线网盘程序，支持的后端较多，特别有 OneDrive。\t存储\tzhaojun1998/zfile: 在线云盘、网盘、OneDrive、云存储、私有云、对象存储、h5ai vaultwarden\tBitwarden server API 的非官方实现，兼容官方客户端。和官方的服务端相比自建很方便，只需要运行一个容器即可。\t存储\tdani-garcia/vaultwarden: Unofficial Bitwarden compatible server written in Rust, formerly known as bitwarden_rs Rclone\t支持各种网络存储的 rsync。\t传输\trclone/rclone: &quot;rsync for cloud storage&quot; - Google Drive, S3, Dropbox, Backblaze B2, One Drive, Swift, Hubic, Wasabi, Google Cloud Storage, Yandex Files transfer.sh\t通过 HTTP 请求快速上传/分享临时文件，可以自建。\t传输\tdutchcoders/transfer.sh: Easy and fast file sharing from the command-line. croc\t命令行文件传输工具，跨平台，不需要公网 IP。\t传输\tGitHub - schollz/croc: Easily and securely send things from one computer to another Bark\t可以自建的消息推送服务，可以直接向你的 iOS 设备发送系统通知。\t传输\tFinb/bark-server: Backend of Bark NGINX Config\t在线生成 Nginx 配置文件。\tWeb\tdigitalocean/nginxconfig.io: ⚙️ NGINX config generator on steroids 💉 Certbot\t基于 ACME 协议的 TLS 证书自动签发工具，证书来自 Let’s Encrypt。\tWeb\tcertbot/certbot: Certbot is EFF's tool to obtain certs from Let's Encrypt and (optionally) auto-enable HTTPS on your server. It can also act as a client for any other CA that uses the ACME protocol. Caddy\t以自动 HTTP、简易配置而出名的跨平台 Web 服务器，用 Go 语言实现。\tWeb\tcaddyserver/caddy: Fast, multi-platform web server with automatic HTTPS Adminer\t基于 PHP 的单文件数据库管理工具。\t数据库\tvrana/adminer: Database management in a single PHP file test_db\t数据库测试数据。\t数据库\tdatacharmer/test_db: A sample MySQL database with an integrated test suite, used to test your applications and database servers vxe-table\tVue 表格和表单组件，非常丰富。\tVue\tx-extends/vxe-table: vxe-table vue 表格解决方案 Vue.Draggable\tVue 可拖拽控件。\tVue\tSortableJS/Vue.Draggable: Vue drag-and-drop component based on Sortable.js Portainer\t轻量级 Docker GUI，基于 Web。以 Docker 容器的方式运行。\tDocker\tportainer/portainer: Making Docker and Kubernetes management easy. Watchtower\t自动更新 Docker 镜像，并用相同的创建命令重新用新版本镜像创建容器。\tDocker\tcontainrrr/watchtower: A process for automating Docker container base image updates. composerize\t把docker run命令转换为 docker-compose.yml。\tDocker\tmagicmark/composerize: 🏃→🎼 docker run asdlksjfksdf &gt; docker-composerize up Dozzle\t在网页中查看 Docker 容器的日志。\tDocker\tamir20/dozzle: Realtime log viewer for docker containers. lazydocker\t在命令行中带 UI 界面管理 Docker 容器和其它 Docker 资源。\tDocker\tjesseduffield/lazydocker: The lazier way to manage everything docker PlantUML\t声明式绘图工具，Java 实现。\t绘图\tplantuml/plantuml: Generate UML diagram from textual description Mermaid\t声明式绘图工具，JavaScript 实现，可以在浏览器中直接渲染，支持的图种类较少。\t绘图\tmermaid-js/mermaid: Generation of diagram and flowchart from text in a similar manner as markdown Foam\t个人知识库/笔记整理软件，基于 VS Code 插件。\t笔记\tfoambubble/foam: A personal knowledge management and sharing system for VSCode 思源笔记\t国产的个人知识库/笔记整理软件。类似于 Notion，以块为基础结构。可以做到完全离线工作，数据文件都在本地，是 JSON 格式而不是 Markdown。基于 Electron。\t笔记\tsiyuan-note/siyuan: 📕 SiYuan is a local-first personal knowledge management system, supports fine-grained block-level reference, and Markdown WYSIWYG. Flame\t自建的个人书签网页。是一个 JavaScript 应用，数据用 SQLit 储存。\t笔记\tpawelmalak/flame: Flame is self-hosted startpage for your server. Easily manage your apps and bookmarks with built-in editors. Rubick\t基于 Electron 的开源桌面工具箱，和 uTools 的设计很像，目前正在火热开发阶段，优势是开源。\t工具\tclouDr-f2e/rubick: 🔧 基于 electron 的开源工具箱，自由集成丰富插件。 Ventoy\tU 盘启动工具，特点是多启动，不用为每个启动镜像制作一个 U 盘启动了，所有镜像都塞在 U 盘里，启动的时候可以选择。\t工具\tventoy/Ventoy: A new bootable USB solution. mitmproxy\t网络抓包工具，有命令行版本和基于 Web 的 GUI 版本。\t抓包\tmitmproxy/mitmproxy: An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers. ja-netfilter\t基于 Java Agent 的网络工具，可以拦截 Java 程序的网络通讯，并且对其修改。\t抓包\tja-netfilter/ja-netfilter: A javaagent framework Flameshot\t功能强大的、易用的截图工具。\t图像\tflameshot-org/flameshot: Powerful yet simple to use screenshot software Terminalizer\t记录命令行历史，以 GIF 图片或网页播放器分享。\t图像\tGitHub - faressoft/terminalizer: 🦄 Record your terminal and generate animated gif images or share a web player asciinema\t记录命令行历史，可以回放。\t图像\tasciinema/asciinema: Terminal session recorder 📹 neofetch\t在终端显示系统信息。\t图像\tdylanaraps/neofetch: 🖼️ A command-line system information tool written in bash 3.2+ Macast\t运行在电脑上的 DLNA 客户端。\t图像\txfangfang/Macast: Macast is a cross-platform application which using mpv as DLNA Media Renderer. 程序员做饭指南\t程序员做饭指南，步骤详细，食材及调味料的用量描述精确，可以一试。要是做饭有 Docker 就好了。\t生活\tAnduin2017/HowToCook: 程序员在家做饭方法指南。Programmer's guide about how to cook at home (Chinese). lazygit\t懒人用 Git，在命令行中以图形化的方式使用 Git。\tGit\tjesseduffield/lazygit: simple terminal UI for git commands Tabby\t终端模拟器，SSH 客户端，SFTP 客户端。\tSSH\tEugeny/tabby: A terminal for a more modern age 中文文案排版指北\t中文文案排版建议。\t排版\tsparanoid/chinese-copywriting-guidelines: Chinese copywriting guidelines for better written communication／中文文案排版指北 typo.css\t适合中文阅读的网页排版样式。\t排版\tsofish/typo.css: 中文网页重设与排版：一致化浏览器排版效果，构建最适合中文阅读的网页排版 pangu.js\t在中英文之间自动插入空格。\t排版\tvinta/pangu.js: Paranoid text spacing in JavaScript Xbox 下载助手\t帮助解决 Xbox 下载问题，如下载域名测速、电脑下载回传至 Xbox。\t游戏\tskydevil88/XboxDownload: Xbox 下载助手，支持 Xbox、微软商店、PSN、NS、EA Desktop &amp; Origin、战网国际服、Epic 下载加速。 SGS\t三国杀。\t游戏\tdonle/sgs noname\t三国杀。\t游戏\tlibccy/noname RSSHub\t通过编写规则将不支持 RSS 的网站转为 RSS 订阅。\tRSS\tDIYgod/RSSHub: 🍰 Everything is RSSible FreshRSS\tRSS 下载器、网页 RSS 阅读器，支持 Fever API 和 Google Reader API，所以可以使用兼容这些 API 的客户端。\tRSS\tFreshRSS/FreshRSS: A free, self-hostable aggregator… dracula-theme\t提供很多软件的统一风格的黑暗模式主题。 dracula/dracula-theme: 🧛🏻‍♂️ One theme. All platforms. (github.com) WiFi Card\t生成含有 WIFI 信息的二维码，可以扫描以快速连接 WIFI。 bndw/wifi-card: 📶 Print a QR code for connecting to your WiFi (wificard.io) Modern Unix\t收集了一些能代替 Unix 中的部分命令工作的现代化软件。 ibraheemdev/modern-unix: A collection of modern/faster/saner alternatives to common unix commands. zx\t用 JavaScript 编写服务器脚本，适合对 Bash 编程不太精通的前端开发者。 google/zx: A tool for writing better scripts 中国程序员容易发音错误的单词 shimohq/chinese-programmer-wrong-pronunciation: 中国程序员容易发音错误的单词 Administrative-divisions-of-China\t行政区划代码。 modood/Administrative-divisions-of-China: 中华人民共和国行政区划：省级（省份）、地级（城市）、县级（区县）、乡级（乡镇街道）、村级（村委会居委会），中国省市区镇村二级三级四级五级联动地址数据。 Glances\tPython 语言实现的系统信息以及资源占用查看工具，还可以兼容 Docker 容器的资源占用。可以在本机运行，可以以 C/S 方式运行，可以以 Web 服务器方式运行。 nicolargo/glances: Glances an Eye on your system. A top/htop alternative for GNU/Linux, BSD, Mac OS and Windows operating systems.","keywords":""},{"title":"CMake","type":0,"sectionRef":"#","url":"docs/notes/c/cmake","content":"CMake","keywords":""},{"title":"C 语言","type":0,"sectionRef":"#","url":"docs/notes/c/","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#参考资料","content":"C 语言教程 - 网道C 语言教程 | 菜鸟教程C reference - cppreference.com "},{"title":"C 简介​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#c-简介","content":""},{"title":"程序​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#程序","content":"一系列有序指令的集合，目的是执行某些操作或解决某个特定问题。 "},{"title":"C 语言发展历程​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#c-语言发展历程","content":" 需要注意的几个版本： ANSI C（标准 C）C89C99 "},{"title":"C 语言的特点​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#c-语言的特点","content":"代码级别的跨平台允许直接访问物理地址，对硬件进行操作结构化程序设计，具有变量作用域以及递归功能的过程式语言参数可以是指传递，也可以是指针传递没有对象，可以用结构体预编译处理 "},{"title":"程序结构​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#程序结构","content":""},{"title":"基本结构​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#基本结构","content":"C 程序主要包括以下部分： 预处理器指令函数变量语句 &amp; 表达式注释 "},{"title":"程序入口​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#程序入口","content":"程序的入口是main函数。 int main(){ // 方法体 }  "},{"title":"开发过程​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#开发过程","content":"编辑（.c/.h）编译（.obj）链接（.exe）运行 "},{"title":"编译&执行命令​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#编译执行命令","content":"gcc test1.c -o main.out ./main.out  "},{"title":"基本语法​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#基本语法","content":"C 程序的入口是main函数C 程序源代码文件的扩展名为.c头文件的扩展名为.h语法区分大小写每条执行语句以;结束 "},{"title":"数据类型​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#数据类型","content":"C Tutorials - data types in C Programming Language  每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间。 基本类型，它们是算术类型，包括两种类型：整数类型和浮点类型。枚举类型，它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。void，表明没有可用的值。派生类型，包括指针类型、数组类型、结构类型、共用体类型和函数类型。 "},{"title":"字符类型​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#字符类型","content":"在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义。 \\t，制表位\\n，换行符\\\\，\\\\&quot;，&quot;\\'，'\\r，回车 "},{"title":"整数类型​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#整数类型","content":"前缀： 0x，16 进制0，8 进制无前缀，10 进制 后缀： U，unsigned，无符号整数L，long，长整数 "},{"title":"枚举​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#枚举","content":"enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN };  枚举本质上就是整形。默认情况下编号从 0 开始。 "},{"title":"浮点类型​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#浮点类型","content":"float是单精度浮点类型，1 位符号，8 位指数，23 位小数。  double是双精度浮点值。双精度是 1 位符号，11 位指数，52 位小数。  可以使用科学计数法表示，如3.14e-11，表示3.14×(10)−113.14\\times(10)^{-11}3.14×(10)−11。 "},{"title":"void类型​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#void类型","content":""},{"title":"变量​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#变量","content":""},{"title":"初始值​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#初始值","content":"局部变量不会被自动初始化；全局变量会被自动初始化。 数据类型\t初始化默认值int\t0 char\t'\\0' float\t0 double\t0 pointer\tNULL "},{"title":"常量​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#常量","content":""},{"title":"字面量​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#字面量","content":"写出来的数字、字符、字符串都是字面量，是不变的。 "},{"title":"定义常量​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#定义常量","content":"#define​ #define identifier value  这是一个预处理命令，实现原理是在编译时进行字符串替换。注意 value 使用括号包围起来，不然在某些地方会产生意料之外的结果。 const​ const type variable = value;  这是一个关键字，用于把变量所在的内存区域设置为只读。可以用在参数列表中，在该方法中，该参数不能被修改。 "},{"title":"判断​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#判断","content":""},{"title":"switch​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#switch","content":"switch(expression){ case constant-expression : statement(s); break; /* 可选的 */ case constant-expression : statement(s); break; /* 可选的 */ /* 您可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s); }  switch 语句中的 expression 是一个常量表达式，必须是一个整型或枚举类型。 "},{"title":"循环​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#循环","content":""},{"title":"goto​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#goto","content":"goto label; // .. // . label: statement;  label 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 goto 语句的前面或者后面。 "},{"title":"函数​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#函数","content":"函数的参数传递都是值传递，没有引用传递。即使是指针，传递的也是指针值的复制。所以直接修改局部变量的指针地址是不会影响到外部的变量的。 传递结构体的时候也是传递了一个复制，而不是引用；包括结构体中的指针，也是传递了一个指针的复制。 "},{"title":"数组​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#数组","content":"// 逐个初始化 double balance[5]; balance[4] = 50.0; // 使用初始化语句 double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0}; // 可以省略掉长度 double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};  数组名就是一个指针，指向数组的首地址。 "},{"title":"指针​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#指针","content":""},{"title":"操作符​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#操作符","content":"&amp;，取地址操作符*，取实例操作符 "},{"title":"变量指针​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#变量指针","content":"指针变量中保存着一个内存地址。 "},{"title":"指向数组的指针​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#指向数组的指针","content":"数组名就是一个指针，指向数组的首地址。 "},{"title":"多重指针​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#多重指针","content":"指针中的内存地址指向的还是指针。多维数组就是多重指针。 "},{"title":"函数指针​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#函数指针","content":"int max(int a, int b); int (*fun_ptr)(int,int) = max; // 声明一个指向同样参数、返回值的函数指针类型 fun_ptr(1, 2); // 通过 fun_ptr 调用 max 函数  声明一个函数指针与声明一个变量类似；其中fun_ptr是变量名，前面的int是返回值类型，后面的是参数列表，参数列表可以不用写参数名称，只与参数类型和顺序有关。 通过函数指针可以实现回调函数。即将其声明在函数参数中，在函数内部可以调用传递进来的方法。 #include &lt;stdio.h&gt; int max(int a, int b) { return a &gt; b ? a : b; } void callback(int (*p_max)(int, int)) { printf(&quot;%d\\n&quot;, p_max(1, 2)); } int main() { callback(max); }  "},{"title":"指针与算术运算符​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#指针与算术运算符","content":"可以对指针使用算数运算，如+、-、*、/；单位偏移量和指针类型有关，如int指针的单位偏移量为 4。可以使用这个特性来计算出每个数组元素的地址，可以通过指针访问该地址。 指针也可以用比较运算符进行比较。 "},{"title":"字符串​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#字符串","content":"字符串实际上是字符数组，字符串以'\\0'结尾，无论该元素后是否还有字符。  在使用字符串常量时不需要手动在末尾放一个'\\0'，编译器会自动给你加。 "},{"title":"struct结构体​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#struct结构体","content":"把多种类型的数据声明在一起，结构体所占内存长度是其中最大字段大小的整数倍。 使用.来访问结构体成员；在通过结构体指针访问结构体成员时可以使用-&gt;。不用通过*符号取到结构体实力再操作成员，是一种简便写法。 struct Books book1; struct Books *struct_pointer; struct_pointer = &amp;book1; // -&gt; struct_pointer-&gt;title; // . (*struct_pointer).title;  "},{"title":"union共用体​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#union共用体","content":"共用体的声明和使用与结构体类似。区别是共用体的长度是其内最大成员的长度；其内所有成员共用同一个内存区域来存储数据，修改一个成员的内容可能会对其它数据造成影响；在读取成员值的时候会按照该成员类型的长度来读取对应长度的内存值来解析为对应类型。 "},{"title":"typedef​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#typedef","content":"给类型取新名字。 "},{"title":"I/O​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#io","content":"在&lt;stdio.h&gt;中声明有三个FILE *，把输入/输出当作文件处理。 stdin，标准输入stdout，标准输出stderr，错误输出 "},{"title":"预处理命令​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#预处理命令","content":"C 预处理器 | 菜鸟教程 "},{"title":"include​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#include","content":"#include &lt; &gt;引用的是编译器的类库路径里面的头文件；#include &quot; &quot;引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件。 "},{"title":"错误处理​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#错误处理","content":"int atexit(void (*func)(void))，&lt;stdlib.h&gt;，注册程序退出时的回调函数extern int errno，&lt;errno.h&gt;，存储最后一个错误号char *strerror(int errnum)，&lt;string.h&gt;，把错误号转为字符串 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; void ae() { if (errno) { fprintf(stderr, &quot;%s\\n&quot;, strerror(errno)); } } int main() { atexit(ae); // ... }  "},{"title":"可变参数​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#可变参数","content":"在&lt;stdarg.h&gt;中。 "},{"title":"内存管理​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#内存管理","content":"这些函数在&lt;stdlib.h&gt;中。 void *malloc(int num);void *calloc(int num, int size);void free(void *address); "},{"title":"标准库​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#标准库","content":""},{"title":"stdio.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#stdioh","content":"结构​ FILE 成员​ 声明有三个FILE *，把输入/输出当作文件处理。 stdin，标准输入stdout，标准输出stderr，错误输出 函数​ int printf(const char *format, ...);，格式化字符串并向stdout输出int fprintf(FILE *stream, const char *format, ...);格式化字符串，可以向指定的流输出int sprintf(char *buffer, const char *format, ...);，格式化字符串，写入另一个字符串int scanf( const char *format, ... );int fscanf( FILE *stream, const char *format, ... );int sscanf( const char *buffer, const char *format, ... ); 格式化参数\t备注\tPrecision%\t%本身 %c\tchar %s\t字符串\t指定最大输出长度 %d/%i\tint %u\tunsigned int\t指定小数位数，默认是 6 %f/%F\tfloat %e/%E\t十进制科学计数法 %x/%X\t十六进制 %p\t输出指针内的内存地址\t int getchar(void);，从标准输入读一个字符int getc( FILE *stream );，从指定流读一个字符int putchar(int ch);，写出一个字符到标准输出int putc( int ch, FILE *stream );，写出一个字符到指定流char *gets( char *str );，字符串char *fgets( char *str, int count, FILE *stream );int puts( const char *str );int fputs( const char *str, FILE *stream ); 文件读写： FILE *fopen( const char *filename, const char *mode );int fclose( FILE *stream );size_t fread( void *buffer, size_t size, size_t count, FILE *stream );，二进制读size_t fwrite( const void *restrict buffer, size_t size, size_t count, FILE *restrict stream );，二进制写int fseek( FILE *stream, long offset, int origin );，移动文件指针 fopen访问模式mode的值可以是下列值中的一个。 文本模式\t二进制模式\t备注r\trb\t打开已有文件，只读 w\twb\t读写，如果文件存在则清空文件覆盖写入 a\tab\t读写，追加写入 r+\tr+b/rb+\t读写 w+\tw+b/wb+\t读写，存在则清空，不存在则创建 a+\ta+b/ab+\t读写，从头读，追加写 fseek中origin有以下 3 个可选值。 SEEK_SET，以文件开头为基准SEEK_CUR，以当前指针位置为基准SEEK_END，以文件结束为基准 "},{"title":"stdlib.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#stdlibh","content":"系统： int system( const char *command );，执行系统命令void exit( int exit_code ); 随机数： void srand( unsigned seed );，重置随机数种子int rand();，生成0到`RAND_MAX 的一个随机数 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main(void) { srand(time(NULL)); // use current time as seed for random generator int random_variable = rand(); printf(&quot;Random value on [0,%d]: %d\\n&quot;, RAND_MAX, random_variable); // roll a 6-sided die 20 times for (int n=0; n != 20; ++n) { int x = 7; while(x &gt; 6) x = 1 + rand()/((RAND_MAX + 1u)/6); // Note: 1+rand()%6 is biased printf(&quot;%d &quot;, x); } }  // Possible output Random value on [0,2147483647]: 448749574 3 1 3 1 4 2 2 1 3 6 4 4 3 1 6 2 3 2 6 1  "},{"title":"stdbool.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#stdboolh","content":"定义了bool类型和true/false。 true=1false=0 "},{"title":"string.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#stringh","content":"类型转换函数： int atoi( const char *str );，字符串转intlong atol( const char *str );long long atoll( const char *str );double atof( const char* str ); 字符串操作： void *memchr(const void *str, int c, size_t n)，字符串中搜索某个字符char *strchr(const char *str, int c)int memcmp(const void *str1, const void *str2, size_t n)，字符串比较int strcmp(const char *str1, const char *str2)void *memcpy(void *str1, const void *str2, size_t n)，复制字符串char *strcpy(char *dest, const char *src)void *memmove(void *str1, const void *str2, size_t n)，移动字符串char *strcat(char *dest, const char *src)，连接两个字符串char *strerror(int errnum)，把错误号转为对应的错误消息size_t strlen(const char *str)，字符串长度，以\\0为字符串结束char *strtok(char *str, const char *delim)，分隔字符串char *strstr(const char *haystack, const char *needle)，字符串中查找子串 "},{"title":"time.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#timeh","content":"结构​ struct tm { int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月，范围从 0 到 11 */ int tm_year; /* 自 1900 年起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ };  成员​ CLOCKS_PER_SEC，表示每秒的处理器时钟个数 函数​ clock_t clock(void)，返回自从程序启动起，所经过的处理器时钟char *asctime(const struct tm *timeptr)，将tm结构解析为字符串char *ctime(const time_t *timer)，把时间戳转换为字符串double difftime(time_t time1, time_t time2)，计算两个时间戳之间的差值struct tm *gmtime(const time_t *timer)，时间戳转tm结构，用 UTC 时间，时区为+0struct tm *localtime(const time_t *timer)，时间戳转tm，用本地时区time_t mktime(struct tm *timeptr)，tm转时间戳，用本地时区time_t time(time_t *seconds)，得到当前时间戳size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)，tm转时间戳，可以自定义格式 "},{"title":"ctype.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#ctypeh","content":"类型判断函数。 "},{"title":"math.h​","type":1,"pageTitle":"C 语言","url":"docs/notes/c/#mathh","content":"double modf(double x, double *integer)，分解整数和小数部分double fabs(double x)，求绝对值double fmod(double x, double y)，求余数double sqrt(double x)，求平方根，x\\sqrt{x}x​double pow(double x, double y)，幂运算，x12=xx^{\\frac{1}{2}}=\\sqrt{x}x21​=x​double floor(double x)，返回数轴上在x左边的最近一个整数值，包括xdouble ceil(double x) "},{"title":"Redis","type":0,"sectionRef":"#","url":"docs/notes/database/redis","content":"Redis","keywords":""},{"title":"MySQL","type":0,"sectionRef":"#","url":"docs/notes/database/mysql","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#参考资料","content":"【宋红康】MySQL 数据库（mysql 安装/基础/高级/优化）_哔哩哔哩_bilibili "},{"title":"数据库的作用​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#数据库的作用","content":"实现数据持久化使用完整的管理系统统一管理 "},{"title":"名词解释​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#名词解释","content":"DB（Database），数据库，它保存了一系列有组织的数据DBMS（Database Management System），数据库管理系统，简称数据库软件，可以对数据库进行操作DBA（Database Administrator），数据库管理员SQL（Structure Query Language），结构化查询语言 "},{"title":"关系型数据库​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#关系型数据库","content":""},{"title":"概念​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#概念","content":"关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的（Structured）。 将数据放到表中，表再放到库中。 "},{"title":"关系​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#关系","content":"一对一一对多多对多自我引用 "},{"title":"命令行​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#命令行","content":"mysql -h localhost -P 3306 -u root -proot  -P指定端口-p指定密码，密码可以不写在命令中，只指定参数而不写密码的话会在交互式命令行中输入密码，不会在密码历史或屏幕中暴露密码 "},{"title":"默认数据库​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#默认数据库","content":"// TODO Mysql 默认带的几个数据库的作用 "},{"title":"SQL​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#sql","content":""},{"title":"SQL 概念​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#sql-概念","content":"结构化查询语言（Structured Query Language），是一种规范，用来操作关系型数据库。但是每种数据库在实现上有略微不同，称为「方言」； "},{"title":"分类​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#分类","content":"DDL（Data Definition Language）数据定义语言：用于操作数据库对象，如数据库、表、字段等。关键字：create、drop、alter、rename、truncate ；DML（Data Manipulation Language）数据操作语言：用于操作数据本身。关键字 insert、delete、update、select ；DCL（Data Control Language）数据控制语言：用户操作数据库 的访问权限和安全级别，以及管理用户，关键字 grant、revoke、commit、rollback、savepoint。 "},{"title":"规则​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#规则","content":"SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进 每条命令以;或 \\g或\\G结束 \\g和\\G只能在命令行中使用\\g和;的效果一样\\G会将结果表转置，行列转换 关键字不能被缩写也不能分行 关于标点符号 必须保证所有的()、单引号、双引号是成对结束的必须使用英文状态下的半角输入方式字符串型和日期时间类型的数据可以使用单引号表示列的别名，尽量使用双引号，而且不建议省略as "},{"title":"规范​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#规范","content":"这是建议遵守的，不强制。 MySQL 在 Windows 环境下是大小写不敏感的MySQL 在 Linux 环境下是大小写敏感的 数据库名、表名、表的别名、变量名是严格区分大小写的关键字、函数名、列名（或字段名）、列的别名（字段的别名）是忽略大小写的。 推荐采用统一的书写规范 数据库名、表名、表别名、字段名、字段别名等都小写SQL 关键字、函数名、绑定变量等都大写 "},{"title":"注释​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#注释","content":"-- 单行注释 # 单行注释 /* 多行注释 */  "},{"title":"SELECT 语句​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#select-语句","content":"select [distinct | ] 字段列表 from 表名列表 where 条件列表 group by 分组条件 having 分组之后的条件 order by 排序 limit 分页条件 escape '转义字符'  "},{"title":"去除重复行​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#去除重复行","content":"使用关键字DISTINCT去除重复行。 DISTINCT需要放到所有列名的前面DISTINCT是对后面所有列名的组合进行去重 "},{"title":"字段名和关键字冲突​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#字段名和关键字冲突","content":"在表名或字段名和关键字冲突时可能会造成歧义，这是使用着重号包裹字段名来避免歧义。 SELECT * FROM `ORDER`;  "},{"title":"转义字符​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#转义字符","content":"默认的转义字符是\\。 比如在使用like进行模糊查询的时候使用_作为单个字符的通配符，如果此时就是需要查询含有下划线的行，则需对其进行转义，如_\\__，中间的下划线就被转义了。 使用ESCAPE来自定义转义字符，如ESCAPE '&amp;'，意为使用$作为转义字符，此查询语句中的转义字符不再是\\了。 "},{"title":"运算符​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#运算符","content":""},{"title":"算数运算符​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#算数运算符","content":" "},{"title":"比较运算符​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#比较运算符","content":"  如果等号两边的值、字符串或表达式都为字符串，则 MySQL 会按照字符串进行比较，其比较的是每个字符串中字符的 ANSI 编码是否相等。如果等号两边的值一个是整数，另一个是字符串，则 MySQL 会将字符串转化为数字进行比较。如果等号两边的值、字符串或表达式中有一个为 NULL，则比较结果为 NULL。   LIKE 运算符通常使用如下通配符。 %匹配 0 个或多个字符。_只能匹配一个字符。 REGEXP和RLIKE均表示用正则表达式进行匹配。 "},{"title":"逻辑运算符​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#逻辑运算符","content":" "},{"title":"位运算符​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#位运算符","content":" "},{"title":"运算符的优先级​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#运算符的优先级","content":"下图中数字编号越大，优先级越高。   "},{"title":"NULL参与运算​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#null参与运算","content":"所有运算符或列值遇到null值，运算的结果都为null。 使用下面的方法安全处理null值。 &lt;=&gt;is nullis not nullisnull()ifnull() "},{"title":"排序​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#排序","content":"使用ORDER BY子句排序。 select * from 表 order by 字段 1 [, 字段 2, ...] [asc | desc];  ASC（Ascend），升序，默认排序方式DESC（Descend），降序 可以多字段同时排序，在前面字段相同的情况下会比较后面的字段。 "},{"title":"分页​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#分页","content":"使用LIMIT进行分页。 select * from 表 limit [offset,] rows;  offset表示从第几行之后开始，最小值为0，可省略，默认为0rows表示查询出多少行 "},{"title":"多表查询​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#多表查询","content":""},{"title":"内连接​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#内连接","content":"select * from a [inner] join b on a.id = b.id;  只会显示两表的交集，结果集的行必须出现在两个表中。 "},{"title":"外连接​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#外连接","content":"select * from a left | right [outer] join b on a.id = b.id;  左外连接：结果集中的行不仅包含符合连接条件的行，同时还包括左表中的不符合连接条件的行，这些行中来自副表的字段内容都是NULL。右外连接：同理。 "},{"title":"全链接​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#全链接","content":"MySQL 没有全连接，可以使用UNION来实现。 UNION操作符返回两个查询的结果集的并集，去除重复记录。UNION ALL不除重复记录。 "},{"title":"SQL99 语法新特性​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#sql99-语法新特性","content":"自然连接​ 使用NATURAL JOIN来简化多表查询操作，此时会自动将两表中所有同名字段进行等值连接。 USING连接​ 使用USING来简化ON子句，如果连接条件中的字段名称相同的话可以使用。 select * from a join b on a.id = b.id; select * from a join b using (id);  "},{"title":"单行函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#单行函数","content":""},{"title":"数值函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#数值函数","content":"函数\t用法ABS(x)\t返回 x 的绝对值 SIGN(X)\t返回 X 的符号。正数返回 1，负数返回-1，0 返回 0 PI()\t返回圆周率的值 CEIL(x)，CEILING(x)\t返回大于或等于某个值的最小整数 FLOOR(x)\t返回小于或等于某个值的最大整数 LEAST(e1,e2,e3…)\t返回列表中的最小值 GREATEST(e1,e2,e3…)\t返回列表中的最大值 MOD(x,y)\t返回 X 除以 Y 后的余数 RAND()\t返回 0~1 的随机值 RAND(x)\t返回 0~1 的随机值，其中 x 的值用作种子值，相同的 X 值会产生相同的随机数 ROUND(x)\t返回一个对 x 的值进行四舍五入后，最接近于 X 的整数 ROUND(x,y)\t返回一个对 x 的值进行四舍五入后最接近 X 的值，并保留到小数点后面 Y 位 TRUNCATE(x,y)\t返回数字 x 截断为 y 位小数的结果 SQRT(x)\t返回 x 的平方根。当 X 的值为负数时，返回 NULL 角度与弧度互换函数​ 函数\t用法RADIANS(x)\t将角度转化为弧度，其中，参数 x 为角度值 DEGREES(x)\t将弧度转化为角度，其中，参数 x 为弧度值 三角函数​ 函数\t用法SIN(x)\t返回 x 的正弦值，其中，参数 x 为弧度值 ASIN(x)\t返回 x 的反正弦值，即获取正弦为 x 的值。如果 x 的值不在-1 到 1 之间，则返回 NULL COS(x)\t返回 x 的余弦值，其中，参数 x 为弧度值 ACOS(x)\t返回 x 的反余弦值，即获取余弦为 x 的值。如果 x 的值不在-1 到 1 之间，则返回 NULL TAN(x)\t返回 x 的正切值，其中，参数 x 为弧度值 ATAN(x)\t返回 x 的反正切值，即返回正切值为 x 的值 ATAN2(m,n)\t返回两个参数的反正切值 COT(x)\t返回 x 的余切值，其中，X 为弧度值 指数与对数​ 函数\t用法POW(x,y)，POWER(X,Y)\t返回 x 的 y 次方 EXP(X)\t返回 e 的 X 次方，其中 e 是一个常数，2.718281828459045 LN(X)，LOG(X)\t返回以 e 为底的 X 的对数，当 X &lt;= 0 时，返回的结果为 NULL LOG10(X)\t返回以 10 为底的 X 的对数，当 X &lt;= 0 时，返回的结果为 NULL LOG2(X)\t返回以 2 为底的 X 的对数，当 X &lt;= 0 时，返回 NULL 进制间的转换​ 函数\t用法BIN(x)\t返回 x 的二进制编码 HEX(x)\t返回 x 的十六进制编码 OCT(x)\t返回 x 的八进制编码 CONV(x,f1,f2)\t返回 f1 进制数变成 f2 进制数 "},{"title":"字符串函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#字符串函数","content":"MySQL 中，字符串的位置是从 1 开始的。 函数\t用法ASCII(S)\t返回字符串 S 中的第一个字符的 ASCII 码值 CHAR_LENGTH(s)\t返回字符串 s 的字符数。作用与 CHARACTER_LENGTH(s) 相同 LENGTH(s)\t返回字符串 s 的字节数，和字符集有关 CONCAT(s1,s2,......,sn)\t连接 s1,s2,......,sn 为一个字符串 CONCAT_WS(x, s1,s2,......,sn)\t同 CONCAT(s1,s2,...) 函数，但是每个字符串之间要加上 x INSERT(str, idx, len, replacestr)\t将字符串 str 从第 idx 位置开始，len 个字符长的子串替换为字符串 replacestr REPLACE(str, a, b)\t用字符串 b 替换字符串 str 中所有出现的字符串 a UPPER(s) 或 UCASE(s)\t将字符串 s 的所有字母转成大写字母 LOWER(s) 或 LCASE(s)\t将字符串 s 的所有字母转成小写字母 LEFT(str,n)\t返回字符串 str 最左边的 n 个字符 RIGHT(str,n)\t返回字符串 str 最右边的 n 个字符 LPAD(str, len, pad)\t用字符串 pad 对 str 最左边进行填充，直到 str 的长度为 len 个字符 RPAD(str ,len, pad)\t用字符串 pad 对 str 最右边进行填充，直到 str 的长度为 len 个字符 LTRIM(s)\t去掉字符串 s 左侧的空格 RTRIM(s)\t去掉字符串 s 右侧的空格 TRIM(s)\t去掉字符串 s 开始与结尾的空格 TRIM(s1 FROM s)\t去掉字符串 s 开始与结尾的 s1 TRIM(LEADING s1 FROM s)\t去掉字符串 s 开始处的 s1 TRIM(TRAILING s1 FROM s)\t去掉字符串 s 结尾处的 s1 REPEAT(str, n)\t返回 str 重复 n 次的结果 SPACE(n)\t返回 n 个空格 STRCMP(s1,s2)\t比较字符串 s1,s2 的 ASCII 码值的大小 SUBSTR(s,index,len)\t返回从字符串 s 的 index 位置其 len 个字符，作用与 SUBSTRING(s,n,len)、MID(s,n,len) 相同 LOCATE(substr,str)\t返回字符串 substr 在字符串 str 中首次出现的位置，作用于 POSITION(substr IN str)、INSTR(str,substr) 相同。未找到，返回 0 ELT(m,s1,s2,…,sn)\t返回指定位置的字符串，如果 m=1，则返回 s1，如果 m=2，则返回 s2，如果 m=n，则返回 sn FIELD(s,s1,s2,…,sn)\t返回字符串 s 在字符串列表中第一次出现的位置 FIND_IN_SET(s1,s2)\t返回字符串 s1 在字符串 s2 中出现的位置。其中，字符串 s2 是一个以逗号分隔的字符串 REVERSE(s)\t返回 s 反转后的字符串 NULLIF(value1,value2)\t比较两个字符串，如果 value1 与 value2 相等，则返回 NULL，否则返回 value1 "},{"title":"日期和时间函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#日期和时间函数","content":""},{"title":"流程控制函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#流程控制函数","content":"函数\t用法IF(value,value1,value2)\t如果 value 的值为 TRUE，返回 value1，否则返回 value2 IFNULL(value1, value2)\t如果 value1 不为 NULL，返回 value1，否则返回 value2 CASE WHEN 条件 1 THEN 结果 1 WHEN 条件 2 THEN 结果 2 .... [ELSE resultn] END\t相当于 Java 的 if...else if...else... CASE expr WHEN 常量值 1 THEN 值 1 WHEN 常量值 1 THEN 值 1 .... [ELSE 值 n] END\t相当于 Java 的 switch...case... "},{"title":"加密与解密函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#加密与解密函数","content":"函数\t用法PASSWORD(str)\t返回字符串 str 的加密版本，41 位长的字符串。加密结果不可逆，常用于用户的密码加密 MD5(str)\t返回字符串 str 的 md5 加密后的值，也是一种加密方式。若参数为 NULL，则会返回 NULL SHA(str)\t从原明文密码 str 计算并返回加密后的密码字符串，当参数为 NULL 时，返回 NULL。SHA 加密算法比 MD5 更加安全。 ENCODE(value,password_seed)\t返回使用 password_seed 作为加密密码加密 value DECODE(value,password_seed)\t返回使用 password_seed 作为加密密码解密 value "},{"title":"MySQL 信息函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#mysql-信息函数","content":"函数\t用法VERSION()\t返回当前 MySQL 的版本号 CONNECTION_ID()\t返回当前 MySQL 服务器的连接数 DATABASE()，SCHEMA()\t返回 MySQL 命令行当前所在的数据库 USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()\t返回当前连接 MySQL 的用户名，返回结果格式为“主机名 @用户名” CHARSET(value)\t返回字符串 value 自变量的字符集 COLLATION(value)\t返回字符串 value 的比较规则 "},{"title":"其他函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#其他函数","content":"函数\t用法FORMAT(value,n)\t返回对数字 value 进行格式化后的结果数据。n 表示四舍五入后保留到小数点后 n 位 INET_ATON(ipvalue)\t将以点分隔的 IP 地址转化为一个数字 INET_NTOA(value)\t将数字形式的 IP 地址转化为以点分隔的 IP 地址 BENCHMARK(n,expr)\t将表达式 expr 重复执行 n 次。用于测试 MySQL 处理 expr 表达式所耗费的时间 CONVERT(value USING char_code)\t将 value 所使用的字符编码修改为 char_code "},{"title":"聚合函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#聚合函数","content":"聚合函数作用于一组数据，并对一组数据返回一个值。 "},{"title":"AVG 和 SUM 函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#avg-和-sum-函数","content":"可以对数值型数据使用AVG和SUM函数。 "},{"title":"MIN 和 MAX 函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#min-和-max-函数","content":"可以对任意数据类型的数据使用MIN和MAX函数。 "},{"title":"COUNT 函数​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#count-函数","content":"COUNT(*)返回表中记录总数，适用于任意数据类型。 COUNT(expr)返回expr 不为空的记录总数。 问题：用count(*)，count(1)，count(列名)谁好呢？ 其实，对于 MyISAM 引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。 Innodb 引擎的表用count(*),count(1)直接读行数，复杂度是 O(n)，因为 innodb 真的要去数一遍。但好于具体的count(列名)。 问题：能不能使用count(列名)替换count(*)? 不要使用 count(列名) 来替代 count(*)，count(*)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而count(列名)不会统计此列为 NULL 值的行。 "},{"title":"GROUP BY​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#group-by","content":"可以使用GROUP BY子句将表中的数据分成若干组。 在SELECT列表中的字段都必须出现在GROUP BY子句中，除了在聚合函数中的字段。如果不遵守的话在 MySQL 中不会提示错误，但是这个字段在行中是无意义的。 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id ;  包含在GROUP BY子句中的列不必包含在SELECT列表中。 SELECT AVG(salary) FROM employees GROUP BY department_id ;  GROUP BY后可以有多个列，此时按这些列的各个组合进行分组。 使用WITH ROLLUP关键字之后，在所有查询出的分组记录之后增加一条记录，就是将所有组的数据代入到聚合函数中。没有使用聚合函数的列显示为 NULL。 "},{"title":"HAVING​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#having","content":"HAVING不能单独使用，必须要跟GROUP BY一起使用。用来过滤分组结果，满足条件的分组行才会被查询出来。在之后可以使用聚合函数。 WHERE和HAVING的对比。 WHERE跟在FROM后面，HAVING跟在GROUP BY后面；WHERE后面不能使用聚合函数，HAVING可以；WHERE在分组前筛选，HAVING在分组后筛选；在多表查询中WHERE的效率更高，所以不涉及到聚合函数的条件写在WHERE中更好。 "},{"title":"SELECT 的执行过程​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#select-的执行过程","content":"在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。 SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5 FROM player JOIN team ON player.team_id = team.team_id # 顺序 1 WHERE height &gt; 1.80 # 顺序 2 GROUP BY player.team_id # 顺序 3 HAVING num &gt; 2 # 顺序 4 ORDER BY num DESC # 顺序 6 LIMIT 2 # 顺序 7  "},{"title":"子查询​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#子查询","content":"子查询指一个查询语句嵌套在另一个查询语句内部的查询。 子查询要包含在括号内将子查询放在比较条件的右侧单行操作符对应单行子查询，多行操作符对应多行子查询 在下列子句中都可以写子查询。 SELECTFROMWHEREHAVINGORDER BY "},{"title":"单行子查询​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#单行子查询","content":"单行比较操作符后面只能是单行子查询。 "},{"title":"多行子查询​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#多行子查询","content":"多行操作符后面可以是单行子查询，也可以是多行子查询。 操作符\t含义IN\t等于列表中的任意一个 ANY\t需要和单行比较操作符一起使用，和子查询返回的某一个值比较，只要有一行满足条件即可 ALL\t需要和单行比较操作符一起使用，和子查询返回的所有值比较，需要所有行都满足条件 SOME\t实际上是 ANY 的别名，作用相同，一般常使用 ANY "},{"title":"相关子查询​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#相关子查询","content":"子查询会执行多次。子查询中使用了外部的信息。 "},{"title":"EXISTS与NOT EXISTS​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#exists与not-exists","content":"用在WHERE子句中。EXISTS与NOT EXISTS后面都跟一个子查询，如果子查询返回有数据则EXISTS返回1，否则返回0；NOT EXISTS正相反。 SELECT employee_id , last_name , job_id , department_id from employees e WHERE EXISTS ( select 1 from employees e2 WHERE e2.manager_id = e.employee_id );  "},{"title":"相关更新​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#相关更新","content":"使用相关子查询依据一个表中的数据更新另一个表的数据。 UPDATE employees e SET department_name = (SELECT department_name FROM departments d WHERE e.department_id = d.department_id);  "},{"title":"相关删除​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#相关删除","content":"使用相关子查询依据一个表中的数据删除另一个表的数据。 DELETE FROM employees e WHERE employee_id in (SELECT employee_id FROM emp_history WHERE employee_id = e.employee_id);  "},{"title":"创建表和管理表​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#创建表和管理表","content":""},{"title":"标识符命名规则​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#标识符命名规则","content":"数据库名、表名不得超过 30 个字符，变量名限制为 29 个必须只能包含 A–Z、a–z、0–9和_共 63 个字符同一个 MySQL 软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在 SQL 语句中使用`（着重号）引起来保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了 "},{"title":"MySQL 中的数据类型​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#mysql-中的数据类型","content":"类型\t类型举例整数类型\tTINYINT、SMALLINT、MEDIUMINT、INT（或 INTEGER）、BIGINT 浮点类型\tFLOAT、DOUBLE 定点数类型\tDECIMAL 位类型\tBIT 日期时间类型\tYEAR、TIME、DATE、DATETIME、TIMESTAMP 文本字符串类型\tCHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT 枚举类型\tENUM 集合类型\tSET 二进制字符串类型\tBINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB JSON 类型\tJSON 对象、JSON 数组 空间数据类型\t单值：GEOMETRY、POINT、LINESTRING、POLYGON； 集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 其中，常用的几类类型介绍如下。 数据类型\t描述INT\t从 −231-2^{31}−231 到 231−12^{31}-1231−1 的整型数据。存储大小为 4 个字节 CHAR(size)\t定长字符数据。若未指定，默认为 1 个字符，最大长度 255 VARCHAR(size)\t可变长字符数据，根据字符串实际长度保存，必须指定长度 FLOAT(M,D)\t单精度，占用 4 个字节，M=整数位+小数位M=整数位 + 小数位M=整数位+小数位，D=小数位D=小数位D=小数位。 D&lt;=M&lt;=255D&lt;=M&lt;=255D&lt;=M&lt;=255，0&lt;=D&lt;=300&lt;=D&lt;=300&lt;=D&lt;=30，默认 M+D&lt;=6M+D&lt;=6M+D&lt;=6 DOUBLE(M,D)\t双精度，占用 8 个字节，D&lt;=M&lt;=255D&lt;=M&lt;=255D&lt;=M&lt;=255，0&lt;=D&lt;=300&lt;=D&lt;=300&lt;=D&lt;=30，默认 M+D&lt;=15M+D&lt;=15M+D&lt;=15 DECIMAL(M,D)\t高精度小数，占用 M+2M+2M+2 个字节，D&lt;=M&lt;=65D&lt;=M&lt;=65D&lt;=M&lt;=65，0&lt;=D&lt;=300&lt;=D&lt;=300&lt;=D&lt;=30，最大取值范围与 DOUBLE 相同。 DATE\t日期型数据，格式「YYYY-MM-DD」 BLOB\t二进制形式的长文本数据，最大可达 4G TEXT\t长文本数据，最大可达 4G "},{"title":"管理数据库​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#管理数据库","content":"创建数据库​ CREATE DATABASE 数据库名; CREATE DATABASE 数据库名 CHARACTER SET 'utf8mb4'; CREATE DATABASE IF NOT EXISTS 数据库名 CHARACTER SET 'utf8mb4';  数据库不能改名，只能删除重建。 使用数据库​ # 查看所有数据库 SHOW DATABASES; # 查询建表语句 SHOW CREATE DATABASE 数据库名; # 选择使用某个数据库 USE 数据库名; # 查看当前正在使用的数据库 SELECT DATABASE();  修改数据库​ # 更改数据库字符集 ALTER DATABASE 数据库名 CHARACTER SET 字符集;  删除数据库​ DROP DATABASE 数据库名; # 数据库不存在时不会报错 DROP DATABASE IF EXISTS 数据库名;  "},{"title":"管理表​","type":1,"pageTitle":"MySQL","url":"docs/notes/database/mysql#管理表","content":"创建表​ # 方式一 直接创建表 CREATE TABLE [IF NOT EXISTS] 表名( 字段1, 数据类型 [约束条件] [默认值], 字段2, 数据类型 [约束条件] [默认值], 字段3, 数据类型 [约束条件] [默认值], …… [表约束条件] );  CREATE TABLE dept( -- int类型，自增 deptno INT(2) AUTO_INCREMENT, dname VARCHAR(14), loc VARCHAR(13), -- 主键 PRIMARY KEY (deptno) );  # 方式二 基于子查询创建表，并导入数据 CREATE TABLE 表名 [(列, 列...)] AS (子查询)  CREATE TABLE emp1 AS SELECT * FROM employees;  使用表​ # 查看当前数据库下的所有表 show tables; # 查询建表语句 show create table t1; # 查询表结构 desc t1; describe t1;  修改表​ "},{"title":"apache-commons","type":0,"sectionRef":"#","url":"docs/notes/java/apache-commons","content":"apache-commons","keywords":""},{"title":"arthas","type":0,"sectionRef":"#","url":"docs/notes/java/arthas","content":"arthas","keywords":""},{"title":"freemaker","type":0,"sectionRef":"#","url":"docs/notes/java/freemaker","content":"freemaker","keywords":""},{"title":"gson","type":0,"sectionRef":"#","url":"docs/notes/java/gson","content":"gson","keywords":""},{"title":"guava","type":0,"sectionRef":"#","url":"docs/notes/java/guava","content":"guava","keywords":""},{"title":"hutool","type":0,"sectionRef":"#","url":"docs/notes/java/hutool","content":"hutool","keywords":""},{"title":"jackson","type":0,"sectionRef":"#","url":"docs/notes/java/jackson","content":"jackson","keywords":""},{"title":"java-web","type":0,"sectionRef":"#","url":"docs/notes/java/java-web","content":"java-web","keywords":""},{"title":"Java","type":0,"sectionRef":"#","url":"docs/notes/java/","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"Java","url":"docs/notes/java/#参考资料","content":"2021 年度全网最全 Java 学习路线 - 哔哩哔哩尚硅谷 Java 零基础入门教程（含百道 Java 真题，2 万多行 Java 代码实战）_哔哩哔哩_bilibili30 天搞定 Java 核心技术-程序员标配，人手一套尚硅谷教程30 天搞定 Java 核心技术（上） - 谷粒学苑 - Java 培训|大数据培训|前端培训|HTML5 培训|Linux 运维培训_程序员一站式 IT 在线学习平台 - Powered By EduSoho "},{"title":"Java 语言概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-语言概述","content":""},{"title":"软件开发介绍​","type":1,"pageTitle":"Java","url":"docs/notes/java/#软件开发介绍","content":"人机交互方式​ 图形化界面（Graphical User Interface, GUI）命令行方式（Command Line Interface, CLI） 常用的 DOS 命令​ dir列出目录下的文件以及文件夹md创建目录rd删除目录cd进入指定目录cd..进入上级目录cd\\进入根目录del删除文件exit退出 DOS 命令行echo回显；可以用输出重定向输出内容到文件，如echo javase &gt; 1.txtTAB代码提示←→移动光标↑↓调整历史命令DeleteBackspace删除字符 "},{"title":"计算机编程语言介绍​","type":1,"pageTitle":"Java","url":"docs/notes/java/#计算机编程语言介绍","content":"第一代语言：机器语言，指令以二进制代码形式存在；第二代语言：汇编语言，使用助剂符表示一条机器指令；第三代语言：高级语言。 "},{"title":"Java 语言概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-语言概述-1","content":"Java 语言是 SUN（Stanford University Network）1995 年推出的一门高级编程语言。 编程语言排行榜：index | TIOBE - The Software Quality Company。 Java 简史​ 1991 年 Green 项目，开发语言最初命名为 Oak （橡树）1996 年，发布 JDK 1.01999 年，Java 分成 J2SE、J2EE 和 J2ME，JSP/Servlet 技术诞生2004 年，发布里程碑式版本 JDK 1.5，为突出此版本的重要性，更名为 JDK 5.02005 年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME2009 年，Oracle 公司收购 SUN，交易价格 74 亿美元2014 年，发布 JDK 8.0，是继 JDK 5.0 以来变化最大的版本2018 年 3 月，发布 JDK 10.0，版本号也称为 18.32018 年 9 月，发布 JDK 11.0，版本号也称为 18.9 Java 技术体系平台​ Java SE（Java Standard Edition）标准版，面向桌面级应用开发；Java EE（Java Enterprise Edition）企业版，是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如 Servlet 、JSP 等，主要针对于 Web 应用程序开发；ava ME（Java Micro Edition）小型版，支持 Java 程序运行在移动终端上的平台；Java Card，支持一些 Java 小程序（Applets）运行在小内存设备（如智能卡）上的平台。 "},{"title":"Java 语言的环境搭建​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-语言的环境搭建","content":"JRE（Java Runtime Environment，Java 运行环境）JDK（Java Development Kit，Java 开发工具包）   "},{"title":"开发体验——Hello World​","type":1,"pageTitle":"Java","url":"docs/notes/java/#开发体验hello-world","content":"编写 文件以.java为后缀以类为基本单位一个文件中只能由一个public类如果存在public类，则源代码文件名需要与类名相同程序的入口为固定写法，public static void main(String[] args) { /* ... */ }语句之间用分号分隔 编译，javac A.java运行，java 类名  "},{"title":"注释​","type":1,"pageTitle":"Java","url":"docs/notes/java/#注释","content":"单行注释，// 注释多行注释，/* 注释 */文档注释，/** @author Roddy */，可以用javadoc工具解析，生成代码文档 "},{"title":"Java API 文档​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-api-文档","content":"Java 8 中文版 - 在线 API 中文手册 - 码工具Overview (Java Platform SE 8 ) "},{"title":"Java 基本语法​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-基本语法","content":""},{"title":"关键字与保留字​","type":1,"pageTitle":"Java","url":"docs/notes/java/#关键字与保留字","content":"Java Language Keywords (The Java™ Tutorials &gt; Learning the Java Language &gt; Language Basics) 关键字（keyword）：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词）。关键字中所有字母都为小写。 保留字（reserverd word）：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。有两个goto、const。  "},{"title":"标识符​","type":1,"pageTitle":"Java","url":"docs/notes/java/#标识符","content":"命名规则​ Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符。 由 26 个英文字母大小写，0-9 、_或 $ 组成；数字不可以开头；不可以使用关键字和保留字，但能包含关键字和保留字；Java 中严格区分大小写，长度无限制；标识符不能包含空格。 命名规范​ 命名规范，不强制但是强烈建议。 包名：xxxyyyzzz类名、接口名：XxxYyyZzz变量名、方法名：xxxYyyZzz常量名：XXX_YYY_ZZZ "},{"title":"变量​","type":1,"pageTitle":"Java","url":"docs/notes/java/#变量","content":"概念​ 内存中的一个存储区域该区域的数据可以在同一类型范围内不断变化变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值。 作用​ 用于在内存中保存数据。 使用规则​ Java 中每个变量必须先声明，后使用使用变量名来访问这块区域的数据变量的作用域为其定义所在的一对{}内变量只有在其作用域内才有效同一个作用域内，不能定义重名的变量 变量分类​ 按类型分类​  @startmindmap * Java 数据类型 **: 基本数据类型 （primitive type）; *** 数值型 **** 整数类型（byte，short，int，long） **** 浮点类型（float，double） *** 字符型（char） *** 布尔型（boolean） **: 引用数据类型 （reference type）; *** 类（class） ****_ 字符串在这里 *** 接口（interface） *** 数组（[]） @endmindmap  按声明位置分类​ 成员变量：在方法体外，类内部声明的变量； 实例变量：没有static修饰的变量；类变量：有static修饰的变量。 局部变量：在方法体内部声明的变量。 变量的初始值​ 成员变量有初始值，局部变量没有初始值，需要显示初始化，不然不能通过编译检查。 数据类型\t默认值byte\t0 short\t0 int\t0 long\t0L float\t0.0F double\t0.0 char\t0（int类型）或'\\u0000' boolean\tfalse 引用类型\tnull 数据类型​   #\t数据类型\t占用存储空间\t表数范围\t备注1\tbyte\t1 字节\t[−128,127][-128,127][−128,127] 2\tshort\t2\t[−215,215−1][-2^{15},2^{15}-1][−215,215−1] 3\tint\t4\t[−232,232−1][-2^{32},2^{32}-1][−232,232−1]（约为 21 亿）\t默认的整数类型 4\tlong\t8 数字后面加l或L可声明为此类型 5\tfloat\t4\t尾数可以精确到 7 位有效数字\t后加f或F 6\tdouble\t8\t精度是float的两倍\t默认的浮点数字类型 7\tchar\t2\t\\u0000~\\uFFFF，即0~65535，无符号 16 位二进制数\t存储一个 Unicode 编码字符，用一对单引号''包括，可以用 Unicode 编码，比如'\\u00443' 8\tboolean 只可以在true或false两个字面量之间取值 浮点类型补充​ float 遵循 IEEE R32.24 规范，double 遵循 IEEE R64.53 规范。 无论是单精度还是双精度在存储中都分为三个部分： 符号位（Sign） ：0 代表正，1 代表为负指数位（Exponent）：用于存储科学计数法中的指数数据，并且要加上偏移量（float 偏移量 127，double 偏移量 1023）尾数部分（Mantissa）   注意： 浮点类型不精确，因为可能会舍弃存不下的位float 类型的表示范围比 long 类型的表示范围大 // TODO 补充浮点数知识 自动类型转换​ int a = 100; long b = a;   容量（表数范围/精度）小的类型在需要的时候会自动转为容量大的类型，不会丢失精度；有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算；byte、short、char之间不会相互转换，它们三种类型在计算时会首先转为int类型；boolean类型不会与其他类型转换；任何基本数据类型和Sting字符串在进行+运算时，基本数据类型会首先被转换为字符串类型，参与字符串拼接。 Unicode 与 ASCII​ char类型的变量在转换为int类型的时候会转换为对应 Unicode 编码的十进制值。Unicode 兼容 ASCII。 ASCII TableUnicode 14.0 Character Code Charts String​ String不是基本数据类型，而是引用数据类型，它是一个类；可以使用字面量方式声明，用双引号&quot;&quot;包括；也可以用new String()的方式创建对象；String在和+使用的时候意义为字符串拼接而不是加法，在和基本数据类型进行拼接运算时，基本数据类型会首先被转为String类型； 强制类型转换​ long a = 100L; int b = (int) a;  boolean类型不可以被转换为其他类型；如果想把更大容量/更高精度的类型转为小容量/低精度类型的时候可以用强制类型转换，有丢失精度的和数据的风险。 "},{"title":"进制​","type":1,"pageTitle":"Java","url":"docs/notes/java/#进制","content":"这是常用进制在 Java 中的声明方式。 进制\t开头二进制（Binary）\t0b或0B 八进制（Octal）\t0 十进制（Decimal） 十六进制（Hex）\t0x或0X "},{"title":"运算符​","type":1,"pageTitle":"Java","url":"docs/notes/java/#运算符","content":"算术运算符​  %的结果和前一个操作数的正负相同，与后一个操作数的正负无关；(a++)++是行不通的，编译错误。 赋值运算符​ =当两侧的数据类型不一致的时候，可以使用自动类型转换或强制类型转换处理支持连续赋值扩展赋值运算符，不会改变原有的数据类型 +=，a+=b &lt;=&gt; a=a+b-=*=/=%= short s = 3; s = s + 2; // 编译不通过 s += 2; // 不改变原来的数据类型  比较运算符​  比较运算符的结果都是boolean类型，要么是true，要么是false。 逻辑运算符​  位运算符​   位运算符对整数的二进制进行运算；&lt;&lt;左移一位相当于×2\\times2×2；&gt;&gt;右移一位相当于÷2\\div2÷2；没有无符号左移运算符&lt;&lt;&lt;；异或^在交换两个整数类型变量的值的时候有妙用，异或三次次即可交换值，不需要中间变量。 // 加减交换整数值 // 可能会超出 int 的范围 n1 = n1 + n2; n2 = n1 - n2; n1 = n1 - n2; // 用异或交换整数值 n1 = n1 ^ n2; n2 = n1 ^ n2; n1 = n1 ^ n2;  三元运算符​ （条件表达式） ? 表达式 1 : 表达式 2;  当条件表达式为true时，执行表达式 1，整个表达式的值为表达式 1 的结果；否则执行表达式 2，整个表达式的结果为表达式 2 的结果；表达式 1 和表达式 2 必须是同种类型。 运算符的优先级​  "},{"title":"程序流程控制​","type":1,"pageTitle":"Java","url":"docs/notes/java/#程序流程控制","content":"顺序结构​ Java 程序在整体上是顺序结构的，依据语句书写的顺序从前往后执行。 分支结构​ ifif-elseswitch-case switch表达式中的值必须是下面几种类型之一 byteshortintcharEnum（JDK 5）String（JDK 7） case子句的值必须是常量，不能是变量名或者不确定值的表达式；所有case字句的值应该互斥；break关键字用于跳出switch结构，如果没有使用break则会接着向下执行，意味着可以匹配多个case；default子句是可选的，位置也是灵活的（不一定要写在case语句之后），在没有匹配到case语句时会执行default子句中的表达式；如果default语句写在case语句之前，并且没有break，在匹配default语句之后还会向下执行case里的语句，直到遇到break或者执行完毕。这是一个很反直觉的行为，所以default子句尽量写在最后，并且如果不是特殊情况下，每条case语句都应包含一个break。 循环结构​ forwhiledo-while "},{"title":"数组​","type":1,"pageTitle":"Java","url":"docs/notes/java/#数组","content":""},{"title":"数组的概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/#数组的概述","content":"数组（Array）是多个相同数据类型按一定顺序排列的集合。 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型；数组在内存中是一整块连续的空间，数组名引用的是这块连续空间的首地址；数组的长度一旦确定就不能修改。 "},{"title":"一维数组​","type":1,"pageTitle":"Java","url":"docs/notes/java/#一维数组","content":"声明​ int a[]; int[] a;  动态初始化​ int[] arr = new int[3]; arr[0] = 3;  静态初始化​ int[] arr = new int[]{1, 2, 3}; // 类型推断 int[] arr = {1, 2, 3};  默认值​ 数组成员具有默认值，和成员变量的初始值规则相同。不管是通过动态初始化还是静态初始化的方式来初始化数组，数组成员都有默认值，不过通过静态初始化方式初始化之后，数组成员的值又立刻被修改了一次。 "},{"title":"多维数组的使用​","type":1,"pageTitle":"Java","url":"docs/notes/java/#多维数组的使用","content":"声明​ int arr[][]; int [][] arr; // 也可以这样写 int[] arr[]，也是二维数组的声明 int[] arr[] = new int[3][3]; // 注意特殊写法 // x 是一维数组，y 是二维数组 int[] x, y[];  动态初始化​ int arr[][] = new int[3][2]; arr[0][1] = 2;  // 后面的可以先不初始化 int arr[][] = new int[3][]; arr[0] = new int[3]; arr[0][2] = 1; // 多维数组不必是规则矩阵形式 arr[1] = new int[2]; arr[1][1] = 2;  静态初始化​ int[][] arr = new int[][]{{1, 1, 1}, {2, 2, 2}, {3, 3, 3}}; // 类型推断 int[][] arr = {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}};  "},{"title":"面向对象编程​","type":1,"pageTitle":"Java","url":"docs/notes/java/#面向对象编程","content":""},{"title":"面向过程与面向对象​","type":1,"pageTitle":"Java","url":"docs/notes/java/#面向过程与面向对象","content":"面向过程编程（Procedure Oriented Programming，POP），以函数为最小单位，考虑怎么做； 面向对象编程（Object Oriented Programming, OOP），以类/对象为最小单位，考虑谁来做。 "},{"title":"面向对象的三大特征​","type":1,"pageTitle":"Java","url":"docs/notes/java/#面向对象的三大特征","content":"封装（Encapsulation）​ 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的安全性、可扩展性和可维护性。 修饰符\t同一个类\t同一个包\t不同包的子类\t同一个工程private\t✅ （空）\t✅\t✅ protected\t✅\t✅\t✅ public\t✅\t✅\t✅\t✅ 在修饰class时只能用public或者空修饰符。 继承（Inheritance）​ 子类继承了父类，就继承了父类的所有方法和属性。但是父类中的private成员进行了隐藏，不能直接访问。 父类中的成员，无论是公有还是私有，均被子类继承。只是因为访问控制修饰符的原因，子类不能对继承的私有成员直接进行访问。 子类不会继承父类的构造器，但是一定会调用父类的构造器。 Java 中只能实现单继承。 Java 中所有的类都直接或间接继承自Object类。 子类可以根据需要方法重写（Overwrite）。 子类中的方法和父类中的方法必须有相同的名称和参数列表；子类方法的返回值类型不能大于父类方法的返回值类型；子类方法的访问权限不能小于父类方法的访问权限； 父类中的private方法不能被重写，但是可以在子类中声明相同方法签名的方法，不称为重写；父类中的static方法也不能被重写，可以重新声明。 子类方法抛出的异常不能大于父类方法的异常。 多态（Polymorphism）​ 编译时和运行时对象类型不一致，就出现了对象的多态性。子类对象可以替代父类对象使用。 编译时，看左边（类型声明）；运行时，看右边（对象实例）。 多态不适用于属性，属性是在编译器确定的，运行时也看左边。 意味着方法会被完全覆盖，但是属性不会被覆盖。但是依然可以在子类内部通过super关键字调用直接父类中被覆盖的方法。 可以通过向上转型和向下转型来使用继承树中各个类的属性和方法。 instanceof运算符用来判断某一个对象是否是某个类或该类子类的实例，返回true或false。 java.lang.Object#getClass方法可以获取对象的运行时类名。 抽象​ 也算是面向对象的特征之一，如果有人问的话。 "},{"title":"类和对象​","type":1,"pageTitle":"Java","url":"docs/notes/java/#类和对象","content":"类（Class）是对一类事物的描述，是抽象的、概念上的定义； 对象（Object）是实际存在的该类事物的每个个体，也称为实例（Instance）。 "},{"title":"类的成员​","type":1,"pageTitle":"Java","url":"docs/notes/java/#类的成员","content":"属性​ 属性（Field）又称为成员变量，分为实例变量（没有static修饰）和类变量（有static修饰）。 方法​ 方法的重载（Overload）指的是在同一个类内同名但是参数列表不完全相同的多个方法； 方法的重写（Overwrite）指的是在子类中对父类中已有的方法进行重新实现，方法的签名相同（返回值和抛出的异常范围可以更小）。 参数的值传递：对于基本数据类型，形参（方法内可以操作的参数）就是实参的复制，对形参的改变不会影响到实参；对于引用数据类型，形参是实参内存地址的复制，对形参直接修改不会影响到实参，通过形参名指向的内存地址对该对象/数组内的成员进行操作实际上就是对实参的操作。 构造器​ 没有返回值 在创建对象的时候自动执行 可以用public/protected/private修饰 protected的构造器只能在当前包内用，其它地方不能new这个对象private的构造器只能在类内部用，不能在外部用，常用于单例模式 构造器不是方法 构造器不能被继承 代码块​ 代码块中的变量都是局部变量。 内部类​ 在 Java 中，允许在在类中定义类结构，称为内部类。内部类的名称不能与外部类的名称相同。 可以被以下关键词修饰： staticfinalabstract成员内部类可以被四种不同的权限修饰符修饰 成员内部类​ 静态内部类 可以调用外部类的静态成员，包括私有的；在外部可以直接实例化；静态内部类不会随着外部类的初始化而初始化，只有在用到的时候才会被初始化，静态内部类内的静态代码块不会随着外部类的初始化而执行。 InnerClassTest.StaticA staticA = new InnerClassTest.StaticA();  非静态内部类 可以调用外部的非静态成员，相当于外部类类名。this. 成员，包括私有的；在内部类中this指向自身，外部类类名。this可以访问外部类的this；在外部实例化非静态内部类时需要先实例化外部类，通过外部类实例化内部类。 A.B.C c = new InnerClassTest().new A().new B().new C();  局部内部类​ 定义在方法中。 局部内部类可以使用外部方法的局部变量，但是该变量必须是final的，Java 8 中在局部内部类使用的外部局部变量会自动声明为final的 Java 8 之前需要手动声明。由局部内部类和局部变量的不同生命周期所致；不能使用权限修饰符，和局部变量一样；不能使用static修饰，因此也不能包含静态成员。 匿名内部类​ 匿名内部类必须继承父类或实现接口匿名内部类只有一个对象匿名内部类的对象只能用多态形式引用 "},{"title":"关键字​","type":1,"pageTitle":"Java","url":"docs/notes/java/#关键字","content":"class​ 用于定义类，只能用public或者空权限修饰符。 this​ 实例本身的引用；在构造器中代表正在初始化的对象；可以在构造器中调用其它重载的构造器，必须放在构造器代码块的首行。 super​ 用于显式调用继承来的成员（成员变量/方法）；用于调用直接父类的构造器，必须在子类的构造器中使用，必须在代码块的第一行； static​ static可以用来修饰： 属性方法代码块内部类 被修饰的成员有以下特点： 随着类的加载而加载，只会加载一次优先于对象存在修饰的成员被所有该类的对象共享访问权限允许时，可以不创建对象，直接通过类名调用 final​ final可以用来修饰： 类，表示该类不能被继承方法，表示该方法不能被重写成员变量，表示该变量的值不能被修改，即为常量，必须在声明时赋值或者在构造器中赋值局部变量形参，表明形参在方法的代码块内不能被修改 abstract​ abstract可以用来修饰： 类，抽象类 抽象类不能被实例化，必须有子类继承它并且实现所有的抽象方法之后才能实例化子类如果子类没有重写所有的抽象方法，子类也必须声明为抽象类，含有抽象方法的类必须声明为抽象类不能用abstract修饰final类抽象类可以有构造器 方法，抽象方法 含有抽象方法的类必须声明为抽象类不能用abstract修饰private方法、静态方法、final方法 interface​ 用于定义接口。 接口的思想就是定义了规范，继承是「是不是」的关系，而接口是「能不能」的关系。 接口的所有成员变量默认都是public static final修饰的接口中的所有方法都默认都是public abstract修饰的接口没有构造器一个类可以实现多个接口接口也可以实现其它接口接口与实现类之间也可以表现出多态的特性 Java 8 中对接口的增强： 静态方法默认方法 如果实现了接口并继承了一个类，并且接口中有默认方法和类中的方法同名同参数列表，则接口中的默认方法会被忽略，遵循类优先原则，子类在通过super调用父类方法的时候会调用类中的方法而不是接口中的默认方法，如果需要调用接口中的默认方法可以通过接口名。super. 方法名 ()来调用。 public class InterfaceTest { public static void main(String[] args) { new C().a(); } } interface A { default void a() { System.out.println(&quot;a&quot;); } } abstract class B { public void a() { System.out.println(&quot;b&quot;); } } class C extends B implements A { @Override public void a() { super.a(); A.super.a(); } }  接口可以完全取代抽象类吗？ 不能，抽象类有类的结构，比如说构造器，抽象类可以私有的成员；接口中只能定义public的成员。抽象类可以实现更多细节，接口更轻量。能用接口实现的就尽量用接口，不能用接口实现的采用抽象类。 package​ 指明本源文件中定义的类所在的包。 import​ import用于声明本源文件中用到的外部类的包位置。 java.lang包下的类不需要声明，可以直接用。 import static用于引入外部的静态成员（静态变量/静态方法），可以直接在本源文件中通过名称调用，不用再加上其所在的类名。 native​ 用来修饰方法，表明该方法不是用 Java 语言实现的，而是用底层的 C 语言或者 C++ 实现的。 "},{"title":"类的初始化顺序​","type":1,"pageTitle":"Java","url":"docs/notes/java/#类的初始化顺序","content":"在编译后的字节码文件中不存在构造器，转而出现了&lt;init&gt;()方法，该方法包括： 代码块中的代码显示赋值的代码构造器中的代码 其中 1 和 2 的执行顺序与代码的实际顺序相同，构造器中的代码总是最后执行。 &lt;init&gt;()方法的数量与构造函数的数量相同，调用构造方法实际上就是调用了对应的该方法。 也不存在代码块了，代码块中的代码都拷贝到每个&lt;init&gt;()方法中了。显示赋值也消失了，也同时放在该方法中执行。执行顺序与源码中的书写顺序一致。 最后才是构造器中原有的代码执行。 在有继承的情况下，先在父类中按照此顺序执行，然后再到子类中按照此顺序执行。 如果子类重写了父类的方法，则会调用子类中的该方法而不是父类中的方法。 静态代码块在类初始化的时候执行，所以优先级最高。 父类：成员变量之前的静态代码块父类：成员变量之后的静态代码块子类：成员变量之前的静态代码块子类：成员变量之后的静态代码块父类：成员变量之前的代码块父类：显式赋值父类：成员变量之后的代码块父类：构造方法子类：成员变量之前的代码块子类：显式赋值子类：成员变量之后的代码块子类：构造方法 "},{"title":"异常处理​","type":1,"pageTitle":"Java","url":"docs/notes/java/#异常处理","content":""},{"title":"异常概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/#异常概述","content":"程序执行中发生的不正常情况称为「异常」。开发过程中的语法错误和逻辑错误不属于异常。 "},{"title":"异常体系结构​","type":1,"pageTitle":"Java","url":"docs/notes/java/#异常体系结构","content":" Throwable是所有异常的公共父类，只有此类才能被抛出或者抓取。 Error，Java 虚拟机无法解决的严重的问题，如 JVM 内部系统严重错误、资源耗尽等严重情况等，一般不编写针对性的代码进行处理，捕获了也没用，应该从其它方面解决这些问题；Exception，其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。 RuntimeException，运行时异常，不建议捕获，应该尽量避免。因为这些异常发生比较频繁，如果在代码中显示捕获的话不利于阅读；其它异常，在编译时就能发现并且必须处理的异常，要么捕获，要么一直抛出到最上级。 "},{"title":"常见异常​","type":1,"pageTitle":"Java","url":"docs/notes/java/#常见异常","content":""},{"title":"异常处理机制​","type":1,"pageTitle":"Java","url":"docs/notes/java/#异常处理机制","content":"try-catch-finally​ try 包裹可能发生异常的代码块。如果出现异常就会在当前执行的语句处中断。如果在catch中捕获了该类型的异常就会跳转到对应的catch代码块。如果显式抛出异常则当前方法中断，异常交给调用者处理。如果都没有则程序中断。 catch 捕获某种类型的异常，可以多个catch并列，在捕获到异常之后进行对应处理。 finaly 不管有没有发生异常，该代码段都会执行，通常用于资源清理工作，确保无论何时资源都能被正常关闭。如果该代码块里使用了return语句，那么在try或者catch代码块里的 return语句将失效，因为在执行 try代码块里的return语句之前会先执行finally代码段里的return，然后方法就终止了。还有需要注意的是，如果在finally代码块里没有return语句的情况下，修改返回变量的值是无效的，在执行finally代码块之前就已经将返回值给到return处了，再执行return的时候不会拿最新的变量值，类似于i++的机制。 try-with-resoucees​ Java 8 引入，实现AutoCloseable接口的资源可以放在try后面的括号里初始化，在之后会自动关闭；多个资源之间用分号分隔。 Java 9 增强，资源可以不在括号中初始化，在其中声明即可。 try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } catch { }  throws​ 写在参数列表之后，方法体之前。表明当前方法可能会抛出异常的类型，这些异常不会在该方法内被处理。告知调用者在使用此方法的时候应该对这些异常进行处理，要么捕获要么再抛出。 throw​ 在方法体内中使用，主动抛出一个异常，终止该方法。 如果是一个编译时异常就需要在throws后声明，如果是运行时异常就不用声明。 "},{"title":"自定义异常​","type":1,"pageTitle":"Java","url":"docs/notes/java/#自定义异常","content":"从Exception或者它的子类派生出一个新类即可。 "},{"title":"多线程​","type":1,"pageTitle":"Java","url":"docs/notes/java/#多线程","content":""},{"title":"多线程基本概念​","type":1,"pageTitle":"Java","url":"docs/notes/java/#多线程基本概念","content":"程序（Program）是一段有序执行的静态代码的集合；进程（Process）是程序的一次执行过程，有生命周期；线程（Thread）是进程的进一步细分，比进程更轻量化，在线程之间切换的开销更小，效率更高，多个线程可以共享相同的内存区域。 一个 Java 程序至少有三个线程：主线程、垃圾回收线程和异常处理线程。 并行：多个 CPU 同时执行多个任务；并发：一个 CPU 采用时间片同时执行多个任务。 "},{"title":"线程的创建和使用​","type":1,"pageTitle":"Java","url":"docs/notes/java/#线程的创建和使用","content":"继承 Thread 类​ 从 Thread 类中派生出一个新类，重写run方法；创建线程类的对象，调用start方法，Java 会新开一个线程，执行run方法。 实现 Runnable 接口​ 新类，实现 Runnable 接口，重写run方法；还是通过Thread类来执行，它有一个构造方法接收Runnable类型的参数；调用Thread对象的start方法来启动线程。 Callable 和 FutureTask​ Java 5 新增，可以获得线程运行完毕之后的结果，返回值具有泛型支持。 新类，实现Callable接口，重写call()方法。 用FutureTask套Callable，再用Thread套FutureTask。 可以用FutureTask的get()方法获取返回值，这个方法会一直阻塞直到得到结果。 CallableDemo cd = new CallableDemo(); FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(cd); new Thread(task).start(); log.info(&quot;Task started.&quot;); String result = task.get(); log.info(&quot;Result got： {}&quot;, result);  线程池​ Java 5 中提供的线程池 API，ExecutorService和Executors。 可以手动创建线程池。 ExecutorService是接口，常见子类有ThreadPoolExecutor。 也可以使用Executors工具类来创建预先定义好设置的线程池。 Executors.newCachedThreadPool()newFixedThreadPool()newSingleThreadPool()newScheduledThreadPool() 创建线程池之后会拿到一个ExecutorService接口的对象，其实现类为ThreadPoolExecutor，其中有两个方法可以提交新任务。 submit(Runnable task)执行成功返回nullsubmit(Callable&lt;T&gt; task)有返回值execute(Runnable command)无返回值 "},{"title":"Thread 类中的常用方法​","type":1,"pageTitle":"Java","url":"docs/notes/java/#thread-类中的常用方法","content":"run要求子类重写，它的方法体也成为线程体start线程启动sleep(long millis)阻塞线程getName获取线程名称，默认是自动生成的，也可以在实例化对象的时候传递给构造器setName设置线程名称static currentThread获取当前线程的实例getPriority获取线程优先级，默认线程的优先级和它被创建的线程的优先级相同，主线程的默认优先级是 5setPriority设置线程优先级，范围为[1,10][1,10][1,10]，越大约高，但是执行时间还得看系统的调度策略checkAccess判断当前线程有没有权限修改目标线程stop()废弃的中断线程方法interrupt中断线程，如果在线程外部中断要确保有权限修改该线程。如果线程被其它方法阻塞的时候中断还会抛出异常join在线程外执行，阻塞当前线程，一直等到该线程执行完毕yeld放弃本次 CPU 时间 "},{"title":"线程的生命周期​","type":1,"pageTitle":"Java","url":"docs/notes/java/#线程的生命周期","content":"以下是操作系统概念中的线程的生命周期。 状态名\t解释\t触发条件创建\t新建但未开始\t在生成线程对象，并没有调用该对象的start()方法 就绪\t处于就绪队列\tstart()之后，但未获得 CPU 时间片 运行\t正在执行\t获得 CPU 时间片 阻塞\t处于阻塞队列\t等待资源、wait()、sleep()、suspend() 死亡\t执行完毕\trun()方法运行完毕或者调用stop()方法  JDK 中用枚举类Thread.State定义了线程的几种状态。 状态名\t解释\t触发条件NEW\t新建但未开始\tnew之后，start()之前 RUNNABLE\t可运行\t正在运行或者处于就绪队列 BLOCKED\t阻塞\t等待监视器锁或者调用wait() WAITTING\t等待\twait() TIMED_WAITTING\t可自行返回的等待状态\tsleep()、带时间的wait()、带时间的join() TERMINATED\t执行完毕\trun()方法运行完毕或者调用stop()方法 "},{"title":"线程的同步​","type":1,"pageTitle":"Java","url":"docs/notes/java/#线程的同步","content":"同步代码块​ synchronized（锁对象）{}  规定一段代码，在任何时刻只能有一个对象运行。在运行之前会检查锁对象是否已加锁，如果没有，在运行的时候就给锁对象加锁，运行结束之前解锁。 关于锁对象，要确保它在每个实例中是同一个对象。以继承Thread方式创建的线程中就不能使用this作为锁对象，因为每个实例中的Thread对象不同；以实现Runnable接口方式创建的线程可以使用this作为锁对象，因为在创建线程的时候可以只有一个该类的实例，然后通过这唯一的实例去创建线程。并且在后一种方式中，所有线程共享数据，不需要用static修饰。 同步方法​ 用synchronized修饰方法，同一时刻只能有一个线程执行此方法。 同步方法无法自己选择锁对象。对于非静态方法，锁对象是this；对于静态方法，锁对象是当前类的Class对象。 使用的时候就要判断锁对象合不合适。 Lock​ 在 Java 5 之后提供了一种新的方式来确保线程安全，可以通过显式定义同步锁对象来实现同步。 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。ReentrantLock是该接口的实现类。  "},{"title":"线程的通信​","type":1,"pageTitle":"Java","url":"docs/notes/java/#线程的通信","content":"在 Object 类中定义了一些方法。 wait在被手动唤醒之前一直暂停此线程，必须由锁对象（线程监视器对象）来调用notify唤醒一个正在等待的线程，从上次暂停的地方继续执行notifyAll唤醒所有正在等待的线程，在多个生产者和多个消费者的时候注意用 wait()和sleep() Object.wait()会释放锁，Thread.sleep()不会释放锁。 生产者和消费者问题。 package org.example.thread_test; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ProducerConsumerTest { public static void main(String[] args) { ExecutorService pool = Executors.newFixedThreadPool(7); Clerk clerk = new Clerk(); Producer producer = new Producer(clerk); Consumer consumer = new Consumer(clerk); pool.execute(producer); pool.execute(consumer); pool.shutdown(); } } @Slf4j class Producer implements Runnable { private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { clerk.add(); } } } @Slf4j class Consumer implements Runnable { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { clerk.minus(); } } } @Slf4j class Clerk { private int count = 0; public static final int MAX = 20; public synchronized void add() { try { Thread.sleep(100L); } catch (InterruptedException e) { e.printStackTrace(); } if (count &lt; MAX) { log.info(&quot;生产 1，剩余 {}&quot;, ++count); notify(); } else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } public synchronized void minus() { try { Thread.sleep(100L); } catch (InterruptedException e) { e.printStackTrace(); } if (count &gt; 0) { log.info(&quot;消费 1，剩余 {}&quot;, --count); notify(); } else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } }  "},{"title":"懒汉单例模式的线程安全问题​","type":1,"pageTitle":"Java","url":"docs/notes/java/#懒汉单例模式的线程安全问题","content":"常规方法，使创建对象的操作互斥，只允许创建一个对象。 class Lazy { private static Lazy INSTANCE; private Lazy() { } public static Lazy getInstance() { if (INSTANCE == null) { // 外层判断为了提高效率 // 当内层已经创建好对象之后，其它线程和创建对象的线程就不是竞争关系了 // 可以直接去取已经创建好的实例 synchronized (Lazy.class) { if (INSTANCE == null) { // 内层判断为了安全 INSTANCE = new Lazy(); } } } return INSTANCE; } }  还有一种更简单的方法，利用内部类不会随着外部类的初始化而初始化的特点，完成懒汉单例。 class SimpleLazy { private SimpleLazy() { } public static SimpleLazy getInstance() { return Inner.INSTANCE; } // 内部类不会随着外部类的初始化而初始化 // 静态代码不会随着外部类的初始化而执行 // 而是在使用的时候才会初始化 private static class Inner { public static final SimpleLazy INSTANCE = new SimpleLazy(); } }  "},{"title":"ThreadLocal​","type":1,"pageTitle":"Java","url":"docs/notes/java/#threadlocal","content":"数据容器，和线程绑定。每个线程得到的值不一样。 "},{"title":"枚举类​","type":1,"pageTitle":"Java","url":"docs/notes/java/#枚举类","content":"Java 5 之后，有了enum关键字，可以更方便地实现枚举类。 枚举类型不能继承其它类型，因为枚举类型的每个实例实际上继承了java.lang.Enum抽象类。 protected Enum(String name, int ordinal); public final String name(); public final int ordinal();  在编译的时候编译器会将enum真正转化为Enum的子类，所以可以使用该类的方法。 并且Enum类重写了toString()方法，默认返回name属性值。 Enum类中还有一个静态方法valueOf，可以获取对应值的枚举类实例。 public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name)  还有一个values方法不是继承的，而是编译器添加的。它存在于每个枚举类中，能获取到该类的对应值的枚举类实例。 public static T[] values()  枚举类可以实现接口，并且每个常量可以分别对接口有不同的实现。也可以统一实现接口，跟正常用法一样。 public class Test6 { public static void main(String[] args) { MyEnum.A.test(); // a MyEnum.B.test(); // b MyEnum.C.test(); // 统一实现 } } interface MyInterface { void test(); } enum MyEnum implements MyInterface { A { @Override public void test() { System.out.println(&quot;a&quot;); } }, B { @Override public void test() { System.out.println(&quot;b&quot;); } }, C; @Override public void test() { System.out.println(&quot;统一实现&quot;); } }  "},{"title":"注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/#注解","content":"其实也是一种注释，是代码级别的注释，会被编译器处理。普通注释会被编译器直接忽略。不直接修改程序逻辑，可以通过反射读取出注解信息，根据需要作出不同行为。 "},{"title":"预定义注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/#预定义注解","content":"@Override，标注在方法上，在编译时会检查这个方法是否符合重写的要求，一定确保这个方法成功重写了父类的方法。给程序员看的时候也能快速看出这是一个重写的方法。@Deprecated，标注方法，表明该方法已弃用，有更好的实现供选择。@SuppressWarnings，抑制编译时的警告信息，可以作用在类、类成员、方法参数等。会抑制在该类型作用域内的所有警告信息。value参数可以传入具体抑制哪种警告，或者传入「all」抑制所有警告信息。 "},{"title":"文档注释相关注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/#文档注释相关注解","content":"@author@param@return@see@since@version@exception@throws... "},{"title":"自定义注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/#自定义注解","content":"定义注解​ 属性的数据类型有限制： 基本数据类型String枚举ClassAnnotaion以上这些类型的数组 属性可以有默认值，可以通过default关键字来实现。 @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface Test7 { String value() default &quot;111&quot;; String[] name(); }  元注解​ 标注在注解声明处的注解。 @Target指明注解可以标注的位置。@Retention指明注解的生命周期。 SOURCE只在源码阶段有效，就跟普通的注释一样，编译的时候丢弃CLASS在编译的时候会保存到字节码文件中，但是虚拟机不会在运行时保留，默认是这个级别RUNTIME会在运行时保留，可以通过反射读取 @Documented被 javadoc 读取。@Inherited继承的时候也会继承到注解。 使用​ 在合适位置标注，以@开头。 如果注解没有属性，不需要加括号。 如果注解只需传入一个value属性，则直接传入属性即可。 如果需要传入的属性有多个，或者传入的单个属性不是value，则需要使用键值对的形式传入对应的值。 如果传入的属性要求是数组，在数组只有一个元素的情况下可以省略花括号{}。 @Test7(value = &quot;&quot;, name = &quot;&quot;) @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface Test7 { String value(); String[] name(); }  读取​ 参考反射相关知识。 "},{"title":"Java 8 注解新特性​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-8-注解新特性","content":"@Repeatable可重复注解​ 在 JDK8 之前如果需要重复注解的话，需要新建一个注解，其中包含目标注解的数组，通过数组来重复使用注解。 在 JDK8 中新增了一个元注解@Repeatable，还是需要一个新的注解包含目标注解的数组，但是不需要用数组的方式传递了，直接标注多个同类型的注解即可。 类型注解​ @Target的参数ElementType的枚举值多了两个： TYPE_PARAMETER：表明注解可以使用在类型变量的声明语句中，如泛型声明；TYPE_USE：表示注解能使用在任何类型的语句中，泛型、变量类型转换、抛出的异常。 "},{"title":"常用类​","type":1,"pageTitle":"Java","url":"docs/notes/java/#常用类","content":""},{"title":"Object​","type":1,"pageTitle":"Java","url":"docs/notes/java/#object","content":"Object是所有类的根父类。 equals，比较两个对象，默认行为和比较运算符==相同，都是比较内存地址，子类可以根据需要对该方法进行重写，对内容进行比对；hashCode，默认根据内存地址计算对象的哈希值，如果重写了equals方法则原则上需要重写此方法；clone，返回对象的复制，是一个protected方法，子类需要重写此方法并调用super.clone()，也可以自己实现克隆细节，并实现Cloneable接口；finalize，在对象被回收之前垃圾回收器会调用此方法，子类可以重写此方法来在被回收之前做一些事情；可以通过System.gc()或Runtime.getRuntime().gc()来通知垃圾回收器进行回收，但是否会进行回收是不确定的；toString，返回对象的字符串表示，建议所有子类重写。默认返回「类名@十六进制 hash」。getClass，获取当前对象的运行时类名。 "},{"title":"包装类​","type":1,"pageTitle":"Java","url":"docs/notes/java/#包装类","content":"Java 提供了 8 种基本数据类型的包装类，使得基本数据类型的变量具有类的特征。 基本数据类型\t包装类byte\tByte short\tShort int\tInteger long\tLong float\tFloat double\tDouble boolean\tBoolean char\tCharacter 其中，Byte、Short、Integer、Long、Float和Double都是Number的子类。 自动装箱与自动拆箱​ JDK 1.5 提供的自动拆箱和自动封箱的机制可以让基本数据类型和包装类自动转换。在需要的时候，自动在基本数据类型和包装类之间转换。 Integer a = 5; int b = a;`  缓存​ 为了提高性能，比较常用的基本数据类型的包装类会被缓存。 通过new关键字获取的对象在堆中，直接得到的包装类在方法区中，这个才是被缓存的。 基本数据类型\t包装类\t缓存byte\tByte\t[−128,127][-128,127][−128,127] short\tShort\t[−128,127][-128,127][−128,127] int\tInteger\t[−128,127][-128,127][−128,127] long\tLong\t[−128,127][-128,127][−128,127] float\tFloat\t不缓存 double\tDouble\t不缓存 char\tCharacter\t[0,127][0,127][0,127] boolean\tBoolean\ttrue和false 常用 API​ 字符串解析​ 各个包装类都有一个parseXxx的方法，用于从字符串中解析出对应类型的值，返回包装类。 public static int parseInt(String s) throws NumberFormatException  Integer​ MAX_VALUEint 类型可表示的最大值，2^{31}-1231−1MIN_VALUE最小值，-2^{31}−231toBinaryString转为二进制字符串toOctalString八进制toHexString十六进制 Character​ toUpperCasetoLowerCase "},{"title":"System​","type":1,"pageTitle":"Java","url":"docs/notes/java/#system","content":"包含三个流： PrintStream outInputStream inPrintStream err 这是系统默认的输出流，可以通过setIn、SetOut、SetErr来替换掉系统默认的输出流。 常用方法： currentTimeMillis()arraycopy(Object src, int srcPos, Object dest, int destPos, int length)exit(int status)getProperty(String key) "},{"title":"String​","type":1,"pageTitle":"Java","url":"docs/notes/java/#string-1","content":"与基本数据类型的转换​ String-&gt;基本数据类型 使用各个包装类的方法，使用的时候注意可能会抛出异常 Integer.parseInt()Float.parseFloat() 基本数据类型-&gt;String String.valueOf()使用连接运算符+，1 + &quot;&quot; = &quot;1&quot; 特殊性​ 通过字面量声明的 String 对象存在常量池中，是不可变的，只要修改了字符串就会产生新对象。通过new关键字取得的字符串对象不在常量池中。 常量池里的对象可以共享，提高性能。 常量池位置​ Java 6，在方法区； Java 7，在堆中专门划分了一块区域来存储字符串常量； Java 8，在元空间（Meta space）中，类似于方法区，甚至可以独立于 JVM 存在。 底层存储结构​ Java 8，使用char[]存储； Java 9，使用byte[]存储。 不可变性​ char[]使用final修饰，意味着数组不能扩容。同时它也是私有的，外部也不能修改某一个元素的值；String 提供的所有对字符串修改的方法都会返回一个新对象。 字面量和直接创建对象的不同​ String str = new String(&quot;str&quot;);  在这个过程中产生了两个对象；&quot;str&quot;是一个对象，在常量池；又通过new关键字得到一个对象，在堆。两者的char values[]指向相同的地址。具体代码在 String 的构造器中。 拼接​ String s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; String s3 = &quot;helloworld&quot;; String s4 = s1 + &quot;world&quot;; String s5 = s1 + s2; String s6 = &quot;hello&quot; + &quot;world&quot;; System.out.println(s3 == s4); // false System.out.println(s3 == s5); // false System.out.println(s3 == s6); // true  只要有变量参与的拼接，结果都在堆中。s6在编译期间就可以确定结果，所以存在常量池中。 如果给 s1 和 s2 加上final修饰，那么结果都为true。 常用方法​ equals(Object anObject)equalsIgnoreCase(String anotherString)compareTo(String anotherString)compareToIgnoreCase(String str)intern()把字符串放入常量池，并返回引用length()isEmpty()concat(String str)与另一个字符串相连接，相当于+trim()移除开头和结尾的空白字符substring(begin, end)返回子字符串，索引从 0 开始，包含包含左边不包含右边。左闭右开toCharArray()转为字符数组getBytes()转为字节数组 字典排序​ String 实现了Comparable接口，但是默认是按照 Unicode 编码值排序。 java.lang.Collator类实现了Comparator接口，可以选择各地的语言习惯来排序。 在有拼音排序的需求的时候可以采用这个方法来实现。 Collator collator = Collator.getInstance(Locale.CHINESE); int compare = collator.compare(&quot;差&quot;, &quot;啊&quot;); System.out.println(compare);  "},{"title":"StringBuffer​","type":1,"pageTitle":"Java","url":"docs/notes/java/#stringbuffer","content":"可变字符序列。线程安全。效率更低。而StringBuilder相反。默认容量是 16。 没有重写equals方法，比较的是内存地址。 "},{"title":"StringBuilder​","type":1,"pageTitle":"Java","url":"docs/notes/java/#stringbuilder","content":"可变字符序列，Java 5 新增，非线程安全。默认长度是 16，在需要的时候会自动扩容到原来长度的 2 倍再加上 2。 没有重写equals方法，比较的是内存地址。 appendinsertdelete "},{"title":"Math​","type":1,"pageTitle":"Java","url":"docs/notes/java/#math","content":"abs绝对值三角函数sqrt平方根pow幂运算round四舍五入ceil返回比参数大的最近一个整数floor返回比参数小的最近一个整数 "},{"title":"Random​","type":1,"pageTitle":"Java","url":"docs/notes/java/#random","content":"nextInt(int)，随机返回一个在[0,i−1][0,i-1][0,i−1]之间的数。 // 返回一个 [left, right] 之间的数 public static int randomInt(int left, int right) { Random random = new Random(); return random.nextInt(right - left + 1) + left; }  "},{"title":"BigInteger​","type":1,"pageTitle":"Java","url":"docs/notes/java/#biginteger","content":"支持更大的范围，多了一些运算方法。 "},{"title":"BigDecimal​","type":1,"pageTitle":"Java","url":"docs/notes/java/#bigdecimal","content":"精度更高。注意 buyo addsubtractmultiplydivide "},{"title":"日期时间​","type":1,"pageTitle":"Java","url":"docs/notes/java/#日期时间","content":""},{"title":"旧日期时间​","type":1,"pageTitle":"Java","url":"docs/notes/java/#旧日期时间","content":"Date​ 除了下面两个构造器，其它的都过时了。 Date()当前日期获得对象Date(long date)毫秒时间戳转为日期 其中大部分方法也已经过时，可以被Calendar或者DateFormat中的方法替换。 java.sql.Date是 java.util.Date的子类，无特殊需要的情况下均用java.util.Date。 Calendar​ 这是一个抽象类，可以使用它的实现类GregorianCalendar。可以通过Calendar.getInstance()来获取它的实例。 getInstance()获取实现类的实例getInstance(Locale aLocale)getInstance(TimeZone zone)get(int field)通过常量值来获取当前日历对象的某个字段值，比如年份 TimeZone​ 抽象类，可以用静态方法getTimeZone来获取实现类的实例。 getTimeZone(String ID)getAvailableIDs()获取所有时区 id DateFormat​ 这也是一个抽象类，用的是SimpleDateFormat。 SimpleDateFormat(String pattern)构造器，出入格式化字符串format(Date date)将日期对象格式化，返回字符串parse(String source)按照格式将字符串解析为日期对象 "},{"title":"新日期时间​","type":1,"pageTitle":"Java","url":"docs/notes/java/#新日期时间","content":"Java 8 引入了新的日期时间 API。新的对象是不可变的，修改会产生新对象。 新引入了另一套处理日期时间的体系，Date 可以通过toInstant()方法转为新 API。 LocalDate​ yyyy-MM-dd格式的日期。 LocalTime​ 只有时间。 LocalDateTime​ 日期时间。 static now()基于现在的时间创建对象static of()给定日期时间创建对象getMonthgetXxxwithMonth修改月份并返回一个新对象withXxxplusXxx加时间minusXxx减时间isLeapYear是否是闰年format格式化，返回字符串static parse给定字符串和格式解析为时间对象 Duration​ 时间之间的间隔。更精确。 Period​ 日期之间的间隔。 Instant​ 瞬时时间。可以精确到纳秒。从 1970 年的开始算的。没有其它任何上下文信息。 ZonedDateTime​ 带时区的时间。 TemporalAdjuster​ 时间调整期，这是一个接口。在TemporalAdjusters中有许多方法可以得到它的实例。 DateTimeFormatter​ 格式化器。可以用来格式化日期或从字符串解析出日期时间。 ofPattern "},{"title":"工具类​","type":1,"pageTitle":"Java","url":"docs/notes/java/#工具类","content":""},{"title":"Arrays​","type":1,"pageTitle":"Java","url":"docs/notes/java/#arrays","content":"copyOf System.arraycopy() sort "},{"title":"Collections​","type":1,"pageTitle":"Java","url":"docs/notes/java/#collections","content":"Collection 相关的工具类，其中包含了大量的静态方法，方法的参数或者返回值是 Collection。 "},{"title":"Objects​","type":1,"pageTitle":"Java","url":"docs/notes/java/#objects","content":""},{"title":"Spliterators​","type":1,"pageTitle":"Java","url":"docs/notes/java/#spliterators","content":""},{"title":"Files​","type":1,"pageTitle":"Java","url":"docs/notes/java/#files","content":""},{"title":"Paths​","type":1,"pageTitle":"Java","url":"docs/notes/java/#paths","content":""},{"title":"常用接口​","type":1,"pageTitle":"Java","url":"docs/notes/java/#常用接口","content":""},{"title":"Comparable​","type":1,"pageTitle":"Java","url":"docs/notes/java/#comparable","content":"自然排序。需要比较的对象自身实现此接口。String及包装类都实现了此接口。 public int compareTo(T o);  "},{"title":"Compartor​","type":1,"pageTitle":"Java","url":"docs/notes/java/#compartor","content":"定制排序。作为一个比较器，参数需要放入两个对比的对象。 int compare(T o1, T o2);  "},{"title":"Serializable​","type":1,"pageTitle":"Java","url":"docs/notes/java/#serializable","content":""},{"title":"集合​","type":1,"pageTitle":"Java","url":"docs/notes/java/#集合","content":" "},{"title":"Collection​","type":1,"pageTitle":"Java","url":"docs/notes/java/#collection","content":"是单列数据结构的父接口。 for 循环遍历​ 通过size()方法得到集合的长度，通过元素下标遍历，下标从 0 开始。 迭代器遍历​ 调用Iterable#iterator()方法来得到迭代器对象，每次调用都会得到一个新的迭代器对象。 Iterator&lt;E&gt; iterator() 迭代器是一次性使用的，元素的顺序不能保证，只能向后遍历，不能回溯。Java 8 新加入了forEachRemaining方法，可以用函数式接口完成遍历。 boolean hasNext()E next()void remove()void forEachRemaining(Consumer&lt;? super E&gt; action) 在迭代器的过程中不能使用集合本身的有关元素修改的操作如add()和remove()，不然迭代器在下次迭代的时候会抛出异常，这样做的是为了避免同步问题。 在AbstractList中有一个modCount变量，在涉及到对列表元素进行修改的方法中会将modCount++。在迭代器Itr构造的时候会保存当前的modCount值为expectedModCount，在每次迭代和remove()之前都会比对这两个值，如果不相等则意味着在迭代器之外有操作对列表元素进行了修改，为了避免同步问题就会抛出ConcurrentModificationException异常。 如果没有调用next()直接调用remove()，或者在调用了next()之后调用了两次remove()，都会抛出IllegalStateException异常。迭代器Ite中维护了一个lastRet变量，默认是-1，在调用next()之后会更新为当前元素的下标，在调用remove()之后会更新为-1，在调用remove()之前会对其进行检查，如果从来没有调用过next()或者调用两次remove()的时候会抛出异常。 for-each 循环​ Java 5 中新增的语法糖，实际上调用的是迭代器的方法，所以有和迭代器一样的限制。数组也可以用这种方式遍历。注意遍历过程中的元素变量只是局部变量。 for(Person p: persons){ System.out.println(p); }  "},{"title":"List​","type":1,"pageTitle":"Java","url":"docs/notes/java/#list","content":"Vector出现较早（Java 1.0），是线程安全的，效率低ArrayList出现较晚（Java 1.2），是非线程安全的，效率高LinkedList的数据结构是双向链表，其它两者的数据结构是数组，因此对于频繁的插入、删除操作，LinkedList的效率更高 "},{"title":"Set​","type":1,"pageTitle":"Java","url":"docs/notes/java/#set","content":"无序、不可重复的数据结构。底层用的是Map，只用了 key 的那一列。 HashSet，无序，线程不安全，可以存储null值，底层用HashMapLinkedHashSet，元素可以按照添加的顺序遍历，是HashSet的子类，底层用LinkedHashMapTreeSet，可以对添加的对象进行排序，底层用TreeMap "},{"title":"Queue​","type":1,"pageTitle":"Java","url":"docs/notes/java/#queue","content":"LinkedList是Deque的实现类，可以当作栈或队列使用。 \tThrows exception\tReturns special valueInsert\tadd(e)\toffer(e) Remove\tremove()\tpoll() Examine\telement()\tpeek() 有一个子接口Deque。 这些方法可以当作栈使用。 Stack Method\tEquivalent Deque Methodpush(e)\taddFirst(e) pop()\tremoveFirst() peek()\tpeekFirst() 这些方法可以当作双向队列使用。 \tFirst Element (Head)\tFirst Element (Head)\tLast Element (Tail)\tLast Element (Tail)\tThrows exception\tSpecial value\tThrows exception\tSpecial value Insert\taddFirst(e)\tofferFirst(e)\taddLast(e)\tofferLast(e) Remove\tremoveFirst()\tpollFirst()\tremoveLast()\tpollLast() Examine\tgetFirst()\tpeekFirst()\tgetLast()\tpeekLast() "},{"title":"Map​","type":1,"pageTitle":"Java","url":"docs/notes/java/#map","content":"是双列数据结构的顶层接口。Map 的底层也是数组，每个位置放的都是一个Entry，其中包含了 key 和 value。 Hashtable，Java 1.0 引入，当时还没有Map接口，后来 Java 1.2 抽取 Map 接口，Hashtable是线程安全的，其中table是小写，key 不能是nullProperties，Hashtable的子类，用于读取和写入.properties文件，内容也是键值对的形式，key 和 value 都是String类型HashMap，Map的主要实现类，非线程安全，key 可以为nullLinkedHashMap，存储key的时候不仅仅存储 key 的内容，而是存储了一个双向链表的节点，可以按照元素加入的顺序来遍历TreeMap，底层用红黑树，是排序二叉树的一种 "},{"title":"泛型​","type":1,"pageTitle":"Java","url":"docs/notes/java/#泛型","content":"可以在编译期间进行类型检查，更安全。避免了强制类型转换，更方便。 "},{"title":"泛型类/接口​","type":1,"pageTitle":"Java","url":"docs/notes/java/#泛型类接口","content":"class/interface 类名&lt;T1, T2&gt; extends .... { T1 t1; T2 t2; public T1 fn(T2 t2){ } }  如果在实例化时没有指定泛型，则认为此泛型类型为Object静态方法/静态成员不能用类声明的泛型 "},{"title":"泛型方法​","type":1,"pageTitle":"Java","url":"docs/notes/java/#泛型方法","content":"只有声明了泛型参数列表的方法才是泛型方法，泛型方法声明的泛型参数列表只能在这个方法中使用。不论其所在的类是否是泛型类。 //修饰符 泛型 返回值类型 方法名 参数列表 public &lt;T extends Object&gt; T[] toArray(T ...a);  "},{"title":"类型通配符​","type":1,"pageTitle":"Java","url":"docs/notes/java/#类型通配符","content":"&lt;?&gt;任意类型，除了null外不让存，可以取，取出来是Object类型的&lt;? extends Xxx&gt;必须是继承此类&lt;T extends Number &amp; Serializable&gt;，可以有多个限制，但是父类只能有一个，并且必须写在第一位，后面可以跟多个接口&lt;? super Xxx&gt;必须是此类的父类 "},{"title":"I/O​","type":1,"pageTitle":"Java","url":"docs/notes/java/#io","content":"流的分类： 操作数据单位 字节流字符流 数据的流向 输入流输出流 流的角色 节点流处理流  \tByte Based Input\tByte Based Output\tCharacter Based Input\tCharacter Based OutputBasic\tInputStream\tOutputStream\tReader InputStreamReader\tWriter OutputStreamWriter Arrays\tByteArrayInputStream\tByteArrayOutputStream\tCharArrayReader\tCharArrayWriter Files\tFileInputStream RandomAccessFile\tFileOutputStream RandomAccessFile\tFileReader\tFileWriter Pipes\tPipedInputStream\tPipedOutputStream\tPipedReader\tPipedWriter Buffering\tBufferedInputStream\tBufferedOutputStream\tBufferedReader\tBufferedWriter Filtering\tFilterInputStream\tFilterOutputStream\tFilterReader\tFilterWriter Parsing\tPushbackInputStream StreamTokenizer PushbackReader LineNumberReader Strings StringReader\tStringWriter Data\tDataInputStream\tDataOutputStream Data - Formatted PrintStream PrintWriter Objects\tObjectInputStream\tObjectOutputStream Utilities\tSequenceInputStream  表格内容来自 Java IO Tutorial (jenkov.com)。 "},{"title":"File​","type":1,"pageTitle":"Java","url":"docs/notes/java/#file","content":"代表一个文件或目录。 "},{"title":"RandomAccessFile​","type":1,"pageTitle":"Java","url":"docs/notes/java/#randomaccessfile","content":"支持随机读写的文件。对象中维护了一个指针，所有对文件的读写都相对于当前的指针。 "},{"title":"转换流​","type":1,"pageTitle":"Java","url":"docs/notes/java/#转换流","content":"下面的两个类可以将字节流转换为字符流。 InputStreamReaderOutputStreamWriter "},{"title":"打印流​","type":1,"pageTitle":"Java","url":"docs/notes/java/#打印流","content":"PrintStream，是OutputStream的子类PrintWriter，是Writer的子类 System.in、System.out和System.err都是PrintStream。 PrintWriter少了一些参数为byte[]的方法，不能直接写出字节，其它方法都差不多。 以上两者的输出方法都不会抛出 I/O 异常。 "},{"title":"数据流​","type":1,"pageTitle":"Java","url":"docs/notes/java/#数据流","content":"DataInputStreamDataOutputStream 将基本数据类型和String持久化和读入。 "},{"title":"对象流​","type":1,"pageTitle":"Java","url":"docs/notes/java/#对象流","content":"ObjectInputStreamObjectOutputStream 将基本数据类型和String持久化和读入。 对象的序列化和反序列化操作。 在序列化和反序列化的过程中会忽略掉静态成员变量和用transient修饰的成员变量。 要求被操作的类实现java.io.Serializable或java.io.Externalizable接口。 private static final long serialVersionUID用于标识当前对象的版本号，如果不显式声明的话系统会根据类的结构自动计算一个并写入到序列化的结果中。在反序列化的时候会将内存中加载的类的serialVersionUID和序列化结果中的serialVersionUID对比，如果不相同则抛出InvalidClassException异常。 如果显式声明了该字段，并且两个类结构不相同的情况下，反序列化的过程中会尽量读取变量值。如果新增了字段则该字段为默认值，如果删除了字段则忽略该字段；如果更改了字段的类型则会抛出InvalidClassException异常。 在反序列化的过程中可能会抛出ClassNotFoundException。 "},{"title":"NIO​","type":1,"pageTitle":"Java","url":"docs/notes/java/#nio","content":"Java 1.4 引入，更高效的流操作。 "},{"title":"NIO 2​","type":1,"pageTitle":"Java","url":"docs/notes/java/#nio-2","content":"Java 7 引入，对 NIO 进行了扩展。 "},{"title":"Path​","type":1,"pageTitle":"Java","url":"docs/notes/java/#path","content":""},{"title":"Paths​","type":1,"pageTitle":"Java","url":"docs/notes/java/#paths-1","content":""},{"title":"Files​","type":1,"pageTitle":"Java","url":"docs/notes/java/#files-1","content":""},{"title":"网络编程​","type":1,"pageTitle":"Java","url":"docs/notes/java/#网络编程","content":""},{"title":"InetAddress​","type":1,"pageTitle":"Java","url":"docs/notes/java/#inetaddress","content":""},{"title":"ServerSocket​","type":1,"pageTitle":"Java","url":"docs/notes/java/#serversocket","content":"TCP 服务端。 "},{"title":"Socket​","type":1,"pageTitle":"Java","url":"docs/notes/java/#socket","content":"TCP 客户端。 "},{"title":"DatagramSocket​","type":1,"pageTitle":"Java","url":"docs/notes/java/#datagramsocket","content":"UDP，不分服务端与客户端。 非面向连接，不可靠的。 "},{"title":"DatagramPacket​","type":1,"pageTitle":"Java","url":"docs/notes/java/#datagrampacket","content":"UDP 数据包。 "},{"title":"URL​","type":1,"pageTitle":"Java","url":"docs/notes/java/#url","content":""},{"title":"反射​","type":1,"pageTitle":"Java","url":"docs/notes/java/#反射","content":"Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 "},{"title":"获取 Class 实例的方式​","type":1,"pageTitle":"Java","url":"docs/notes/java/#获取-class-实例的方式","content":"Object.classnew Object().getClass()Class.forName(&quot;com.example.A&quot;)&lt;当前类&gt;.class.getClassLoader().loadClass(&quot;com.example.A&quot;) "},{"title":"Class 对象的类型​","type":1,"pageTitle":"Java","url":"docs/notes/java/#class-对象的类型","content":"class类interface接口[]数组，只要数据类型和维度相同就是同一种 Classenum枚举@interface注解基本数据类型void "},{"title":"动态代理​","type":1,"pageTitle":"Java","url":"docs/notes/java/#动态代理","content":"使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 JDK 提供的动态代理要求被代理类必须实现接口。 "},{"title":"Proxy​","type":1,"pageTitle":"Java","url":"docs/notes/java/#proxy","content":"java.lang.reflect.Proxy是专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException  创建代理对象的过程就是创建了一个实现了接口的子类对象，并没有创建被代理的对象。 public class ProxyTest { public static void main(String[] args) { Handler handler = new Handler(); handler.setInstance(new A()); Object instance = Proxy.newProxyInstance(A.class.getClassLoader(), A.class.getInterfaces(), handler); ((Inter) instance).say(&quot;hello&quot;); } } class Handler implements InvocationHandler { private Inter instance; public void setInstance(Inter instance) { this.instance = instance; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { for (Class&lt;?&gt; anInterface : proxy.getClass().getInterfaces()) { System.out.println(anInterface); } System.out.println(method); args[0] = &quot;replace&quot;; return instance == null ? null : method.invoke(instance, args); } }  "},{"title":"新特性​","type":1,"pageTitle":"Java","url":"docs/notes/java/#新特性","content":""},{"title":"Java 7​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-7","content":"switch 支持 String​ try-with-resources​ NIO 2​ 泛型推断​ "},{"title":"Java 8​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-8","content":"函数式（Functional）接口​ 单方法接口。   Lambda 表达式​ 简化 SAM（Single Abstract Method）接口实现的语法糖。 （形参列表）-&gt;{Lambda 体}  如果 Lambda 体里面只有一句话，则可以省略{}以及里面的分号；如果形参列表中形参类型是已知的，那么数据类型可以省略；如果形参列表只有一个形参，并且数据类型可以省略，则可以省略括号；如果只有一句ruturn语句，可以省略return；如果没有形参，()不能省略。 方法引用与构造器引用​ 当 Lambda 体的实现是调用一个现有的方法来实现，并且抽象方法的参数列表与该方法的参数列表对象，那么就可以使用方法引用来简化。 list.forEach(num -&gt; System.out.println(num)); list.forEach(System.out::println);  如果第一个形参是调用方法的，剩下的都作为此方法的参数，也可以使用方法引用。 Arrays.sort(arr, (e1, e2) -&gt; {e1.compareToIgnoreCase(e2)}); Arrays.sort(arr, String::compareToIgnoreCase);  构造器引用，当 Lambda 的方法体是通过创建对象实现的，并且形参列表一致。 Supplier&lt;String&gt; s = String::new; // String[]::new 数组构造器  Stream API​ 数据加工流。 Stream 不负责存储数据，它只负责对数据进行处理Stream 不会改变源对象，每次处理都会返回一个有结果的新 StreamStream 是延迟执行的，在获取结果的时候才会执行之前的操作方法 创建​ &lt;集合对象&gt;.stream()Arrays.stream(arr)static &lt;T&gt; Stream&lt;T&gt; of(T... values)static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)产生一个无限流static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; f)无限流 中间操作​ Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)Stream&lt;T&gt; distinct()Stream&lt;T&gt; limit(long maxSize)Stream&lt;T&gt; skip(long n)static concat()合并两个流Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)对每个元素执行操作，相当于 forEach，但是不是终止操作Stream&lt;T&gt; sorted()Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)对每个元素执行操作，返回该函数返回的元素组成的流&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper) 终结操作​ void forEach(Consumer&lt;? super T&gt; action)long count()boolean allMatch(Predicate&lt;? super T&gt; predicate)boolean anyMatch(Predicate&lt;? super T&gt; predicate)boolean noneMatch(Predicate&lt;? super T&gt; predicate)Optional&lt;T&gt; findFirst()返回第一个元素Optional&lt;T&gt; findAny()返回任意一个Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)相当于 JS 中的 reduce，从左到右依次处理元素值，identity 是初始值，每次 accumulator 的返回值会累加到 identity 上，最后返回该值。&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)把流中的数据收集起来，在Collectors中有许多方法来提供Collectoer的实现类。 Optional​ 单值容器。 public static &lt;T&gt; Optional&lt;T&gt; of(T value)存值public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)可以存 null，如果是 null 则返回空 Optionalstatic &lt;T&gt; Optional&lt;T&gt; empty()直接返回一个空的容器public boolean isPresent()public T get()public void ifPresent(Consumer&lt;? super T&gt; consumer)public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)public T orElse(T other)如果不是空的返回容器中的值，如果是空的返回另一个值public T orElseGet(Supplier&lt;? extends T&gt; other)如果是空的执行方法，返回该方法的返回值public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)public &lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper) 接口中的默认方法和静态方法​ 在之前的接口笔记中有介绍。 新的日期时间 API​ 在之前的笔记中有提及。 "},{"title":"Java 9​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-9","content":"模块化系统​ 在src目录下用module-info.java文件来声明模块信息。 通过module、export和requires关键字来声明模块信息。 交互式编程环境 jShell​ 类似于python和node的命令行交互式编程环境。 接口私有方法​ Java 9 中接口方法可以用private修饰。 匿名实现类使用泛型​ 在 Java 8 中，匿名实现类不能声明泛型，Java 9 中可以。  局部变量类型推断​ 使用var关键字，在代码块中声明变量时可以省略掉变量的类型。 "},{"title":"Java 10​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-10","content":""},{"title":"Java 11​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-11","content":""},{"title":"jdbc","type":0,"sectionRef":"#","url":"docs/notes/java/jdbc","content":"jdbc","keywords":""},{"title":"jvm","type":0,"sectionRef":"#","url":"docs/notes/java/jvm","content":"jvm","keywords":""},{"title":"junit","type":0,"sectionRef":"#","url":"docs/notes/java/junit","content":"junit","keywords":""},{"title":"logback","type":0,"sectionRef":"#","url":"docs/notes/java/logback","content":"logback","keywords":""},{"title":"lombok","type":0,"sectionRef":"#","url":"docs/notes/java/lombok","content":"lombok","keywords":""},{"title":"mybatis","type":0,"sectionRef":"#","url":"docs/notes/java/mybatis","content":"mybatis","keywords":""},{"title":"maven","type":0,"sectionRef":"#","url":"docs/notes/java/maven","content":"maven","keywords":""},{"title":"mybatis-plus","type":0,"sectionRef":"#","url":"docs/notes/java/mybatis-plus","content":"mybatis-plus","keywords":""},{"title":"netty","type":0,"sectionRef":"#","url":"docs/notes/java/netty","content":"netty","keywords":""},{"title":"okhttp","type":0,"sectionRef":"#","url":"docs/notes/java/okhttp","content":"okhttp","keywords":""},{"title":"retrofit","type":0,"sectionRef":"#","url":"docs/notes/java/retrofit","content":"retrofit","keywords":""},{"title":"spring","type":0,"sectionRef":"#","url":"docs/notes/java/spring","content":"spring","keywords":""},{"title":"spring-boot","type":0,"sectionRef":"#","url":"docs/notes/java/spring-boot","content":"spring-boot","keywords":""},{"title":"spring-cloud","type":0,"sectionRef":"#","url":"docs/notes/java/spring-cloud","content":"spring-cloud","keywords":""},{"title":"spring-cloud-alibaba","type":0,"sectionRef":"#","url":"docs/notes/java/spring-cloud-alibaba","content":"spring-cloud-alibaba","keywords":""},{"title":"spring-mvc","type":0,"sectionRef":"#","url":"docs/notes/java/spring-mvc","content":"spring-mvc","keywords":""},{"title":"spring-security","type":0,"sectionRef":"#","url":"docs/notes/java/spring-security","content":"spring-security","keywords":""},{"title":"thymeleaf","type":0,"sectionRef":"#","url":"docs/notes/java/thymeleaf","content":"thymeleaf","keywords":""},{"title":"TypeScript","type":0,"sectionRef":"#","url":"docs/notes/javascript/typescript","content":"","keywords":""},{"title":"基本类型​","type":1,"pageTitle":"TypeScript","url":"docs/notes/javascript/typescript#基本类型","content":"在声明变量时指定类型。如果在声明时直接赋值则 TS 会自动推断类型。 let a: number; let b = true;  类型\t例子\t描述number 数字 string 字符串 boolean 布尔值 字面量 限制类型和值就只能是当前字面量本身 any 任意类型 unknown 类型安全的 any void 没有值或 undefined never 没有值，不能是任何值 object 任意 JavaScript 对象 array 数组 tuple 固定长度数组 enum 枚举 可以使用|来连接多个类型。 let a: &quot;male&quot; | &quot;female&quot; let b: number | boolean  "},{"title":"微信小程序","type":0,"sectionRef":"#","url":"docs/notes/javascript/weapp","content":"","keywords":""},{"title":"组件库​","type":1,"pageTitle":"微信小程序","url":"docs/notes/javascript/weapp#组件库","content":"wechat-miniprogram/weui-miniprogram: 小程序 WeUI 组件库youzan/vant-weapp: 轻量、可靠的小程序 UI 组件库 "},{"title":"功能库​","type":1,"pageTitle":"微信小程序","url":"docs/notes/javascript/weapp#功能库","content":"jin-yufeng/mp-html: 小程序富文本组件，支持渲染和编辑 html，支持在微信、QQ、百度、支付宝、头条和 uni-app 平台使用NewFuture/miniprogram-network: Redefine the Network API of MiniProgram（小程序网络库）zfxmnb/wxStore: 小程序状态管理tailwind-one: 使用 tailwind 运行在 小程序（微信小程序 头条小程序 阿里小程序 taro remax uniapp 等等） web 端 h5 端 native 端！ "},{"title":"Vue.js","type":0,"sectionRef":"#","url":"docs/notes/javascript/vue.js","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#参考资料","content":"Vue.js【尚硅谷】Web 前端迅速上手 Vue 教程丨 vue3.0 入门到精通_哔哩哔哩_bilibili "},{"title":"Vue 简介​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#vue-简介","content":"Vue.js 是一套构建用户界面的渐进式 JavaScript 框架。 构建用户界面：将数据渲染在页面上；渐进式：Vue 可以自底向上逐层应用。如果是简单应用只需要引入核心库；如果是复杂应用，可以引入各种各样的 Vue 插件。 "},{"title":"MVVM​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#mvvm","content":""},{"title":"模板语法​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#模板语法","content":""},{"title":"插值​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#插值","content":"将表达式写入{{ }}中， "},{"title":"指令​","type":1,"pageTitle":"Vue.js","url":"docs/notes/javascript/vue.js#指令","content":""},{"title":"EditorConfig","type":0,"sectionRef":"#","url":"docs/notes/utility/editorconfig","content":"","keywords":""},{"title":"简介​","type":1,"pageTitle":"EditorConfig","url":"docs/notes/utility/editorconfig#简介","content":"EditorConfig1 配置文件被许多优秀的代码编辑器默认支持，只要.editorconfig文件存在于项目的根目录下，它就会被编辑器读取并应用。 将项目文件格式写入名为.editorconfig的配置文件，如文件编码、换行风格、缩进风格等，以便多个开发人员在项目里保持一致的编码风格。 "},{"title":"示例​","type":1,"pageTitle":"EditorConfig","url":"docs/notes/utility/editorconfig#示例","content":"# EditorConfig is awesome: https://EditorConfig.org root = true [*] end_of_line = lf charset = utf-8 insert_final_newline = true trim_trailing_whitespace = true indent_style = space indent_size = 4 [{*.ts, *.js}] indent_size = 2  用#标注注释； 配置可以分段，在[]之中声明要匹配的文件，可以用{}来声明多种匹配规则，用英文逗号,分隔这些规则； *，匹配任意字符串，除了/；**，匹配任意字符串；?，匹配单个字符；[name]，匹配name中的任意单个字符，即n、a、m和e；[!name]，匹配不出现在name中的单个字符；{s1, s2, s3}，联合多个匹配；{1..9}，匹配任意1至9之间的数字。 用key=value的形式定义属性，常用的一些属性如下。 配置项\t可选值\t备注indent_style\ttab/space\t缩进风格 indent_size\t数字\t空格缩进数量 end_of_line\tlf/cr/crlf\t换行符风格 charset\tutf-8/...\t文件编码 trim_trailing_whitespace\ttrue/false\t移除行尾空白字符 insert_final_newline\ttrue/false\t文件永远以空行结尾 root\ttrue/false\t该属性表名此配置文件是最顶层的配置文件，不会再往上层寻找配置文件了 可以在每个文件夹层级都定义配置文件，在进行格式化文件的时候，EditorConfig 会从当前目录至上级目录一直寻找.editorconfig文件，直到文件系统的根目录或者到某个包含root=true的配置文件为止。最终生效的配置文件是将所有寻找到的配置文件合并后的结果，路径短的配置内容会覆盖路径长的配置内容。 EditorConfig↩ "},{"title":"tmux","type":0,"sectionRef":"#","url":"docs/notes/utility/tmux","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#前言","content":"tmux 是一个终端复用器，能让你在一个终端里分屏出多个窗格，还能保存你的终端会话。尤其是在 SSH 连接到远程服务器工作的时候，网络情况不好的情况下 SSH 连接可能会意外断开，此时在该 SSH 会话中运行的命令也会被中断；在使用了 tmux 之后，只要 tmux 进程不结束，任务就不会中断，待恢复 SSH 连接后，tmux 可以让你快速恢复到之前的工作现场。 "},{"title":"快捷键说明​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#快捷键说明","content":"tmux 的快捷键操作都需要先按下前缀快捷键，默认的前缀快捷键是Ctrl+b，需要先按下此快捷键后松开，然后再按下后续指令。所有的快捷键操作均需要在 tmux 会话中按下才能生效。 如分离会话的快捷键是Ctrl+bd，你需要先按下Ctrl+b，松开键盘，再按下d。其它快捷键同理。 在会话中，使用Ctrl+b?快捷键来展示所有的快捷键，按q退出帮助页面。 "},{"title":"多会话​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#多会话","content":""},{"title":"启动​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#启动","content":"tmux，新建一个会话，默认名称是以数字序号，从 0 开始tmux new -s session_name，新建一个会话并命名为「session_name」 "},{"title":"退出​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#退出","content":"会话中不存在进程时会话会自动关闭，使用exit命令或者Ctrl+d关闭当前 shelltmux kill-session -t &lt;会话编号/会话名称&gt;，杀死会话 "},{"title":"分离​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#分离","content":"可以手动分离会话，在 SSH 断开的时候也会分离会话，只要会话中有进程该会话就不会自动关闭。 在会话中，使用Ctrl+bd分离当前会话 "},{"title":"返回​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#返回","content":"tmux ls，列出所有会话Ctrl+bs，列出所有会话tmux attach -t &lt;会话编号/会话名称&gt;，返回会话tmux switch -t &lt;会话编号/会话名称&gt;，切换会话 "},{"title":"重命名​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#重命名","content":"tmux rename-session -t &lt;会话编号/会话名称&gt; &lt;新的会话名称&gt;Ctrl+b$，重命名当前会话 "},{"title":"多窗格（pane）​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#多窗格pane","content":""},{"title":"划分窗格​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#划分窗格","content":"tmux split-window，向下划分窗格（垂直）Ctrl+b% ，向下划分窗格tmux split-window -h，向右划分窗格（水平）Ctrl+b&quot; ，向右划分窗格 "},{"title":"切换光标​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#切换光标","content":"tmux select-pane -U ，光标切换到上一窗格Ctrl+b↑tmux select-pane -D ，光标切换到下一窗格Ctrl+b↓tmux select-pane -L ，光标切换到左一窗格Ctrl+b←tmux select-pane -R ，光标切换到右一窗格Ctrl+b→ "},{"title":"移动窗格​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#移动窗格","content":"Ctrl+bq ，显示窗格编号tmux swap-pane -U，把当前窗格与上一个窗格交换位置Ctrl+b{ ，把当前窗格与上一个窗格交换位置tmux swap-pane -D，把当前窗格与下一个窗格交换位置Ctrl+b} ，把当前窗格与下一个窗格交换位置 "},{"title":"其它操作​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#其它操作","content":"Ctrl+bz ，当前窗格全屏显示，再按一次还原。在全屏模式下Ctrl+bx ，关闭当前窗格Ctrl+b! ，把当前窗格拆分为一个独立窗口Ctrl+b[ ，开启复制模式，可以用用方向键或滚轮上下滚动，q退出。 "},{"title":"多窗口（window）​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#多窗口window","content":"一个会话中可以存在多个窗口，每个窗口中可以有多个窗格。 tmux new-window，新建窗口tmux new-window -n &lt;窗口名称&gt;，新建窗口Ctrl+bc ，新建窗口tmux select-window -t &lt;窗口名称&gt;，切换到指定名称的窗口Ctrl+bp ，切换到上一个窗口Ctrl+bn ，缺环到下一个窗口Ctrl+bnumber ，切换到指定序号的窗口 "},{"title":"参考资料​","type":1,"pageTitle":"tmux","url":"docs/notes/utility/tmux#参考资料","content":"Tmux 使用教程 - 阮一峰的网络日志Gentle Guide to Get Started With tmux | Pragmatic Pineapple 🍍 "},{"title":"RocketMQ","type":0,"sectionRef":"#","url":"docs/notes/message-queuing/rocketmq","content":"","keywords":""},{"title":"MQ​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#mq","content":"MQ（Message Queue，消息队列），是一种 FIFO 的队列。 它的作用有： 异步解耦削峰 "},{"title":"RocketMQ 介绍​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#rocketmq-介绍","content":"RcoketMQ 是一款低延迟、高可靠、可伸缩、易于使用的消息中间件。 "},{"title":"NameServer​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#nameserver","content":"注册中心，可以集群。 "},{"title":"Broker​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#broker","content":"真正负责消息收发和存储的实体，可以主从。 "},{"title":"单机部署​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#单机部署","content":"可以使用 Docker Compose 来快速部署 RocketMQ。 RockerMQ 分为 NameServer1 和 Broker2，前者类似于注册中心，后者才是进行存储消息的服务。还有一个第三方服务rocket-mq-console-ng34，是 RocketMQ 的网页控制台。 RocketMQ 的 NameServer 和 Broker 是同一套代码，只是启动的时候参数不一样。apacherocketmq/rocketmq-nameserver和 apacherocketmq/rocketmq-broker在启动参数上有不同。 RocketMQ 的数据存储在user.home目录下，你可以设置user.home环境变量来自定义存储路径。在这两个 Docker 镜像中，该环境变量的值为/opt。 version: &quot;3&quot; services: nameserver: image: apacherocketmq/rocketmq-nameserver:4.5.0-alpine volumes: - nameserver_logs:/root/logs ports: - 9876:9876 environment: JAVA_OPT_EXT: &quot; -Xms128m -Xmx128m -Xmn128m&quot; command: sh mqnamesrv broker: image: apacherocketmq/rocketmq-broker:4.5.0-alpine depends_on: - nameserver volumes: - broker_data:/root/store - broker_logs:/root/logs - /root/docker-compose/rocketmq/broker.conf:/home/rocketmq/broker.conf ports: - 10909:10909 - 10911:10911 - 10912:10912 environment: JAVA_OPT_EXT: &quot; -Xms128m -Xmx128m -Xmn128m&quot; command: sh mqbroker -c /home/rocketmq/broker.conf console: image: apacherocketmq/rocketmq-console:2.0.0 depends_on: - nameserver - broker ports: - 8088:8080 environment: LOGGIN_LEVEL_ROOT: info ROCKETMQ_CONFIG_NAMESRVADDR: nameserver:9876 JAVA_OPTS: &quot; -Xms128m -Xmx128m -Xmn128m&quot; volumes: nameserver_logs: broker_data: broker_logs:  根据上面的文件中的配置内容，你还需要为 Broker 提供配置文件，位于/root/docker-compose/rocketmq/broker.conf。 需要配置 Broker 的外部 IP，不然客户端连接不上。 brokerClusterName = DefaultCluster brokerName = broker-a brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH namesrvAddr=nameserver:9876 brokerIP1=192.168.229.129 defaultTopicQueueNums=4 autoCreateTopicEnable=true autoCreateSubscriptionGroup=true  接着使用docker compose up -d就可以启动容器了，容器名字都会加上当前文件夹名作为前缀。 可以使用docker compose ps查看容器的运行状态。 "},{"title":"集群部署​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#集群部署","content":"// TODO 还没学，学了再写 "},{"title":"开发​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#开发","content":"首先为了使用方便，定义了一些常量。 public class MQConstant { public static final String NAMESERVER_ADDR = &quot;192.168.229.129:9876&quot;; }  "},{"title":"原生 API​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#原生-api","content":"消费者（推送）​ package example.sync; @Slf4j public class Consumer { public static final String CONSUMER_GROUP = &quot;sync_message_consumer&quot;; public static void main(String[] args) throws Exception { DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP); consumer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET); consumer.subscribe(MQTopicConstant.PRACTISE, MQTagConstant.PRACTISE); consumer.registerMessageListener((MessageListenerOrderly) (msgs, context) -&gt; { msgs.forEach(messageExt -&gt; { log.info(&quot;收到消息：{}&quot;, messageExt); log.info(&quot;消息体：{}&quot;, new String(messageExt.getBody())); }); return ConsumeOrderlyStatus.SUCCESS; }); consumer.start(); log.info(&quot;Consumer 已启动&quot;); Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; { log.info(&quot;程序正在退出&quot;); consumer.shutdown(); })); } }  生产者（同步发送）​ package example.sync; @Slf4j public class Producer { public static final String PRODUCER_GROUP = &quot;sync_message_producer&quot;; public static void main(String[] args) throws Exception { DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP); producer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); producer.start(); Stream.generate(RandomUtil::randomInt) .limit(10) .map(i -&gt; new Message(MQTopicConstant.PRACTISE, MQTagConstant.PRACTISE, StrUtil.format(&quot;Hello RocketMQ: {}&quot;, i).getBytes(StandardCharsets.UTF_8))) .forEach(message -&gt; { try { SendResult result = producer.send(message, 10000); log.info(&quot;消息已发送：{}&quot;, result); } catch (Exception e) { log.error(&quot;消息发送失败&quot;, e); } }); producer.shutdown(); } }  生产者（异步发送）​ package example.producer; @Slf4j public class AsyncMessageProducer { public static final String PRODUCER_GROUP = &quot;async_message_producer&quot;; public static void main(String[] args) throws Exception { final int count = 10; DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP); producer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); producer.start(); CountDownLatch countDownLatch = new CountDownLatch(count); Stream.generate(RandomUtil::randomInt) .limit(count) .map(i -&gt; new Message(MQTopicConstant.PRACTISE, MQTagConstant.PRACTISE, StrUtil.format(&quot;Hello RocketMQ: {}&quot;, i).getBytes(StandardCharsets.UTF_8))) .forEach(message -&gt; { try { producer.send(message, new SendCallback() { @Override public void onSuccess(SendResult sendResult) { log.info(&quot;消息发送成功：{}&quot;, sendResult); countDownLatch.countDown(); } @Override public void onException(Throwable e) { log.error(&quot;消息发送失败&quot;, e); countDownLatch.countDown(); } }); log.info(&quot;消息已发送：{}&quot;, message); } catch (Exception e) { log.error(&quot;消息发送失败&quot;, e); } }); countDownLatch.await(); producer.shutdown(); } }  生产者（单向发送）​ // org.apache.rocketmq.client.producer.DefaultMQProducer#sendOneway public void sendOneway(Message msg)  消费者（拉取）​ 主动拉取可以更灵活地消费消息。 // TODO 还需要明白主动拉取后的消费确认机制 package example.consumer; @Slf4j public class PullConsumer { public static final String CONSUMER_GROUP = &quot;pull_message_consumer&quot;; public static void main(String[] args) throws Exception { DefaultLitePullConsumer consumer = new DefaultLitePullConsumer(CONSUMER_GROUP); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET); consumer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); consumer.subscribe(MQTopicConstant.PRACTISE, MQTagConstant.ALL); consumer.start(); while (true) { List&lt;MessageExt&gt; messages = consumer.poll(); if (CollUtil.isEmpty(messages)) { break; } messages.forEach(messageExt -&gt; log.info(&quot;收到消息：{}&quot;, messageExt)); } Runtime.getRuntime().addShutdownHook(new Thread(consumer::shutdown)); } }  顺序消费​ 顺序消费要做到需要顺序消费的一组消息都发送到同一个队列上。消费者在消费的时候使用串行消费而不是并发消费。 // org.apache.rocketmq.client.producer.DefaultMQProducer#send public SendResult send(Message msg, MessageQueueSelector selector, Object arg)  MessageQueueSelector可以选择发送消息到哪个队列上。 在实际使用中，可以动态地选择队列来实现负载均衡，只要保证需要顺序消费的同一组消息发送到同一个队列上即可。 SendResult sendResult = producer.send(message, (mqs, msg, arg) -&gt; { int i = (Integer) arg % mqs.size(); return mqs.get(i); }, pair.getKey());  广播消息​ 默认情况下，同一个消费者组在消费消息时有竞争关系。在消费消息的时候设置消费者为广播模式就可以让消费者去掉竞争属性。 // org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#setMessageModel public void setMessageModel(MessageModel messageModel)  MessageModel默认为CLUSTERING，需要设置为BROADCASTING。 consumer.setMessageModel(MessageModel.BROADCASTING);  延迟消息​ // org.apache.rocketmq.common.message.Message#setDelayTimeLevel public void setDelayTimeLevel(int level)  可以给Message设置delayLevel，延迟级别分别为1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h，从 1 开始数。 批量消息​ // org.apache.rocketmq.client.producer.DefaultMQProducer#send public SendResult send(Collection&lt;Message&gt; msgs)  可以简单地把消息封装为Collection&lt;Message&gt;，一起发出去。 过滤消息​ 大多数情况下，可以通过 Topic 和 Tag 来过滤消息。 Tag 可以用表达式写。 consumer.subscribe(MQTopicConstant.PRACTISE, MessageSelector.byTag(&quot;TAG&quot;));  在复杂情况下，还可以通过 SQL 语句来过滤消息。  其中变量a可以在发送消息的时候通过putUserProperty()放入。 // org.apache.rocketmq.common.message.Message#putUserProperty public void putUserProperty(final String name, final String value)  只有推送模式的 Consumer 可以使用消息过滤。 事务消息​  事务消息的机制是在发送消息时会发送一个办消息，这个消息存放在系统创建的 Topic 中，对消费者是不可见的。在生产者对消息进行提交之后才会把消息转移到目标 Topic。如果生产者没有对消息进行提交，RocketMQ 会每隔一段时间进行回查，确认本地事务是否已提交成功，如果是则把消息转移到目标 Topic，否则若超过最大回查尝试次数则丢弃消息，默认最大重试次数为 15。 "},{"title":"Spring Boot​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#spring-boot","content":"配置​ 配置解耦，写在配置文件中。 rocketmq.name-server=192.168.229.129:9876 rocketmq.producer.group=spring-boot-producer-group  生产者（同步发送）​ 核心是RocketMQTemplate，消息的发送都依赖它完成。RocketMQTemplate已经在 Spring 容器中，可以自动注入拿到。其中destination的格式为${topic}:${tag}。 // org.springframework.messaging.core.AbstractMessageSendingTemplate#send public void send(D destination, Message&lt;?&gt; message)  发送消息用send()，参数中的Message实际上是org.springframework.messaging.Message，而不是org.apache.rocketmq.common.message.Message。 Message可以用MessageBuilder构建。 MessageBuilder.withPayload(payload).build();  生产者（异步发送）​ // org.apache.rocketmq.spring.core.RocketMQTemplate#asyncSend public void asyncSend(String destination, Message&lt;?&gt; message, SendCallback sendCallback)  生产者（单向发送）​ // org.apache.rocketmq.spring.core.RocketMQTemplate#sendOneWay public void sendOneWay(String destination, Message&lt;?&gt; message)  消费者（推送）​ 消息的消费有了新的抽象。只需实现RocketMQListener接口就可以快速完成消息消费。设计原则是一个接口消费一种消息，如果需要消费其他消息则需要多个接口。 package com.example.rocketmqinspringboot.listener; @Slf4j @Service @RocketMQMessageListener(consumerGroup = MQConstant.CONSUMER_GROUP, topic = MQTopicConstant.PRACTISE, selectorExpression = MQTagConstant.PRACTISE) public class Consumer implements RocketMQListener&lt;String&gt; { @Override public void onMessage(String message) { log.info(&quot;收到消息：{}&quot;, message); } }  上面的例子会直接拿到消息中的 Payload 并且将之转为泛型对应类型的对象。如果你需要拿到消息的头部信息，把泛型设置为MessageExt，其中可以拿到头部信息 5。 顺序消费​ // org.apache.rocketmq.spring.core.RocketMQTemplate#sendAndReceive public &lt;T&gt; T sendAndReceive(String destination, Message&lt;?&gt; message, Type type, String hashKey)  生产者同一组消息指定相同的hashKey，则该组消息会被发送到同一个消息队列上。 // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#consumeMode ConsumeMode consumeMode() default ConsumeMode.CONCURRENTLY;  消费者把consumeMode设置为ORDERLY。 广播消息​ // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#messageModel MessageModel messageModel() default MessageModel.CLUSTERING;  过滤消息​ // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#selectorType SelectorType selectorType() default SelectorType.TAG; // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#selectorExpression String selectorExpression() default &quot;*&quot;;  事务消息​ // org.apache.rocketmq.spring.core.RocketMQTemplate#sendMessageInTransaction public TransactionSendResult sendMessageInTransaction(final String destination, final Message&lt;?&gt; message, final Object arg)  发送事务消息依赖sendMessageInTransaction完成。arg作为自定义参数会被传递到RocketMQLocalTransactionListener#executeLocalTransaction中，本地事务逻辑会在该方法中完成。 package com.example.rocketmqinspringboot.controller; @Operation(summary = &quot;发事务消息&quot;) @PostMapping(&quot;/transaction&quot;) public void sendTransactionMessage(@RequestBody String message) { TransactionSendResult transactionSendResult = rocketMQTemplate.sendMessageInTransaction(getDestination(), getMessage(message), message); log.info(&quot;transactionSendResult: {}&quot;, transactionSendResult); }  package com.example.rocketmqinspringboot.listener; @Slf4j @RocketMQTransactionListener public class TransactionListener implements RocketMQLocalTransactionListener { @Override public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) { String orderNumber = new String((byte[]) msg.getPayload()); log.info(&quot;执行事务，{}&quot;, orderNumber); return RocketMQLocalTransactionState.UNKNOWN; } @Override public RocketMQLocalTransactionState checkLocalTransaction(Message msg) { String orderNumber = new String((byte[]) msg.getPayload()); log.info(&quot;回查，{}&quot;, orderNumber); return RocketMQLocalTransactionState.COMMIT; } }  发送事务消息时，一个RocketMQTemplate对应一个RocketMQLocalTransactionListener，该RocketMQTemplate所发出的事务消息都会在对应的RocketMQLocalTransactionListener中执行。 如果需要定义多个事务消息监听器，就需要多个RocketMQListener，对应多个RocketMQLocalTransactionListener。 package com.example.rocketmqinspringboot.config; @ExtRocketMQTemplateConfiguration public class ExtRocketMQTemplate extends RocketMQTemplate { }  package com.example.rocketmqinspringboot.listener; @RocketMQTransactionListener(rocketMQTemplateBeanName = &quot;extRocketMQTemplate&quot;) public class ExtTransactionListener implements RocketMQLocalTransactionListener { @Override public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) { return RocketMQLocalTransactionState.UNKNOWN; } @Override public RocketMQLocalTransactionState checkLocalTransaction(Message msg) { return RocketMQLocalTransactionState.COMMIT; } }  "},{"title":"Spring Cloud Stream​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#spring-cloud-stream","content":"Spring Cloud Stream 是 Spring 官方提供的一个针对所有开源的消息系统进行统一封装。 配置​ package com.example.rocketmqspringcloudstream; @EnableBinding({Source.class, Sink.class}) @SpringBootApplication public class RocketmqSpringCloudStreamApplication { public static void main(String[] args) { SpringApplication.run(RocketmqSpringCloudStreamApplication.class, args); } }  Source和Sink是 Spring Cloud Stream 提供的简单的消息输入和输出通道。 spring.cloud.stream.bindings.input.destination=STREAM_TOPIC spring.cloud.stream.bindings.input.group=STREAM_GROUP spring.cloud.stream.bindings.output.destination=STREAM_TOPIC spring.cloud.stream.rocketmq.binder.name-server=192.168.229.129:9876  Spring Cloud Stream 关于消息生产和消费的配置都放在配置文件中。 spring.cloud.stream.bindings是一个Map，可以配置多个通道，input就是Sink的通道名，output就是Source的通道名。 如果需要定义其他通道就新增配置文件，然后新增类似于Sink和Sourec的接口。 生产者​ package com.example.rocketmqspringcloudstream.controller; @Tag(name = &quot;消息&quot;) @Slf4j @RestController @RequestMapping(&quot;/messages&quot;) public class MessageController { @Autowired private Source source; @Operation(summary = &quot;发同步消息&quot;) @PostMapping(&quot;/sync&quot;) public void sendSync(@RequestBody String message) { Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;(); headers.put(MessageConst.PROPERTY_TAGS, MQTagConstant.PRACTISE); Message&lt;String&gt; msg = MessageBuilder.createMessage(message, new MessageHeaders(headers)); boolean success = source.output().send(msg); log.info(&quot;success: {}&quot;, success); } }  消费者​ package com.example.rocketmqspringcloudstream.consumer; @Slf4j @Service public class Consumer { @StreamListener(Sink.INPUT) public void consume(String message) { log.info(&quot;收到消息：{}&quot;, message); } }  "},{"title":"参考资料​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#参考资料","content":"2021 年 B 站讲的最牛掰的 RocketMQ 分布式消息中间件：核心原理与最佳实践_哔哩哔哩_bilibiliApache RocketMQrocketmq/docs/cn at master · apache/rocketmqrocketmq-externals/rocketmq-console at master · apache/rocketmq-externals基于 Docker 安装 RocketMQ - 简书rocketmq-docker/docker-compose.yml at master · apache/rocketmq-docker用户手册 · apache/rocketmq-spring Wiki apacherocketmq/rocketmq-nameserver - Docker Image | Docker Hub↩apacherocketmq/rocketmq-broker - Docker Image | Docker Hub↩apacherocketmq/rocketmq-console - Docker Image | Docker Hub↩rocketmq-externals/rocketmq-console at master · apache/rocketmq-externals↩常见问题 · apache/rocketmq-spring Wiki↩ "}]