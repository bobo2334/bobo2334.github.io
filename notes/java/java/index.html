<!doctype html>
<html class="docs-version-current" lang="zh-cn" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.9">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="我的学习笔记 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="我的学习笔记 Atom Feed">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous">
<link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180">
<link rel="icon" href="/favicon-32x32.png" sizes="32x32" type="image/png">
<link rel="icon" href="/favicon-16x16.png" sizes="16x16" type="image/png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><title data-react-helmet="true">Java | 我的学习笔记</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://bobo2334.github.io/notes/java/java"><meta data-react-helmet="true" name="docusaurus_locale" content="zh-cn"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" name="msapplication-TileColor" contnet="#da532c"><meta data-react-helmet="true" name="theme-color" contnet="#25c2a0"><meta data-react-helmet="true" property="og:title" content="Java | 我的学习笔记"><meta data-react-helmet="true" name="description" content="参考资料"><meta data-react-helmet="true" property="og:description" content="参考资料"><link data-react-helmet="true" rel="shortcut icon" href="/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://bobo2334.github.io/notes/java/java"><link data-react-helmet="true" rel="alternate" href="https://bobo2334.github.io/notes/java/java" hreflang="zh-cn"><link data-react-helmet="true" rel="alternate" href="https://bobo2334.github.io/notes/java/java" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.4698d912.css">
<link rel="preload" href="/assets/js/runtime~main.bb4921b8.js" as="script">
<link rel="preload" href="/assets/js/main.338ced93.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/android-chrome-512x512.png" alt="Logo" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/android-chrome-512x512.png" alt="Logo" class="themedImage_TMUO themedImage--dark_uzRr"></div><b class="navbar__title">我的学习笔记</b></a><a class="navbar__item navbar__link" href="/blog/archive">文章</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/bobo2334/bobo2334.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">🌜</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">🌞</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div><div class="navbar__search searchBarContainer_I7kZ"><input placeholder="搜索" aria-label="Search" class="navbar__search-input"><div class="loadingRing_Zg7X searchBarLoadingRing_J5Ez"><div></div><div></div><div></div><div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">我的学习笔记</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">书签</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">草稿</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">测试页面</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">学习笔记</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">java</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/notes/java/java">Java</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">javascript</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">message-queuing</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">utilities</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java</h1></header><h2 class="anchor anchorWithStickyNavbar_y2LR" id="参考资料">参考资料<a aria-hidden="true" class="hash-link" href="#参考资料" title="Direct link to heading">​</a></h2><ul><li><a href="https://www.bilibili.com/read/cv5216534" target="_blank" rel="noopener noreferrer">2021 年度全网最全 Java 学习路线 - 哔哩哔哩</a></li><li><a href="https://www.bilibili.com/video/BV1Kb411W75N" target="_blank" rel="noopener noreferrer">尚硅谷 Java 零基础入门教程（含百道 Java 真题，2 万多行 Java 代码实战）_哔哩哔哩_bilibili</a></li><li><a href="http://www.atguigu.com/download_detail.shtml?v=129" target="_blank" rel="noopener noreferrer">30 天搞定 Java 核心技术-程序员标配，人手一套尚硅谷教程</a></li><li><a href="https://www.gulixueyuan.com/goods/show/203?targetId=309&amp;preview=0" target="_blank" rel="noopener noreferrer">30 天搞定 Java 核心技术（上） - 谷粒学苑 - Java 培训|大数据培训|前端培训|HTML5 培训|Linux 运维培训_程序员一站式 IT 在线学习平台 - Powered By EduSoho</a></li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="java-语言概述">Java 语言概述<a aria-hidden="true" class="hash-link" href="#java-语言概述" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="软件开发介绍">软件开发介绍<a aria-hidden="true" class="hash-link" href="#软件开发介绍" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="人机交互方式">人机交互方式<a aria-hidden="true" class="hash-link" href="#人机交互方式" title="Direct link to heading">​</a></h4><ul><li>图形化界面（Graphical User Interface, GUI）</li><li>命令行方式（Command Line Interface, CLI）</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="常用的-dos-命令">常用的 DOS 命令<a aria-hidden="true" class="hash-link" href="#常用的-dos-命令" title="Direct link to heading">​</a></h4><ul><li><code>dir</code>列出目录下的文件以及文件夹</li><li><code>md</code>创建目录</li><li><code>rd</code>删除目录</li><li><code>cd</code>进入指定目录</li><li><code>cd..</code>进入上级目录</li><li><code>cd\</code>进入根目录</li><li><code>del</code>删除文件</li><li><code>exit</code>退出 DOS 命令行</li><li><code>echo</code>回显；可以用输出重定向输出内容到文件，如<code>echo javase &gt; 1.txt</code></li><li><kbd>TAB</kbd>代码提示</li><li><kbd>←</kbd><kbd>→</kbd>移动光标</li><li><kbd>↑</kbd><kbd>↓</kbd>调整历史命令</li><li><kbd>Delete</kbd><kbd>Backspace</kbd>删除字符</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="计算机编程语言介绍">计算机编程语言介绍<a aria-hidden="true" class="hash-link" href="#计算机编程语言介绍" title="Direct link to heading">​</a></h3><ul><li>第一代语言：机器语言，指令以二进制代码形式存在；</li><li>第二代语言：汇编语言，使用助剂符表示一条机器指令；</li><li>第三代语言：高级语言。</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="java-语言概述-1">Java 语言概述<a aria-hidden="true" class="hash-link" href="#java-语言概述-1" title="Direct link to heading">​</a></h3><p>Java 语言是 SUN（<strong>S</strong>tanford <strong>U</strong>niversity <strong>N</strong>etwork）1995 年推出的一门高级编程语言。</p><p>编程语言排行榜：<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener noreferrer">index | TIOBE - The Software Quality Company</a>。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="java-简史">Java 简史<a aria-hidden="true" class="hash-link" href="#java-简史" title="Direct link to heading">​</a></h4><ul><li>1991 年 Green 项目，开发语言最初命名为 Oak （橡树）</li><li>1996 年，发布 JDK 1.0</li><li>1999 年，Java 分成 J2SE、J2EE 和 J2ME，JSP/Servlet 技术诞生</li><li>2004 年，发布里程碑式版本 JDK 1.5，为突出此版本的重要性，更名为 JDK 5.0</li><li>2005 年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME</li><li>2009 年，Oracle 公司收购 SUN，交易价格 74 亿美元</li><li>2014 年，发布 JDK 8.0，是继 JDK 5.0 以来变化最大的版本</li><li>2018 年 3 月，发布 JDK 10.0，版本号也称为 18.3</li><li>2018 年 9 月，发布 JDK 11.0，版本号也称为 18.9</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="java-技术体系平台">Java 技术体系平台<a aria-hidden="true" class="hash-link" href="#java-技术体系平台" title="Direct link to heading">​</a></h4><ul><li>Java SE（Java Standard Edition）标准版，面向桌面级应用开发；</li><li>Java EE（Java Enterprise Edition）企业版，是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如 Servlet 、JSP 等，主要针对于 Web 应用程序开发；</li><li>ava ME（Java Micro Edition）小型版，支持 Java 程序运行在移动终端上的平台；</li><li>Java Card，支持一些 Java 小程序（Applets）运行在小内存设备（如智能卡）上的平台。</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="java-语言的环境搭建">Java 语言的环境搭建<a aria-hidden="true" class="hash-link" href="#java-语言的环境搭建" title="Direct link to heading">​</a></h3><ul><li>JRE（Java Runtime Environment，Java 运行环境）</li><li>JDK（Java Development Kit，Java 开发工具包）</li></ul><p><img alt="image-20211028110720639" src="/assets/images/image-20211028110720639-1db0de44b0c49dfbcc64d34e70a14ba9.png"></p><p><img alt="image-20211028110750021" src="/assets/images/image-20211028110750021-136438e761c60eca5e8372f9aed8748d.png"></p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="开发体验hello-world">开发体验——Hello World<a aria-hidden="true" class="hash-link" href="#开发体验hello-world" title="Direct link to heading">​</a></h3><ol><li>编写<ol><li>文件以<code>.java</code>为后缀</li><li>以类为基本单位</li><li>一个文件中只能由一个<code>public</code>类</li><li>如果存在<code>public</code>类，则源代码文件名需要与类名相同</li><li>程序的入口为固定写法，<code>public static void main(String[] args) { /* ... */ }</code></li><li>语句之间用分号分隔</li></ol></li><li>编译，<code>javac A.java</code></li><li>运行，<code>java 类名</code></li></ol><p><img alt="image-20211028152547834" src="/assets/images/image-20211028152547834-8519f2137cc2522b020ad2890fbc50f6.png"></p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="注释">注释<a aria-hidden="true" class="hash-link" href="#注释" title="Direct link to heading">​</a></h3><ol><li>单行注释，<code>// 注释</code></li><li>多行注释，<code>/* 注释 */</code></li><li>文档注释，<code>/** @author Roddy */</code>，可以用<code>javadoc</code>工具解析，生成代码文档</li></ol><h3 class="anchor anchorWithStickyNavbar_y2LR" id="java-api-文档">Java API 文档<a aria-hidden="true" class="hash-link" href="#java-api-文档" title="Direct link to heading">​</a></h3><ul><li><a href="https://www.matools.com/api/java8" target="_blank" rel="noopener noreferrer">Java 8 中文版 - 在线 API 中文手册 - 码工具</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener noreferrer">Overview (Java Platform SE 8 )</a></li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="java-基本语法">Java 基本语法<a aria-hidden="true" class="hash-link" href="#java-基本语法" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="关键字与保留字">关键字与保留字<a aria-hidden="true" class="hash-link" href="#关键字与保留字" title="Direct link to heading">​</a></h3><p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html" target="_blank" rel="noopener noreferrer">Java Language Keywords (The Java™ Tutorials &gt; Learning the Java Language &gt; Language Basics)</a></p><p>关键字（keyword）：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词）。关键字中所有字母都为小写。</p><p>保留字（reserverd word）：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。有两个<code>goto</code>、<code>const</code>。</p><p><img alt="image-20211028154406433" src="/assets/images/image-20211028154406433-ac637296c735930be37b19ecf0c3936d.png"></p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="标识符">标识符<a aria-hidden="true" class="hash-link" href="#标识符" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="命名规则">命名规则<a aria-hidden="true" class="hash-link" href="#命名规则" title="Direct link to heading">​</a></h4><p>Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符。</p><ul><li>由 26 个英文字母大小写，<code>0-9</code> 、<code>_</code>或 <code>$</code> 组成；</li><li>数字不可以开头；</li><li>不可以使用关键字和保留字，但能包含关键字和保留字；</li><li>Java 中严格区分大小写，长度无限制；</li><li>标识符不能包含空格。</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="命名规范">命名规范<a aria-hidden="true" class="hash-link" href="#命名规范" title="Direct link to heading">​</a></h4><p>命名规范，不强制但是强烈建议。</p><ul><li>包名：<code>xxxyyyzzz</code></li><li>类名、接口名：<code>XxxYyyZzz</code></li><li>变量名、方法名：<code>xxxYyyZzz</code></li><li>常量名：<code>XXX_YYY_ZZZ</code></li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="变量">变量<a aria-hidden="true" class="hash-link" href="#变量" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="概念">概念<a aria-hidden="true" class="hash-link" href="#概念" title="Direct link to heading">​</a></h4><ul><li>内存中的一个存储区域</li><li>该区域的数据可以在同一类型范围内不断变化</li><li>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值。</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="作用">作用<a aria-hidden="true" class="hash-link" href="#作用" title="Direct link to heading">​</a></h4><p>用于在内存中保存数据。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="使用规则">使用规则<a aria-hidden="true" class="hash-link" href="#使用规则" title="Direct link to heading">​</a></h4><ul><li>Java 中每个变量必须先声明，后使用</li><li>使用变量名来访问这块区域的数据</li><li>变量的作用域为其定义所在的一对<code>{}</code>内</li><li>变量只有在其作用域内才有效</li><li>同一个作用域内，不能定义重名的变量</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="变量分类">变量分类<a aria-hidden="true" class="hash-link" href="#变量分类" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_y2LR" id="按类型分类">按类型分类<a aria-hidden="true" class="hash-link" href="#按类型分类" title="Direct link to heading">​</a></h5><p><img alt="image-20211113165801911" src="/assets/images/image-20211113165801911-203bdd536d6cd026e972b4b469be6744.png"></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI puml"><pre tabindex="0" class="prism-code language-puml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@startmindmap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* Java 数据类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">**: 基本数据类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">（primitive type）;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*** 数值型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">**** 整数类型（byte，short，int，long）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">**** 浮点类型（float，double）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*** 字符型（char）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*** 布尔型（boolean）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">**: 引用数据类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">（reference type）;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*** 类（class）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">****_ 字符串在这里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*** 接口（interface）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*** 数组（[]）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@endmindmap</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_y2LR" id="按声明位置分类">按声明位置分类<a aria-hidden="true" class="hash-link" href="#按声明位置分类" title="Direct link to heading">​</a></h5><ul><li>成员变量：在方法体外，类内部声明的变量；<ul><li>实例变量：没有<code>static</code>修饰的变量；</li><li>类变量：有<code>static</code>修饰的变量。</li></ul></li><li>局部变量：在方法体内部声明的变量。</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="变量的初始值">变量的初始值<a aria-hidden="true" class="hash-link" href="#变量的初始值" title="Direct link to heading">​</a></h4><p>成员变量有初始值，<strong>局部变量没有初始值</strong>，需要显示初始化，不然不能通过编译检查。</p><table><thead><tr><th align="left">数据类型</th><th>默认值</th></tr></thead><tbody><tr><td align="left"><code>byte</code></td><td><code>0</code></td></tr><tr><td align="left"><code>short</code></td><td><code>0</code></td></tr><tr><td align="left"><code>int</code></td><td><code>0</code></td></tr><tr><td align="left"><code>long</code></td><td><code>0L</code></td></tr><tr><td align="left"><code>float</code></td><td><code>0.0F</code></td></tr><tr><td align="left"><code>double</code></td><td><code>0.0</code></td></tr><tr><td align="left"><code>char</code></td><td><code>0</code>（<code>int</code>类型）或<code>&#x27;\u0000&#x27;</code></td></tr><tr><td align="left"><code>boolean</code></td><td><code>false</code></td></tr><tr><td align="left">引用类型</td><td><code>null</code></td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_y2LR" id="数据类型的大小和范围">数据类型的大小和范围<a aria-hidden="true" class="hash-link" href="#数据类型的大小和范围" title="Direct link to heading">​</a></h4><p>// TODO 补充图表</p><table><thead><tr><th>#</th><th>数据类型</th><th>占用存储空间</th><th>表数范围</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td><code>byte</code></td><td>1 字节</td><td><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>128</mn><mo separator="true">,</mo><mn>127</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-128,127]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mclose">]</span></span></span></span></span></td><td></td></tr><tr><td>2</td><td><code>short</code></td><td>2</td><td><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>15</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>15</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-2^{15},2^{15}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></td><td></td></tr><tr><td>3</td><td><code>int</code></td><td>4</td><td><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>32</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-2^{32},2^{32}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>（约为 21 亿）</td><td>默认的整数类型</td></tr><tr><td>4</td><td><code>long</code></td><td>8</td><td></td><td>数字后面加<code>l</code>或<code>L</code>可声明为此类型</td></tr><tr><td>5</td><td><code>float</code></td><td>4</td><td>尾数可以精确到 7 位有效数字</td><td>后加<code>f</code>或<code>F</code></td></tr><tr><td>6</td><td><code>double</code></td><td>8</td><td>精度是<code>float</code>的两倍</td><td>默认的浮点数字类型</td></tr><tr><td>7</td><td><code>char</code></td><td>2</td><td><code>\u0000</code>~<code>\uFFFF</code>，即<code>0</code>~<code>65535</code>，无符号 16 位二进制数</td><td>存储一个 Unicode 编码字符，用一对单引号<code>&#x27;&#x27;</code>包括，可以用 Unicode 编码，比如<code>&#x27;\u00443&#x27;</code></td></tr><tr><td>8</td><td><code>boolean</code></td><td></td><td></td><td>只可以在<code>true</code>或<code>false</code>两个字面量之间取值</td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_y2LR" id="自动类型转换">自动类型转换<a aria-hidden="true" class="hash-link" href="#自动类型转换" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">int a = 100;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">long b = a;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><img alt="image-20211113171839022" src="/assets/images/image-20211113171839022-2e6e7fb7fe66d4a82c734e8e3ecc56ea.png"></p><ul><li>容量（表数范围/精度）小的类型在需要的时候会自动转为容量大的类型，不会丢失精度；</li><li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算；</li><li><code>byte</code>、<code>short</code>、<code>char</code>之间不会相互转换，它们三种类型在计算时会首先转为<code>int</code>类型；</li><li><code>boolean</code>类型不会与其他类型转换；</li><li>任何基本数据类型和<code>Sting</code>字符串在进行<code>+</code>运算时，基本数据类型会首先被转换为字符串类型，参与字符串拼接。</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="unicode-与-ascii">Unicode 与 ASCII<a aria-hidden="true" class="hash-link" href="#unicode-与-ascii" title="Direct link to heading">​</a></h4><p><code>char</code>类型的变量在转换为<code>int</code>类型的时候会转换为对应 Unicode 编码的十进制值。Unicode 兼容 ASCII。</p><ul><li><a href="https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html" target="_blank" rel="noopener noreferrer">ASCII Table</a></li><li><a href="https://www.unicode.org/charts/" target="_blank" rel="noopener noreferrer">Unicode 14.0 Character Code Charts</a></li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="string">String<a aria-hidden="true" class="hash-link" href="#string" title="Direct link to heading">​</a></h4><ul><li><code>String</code>不是基本数据类型，而是引用数据类型，它是一个类；</li><li>可以使用字面量方式声明，用双引号<code>&quot;&quot;</code>包括；</li><li>也可以用<code>new String()</code>的方式创建对象；</li><li><code>String</code>在和<code>+</code>使用的时候意义为字符串拼接而不是加法，在和基本数据类型进行拼接运算时，基本数据类型会首先被转为<code>String</code>类型；</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="强制类型转换">强制类型转换<a aria-hidden="true" class="hash-link" href="#强制类型转换" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">long a = 100L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int b = (int) a;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><code>boolean</code>类型不可以被转换为其他类型；</li><li>如果想把更大容量/更高精度的类型转为小容量/低精度类型的时候可以用强制类型转换，有丢失精度的和数据的风险。</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="进制">进制<a aria-hidden="true" class="hash-link" href="#进制" title="Direct link to heading">​</a></h3><p>这是常用进制在 Java 中的声明方式。</p><table><thead><tr><th>进制</th><th>开头</th></tr></thead><tbody><tr><td>二进制（Binary）</td><td><code>0b</code>或<code>0B</code></td></tr><tr><td>八进制（Octal）</td><td><code>0</code></td></tr><tr><td>十进制（Decimal）</td><td></td></tr><tr><td>十六进制（Hex）</td><td><code>0x</code>或<code>0X</code></td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_y2LR" id="运算符">运算符<a aria-hidden="true" class="hash-link" href="#运算符" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="算术运算符">算术运算符<a aria-hidden="true" class="hash-link" href="#算术运算符" title="Direct link to heading">​</a></h4><p><img alt="image-20211114013104263" src="/assets/images/image-20211114013104263-68470b89f586bbf78cb4df4585b4cbc6.png"></p><ul><li><code>%</code>的结果和前一个操作数的正负相同，与后一个操作数的正负无关；</li><li><code>(a++)++</code>是行不通的，编译错误。</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="赋值运算符">赋值运算符<a aria-hidden="true" class="hash-link" href="#赋值运算符" title="Direct link to heading">​</a></h4><ul><li><code>=</code></li><li>当两侧的数据类型不一致的时候，可以使用自动类型转换或强制类型转换处理</li><li>支持连续赋值</li><li>扩展赋值运算符，不会改变原有的数据类型<ul><li><code>+=</code>，<code>a+=b &lt;=&gt; a=a+b</code></li><li><code>-=</code></li><li><code>*=</code></li><li><code>/=</code></li><li><code>%=</code></li></ul></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">short s = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">s = s + 2; // 编译不通过</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">s += 2; // 不改变原来的数据类型</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="比较运算符">比较运算符<a aria-hidden="true" class="hash-link" href="#比较运算符" title="Direct link to heading">​</a></h4><p><img alt="image-20211115002653156" src="/assets/images/image-20211115002653156-4bb261339460423498a276b93ae94eb9.png"></p><p>比较运算符的结果都是<code>boolean</code>类型，要么是<code>true</code>，要么是<code>false</code>。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="逻辑运算符">逻辑运算符<a aria-hidden="true" class="hash-link" href="#逻辑运算符" title="Direct link to heading">​</a></h4><p><img alt="image-20211115003035328" src="/assets/images/image-20211115003035328-3332ec2cd13e667a9ca04be7b51ff3ac.png"></p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="位运算符">位运算符<a aria-hidden="true" class="hash-link" href="#位运算符" title="Direct link to heading">​</a></h4><p><img alt="image-20211115003527762" src="/assets/images/image-20211115003527762-850d67719e467f1ab50351b376a590af.png"></p><p><img alt="image-20211115004040238" src="/assets/images/image-20211115004040238-adca1280d847ba1515fd641d779ccfc9.png"></p><ul><li>位运算符对<strong>整数</strong>的二进制进行运算；</li><li><code>&lt;&lt;</code>左移一位相当于<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\times2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">×</span><span class="mord">2</span></span></span></span></span>；</li><li><code>&gt;&gt;</code>右移一位相当于<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>÷</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\div2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">÷</span><span class="mord">2</span></span></span></span></span>；</li><li>没有无符号左移运算符<code>&lt;&lt;&lt;</code>；</li><li>异或<code>^</code>在交换两个整数类型变量的值的时候有妙用，异或三次次即可交换值，不需要中间变量。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 加减交换整数值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 可能会超出 int 的范围</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n1 = n1 + n2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n2 = n1 - n2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n1 = n1 - n2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 用异或交换整数值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n1 = n1 ^ n2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n2 = n1 ^ n2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n1 = n1 ^ n2;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="三元运算符">三元运算符<a aria-hidden="true" class="hash-link" href="#三元运算符" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">（条件表达式） ? 表达式 1 : 表达式 2;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>当条件表达式为<code>true</code>时，执行表达式 1，整个表达式的值为表达式 1 的结果；否则执行表达式 2，整个表达式的结果为表达式 2 的结果；</li><li>表达式 1 和表达式 2 必须是<strong>同种类型</strong>。</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="运算符的优先级">运算符的优先级<a aria-hidden="true" class="hash-link" href="#运算符的优先级" title="Direct link to heading">​</a></h4><p><img alt="image-20211115175020615" src="/assets/images/image-20211115175020615-a21c10a143774739abbe09f67f4a6c40.png"></p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="程序流程控制">程序流程控制<a aria-hidden="true" class="hash-link" href="#程序流程控制" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="顺序结构">顺序结构<a aria-hidden="true" class="hash-link" href="#顺序结构" title="Direct link to heading">​</a></h4><p>Java 程序在整体上是顺序结构的，依据语句书写的顺序从前往后执行。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="分支结构">分支结构<a aria-hidden="true" class="hash-link" href="#分支结构" title="Direct link to heading">​</a></h4><ul><li><code>if</code></li><li><code>if-else</code></li><li><code>switch-case</code><ul><li><code>switch</code>表达式中的值必须是下面几种类型之一<ul><li><code>byte</code></li><li><code>short</code></li><li><code>int</code></li><li><code>char</code></li><li><code>Enum</code>（JDK 5）</li><li><code>String</code>（JDK 7）</li></ul></li><li><code>case</code>子句的值必须是常量，不能是变量名或者不确定值的表达式；</li><li>所有<code>case</code>字句的值应该互斥；</li><li><code>break</code>关键字用于跳出<code>switch</code>结构，如果没有使用<code>break</code>则会接着向下执行，意味着可以匹配多个<code>case</code>；</li><li><code>default</code>子句是可选的，位置也是灵活的（不一定要写在<code>case</code>语句之后），在没有匹配到<code>case</code>语句时会执行<code>default</code>子句中的表达式；</li><li>如果<code>default</code>语句写在<code>case</code>语句之前，并且没有<code>break</code>，在匹配<code>default</code>语句之后还会向下执行<code>case</code>里的语句，直到遇到<code>break</code>或者执行完毕。这是一个很反直觉的行为，所以<code>default</code>子句尽量写在最后，并且如果不是特殊情况下，每条<code>case</code>语句都应包含一个<code>break</code>。</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="循环结构">循环结构<a aria-hidden="true" class="hash-link" href="#循环结构" title="Direct link to heading">​</a></h4><ul><li><code>for</code></li><li><code>while</code></li><li><code>do-while</code></li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="数组">数组<a aria-hidden="true" class="hash-link" href="#数组" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="数组的概述">数组的概述<a aria-hidden="true" class="hash-link" href="#数组的概述" title="Direct link to heading">​</a></h3><p>数组（Array）是<strong>多个相同数据类型</strong>按<strong>一定顺序排列</strong>的集合。</p><ul><li>数组本身是<strong>引用数据类型</strong>，而数组中的元素可以是<strong>任何数据类型</strong>，包括基本数据类型和引用数据类型；</li><li>数组在内存中是一整块连续的空间，数组名引用的是这块连续空间的首地址；</li><li>数组的长度一旦确定就不能修改。</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="一维数组">一维数组<a aria-hidden="true" class="hash-link" href="#一维数组" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="声明">声明<a aria-hidden="true" class="hash-link" href="#声明" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">int a[];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int[] a;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="动态初始化">动态初始化<a aria-hidden="true" class="hash-link" href="#动态初始化" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">int[] arr = new int[3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arr[0] = 3;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="静态初始化">静态初始化<a aria-hidden="true" class="hash-link" href="#静态初始化" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">int[] arr = new int[]{1, 2, 3};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 类型推断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int[] arr = {1, 2, 3};</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="默认值">默认值<a aria-hidden="true" class="hash-link" href="#默认值" title="Direct link to heading">​</a></h4><p>数组成员具有默认值，和成员<u>变量的初始值</u>规则相同。不管是通过动态初始化还是静态初始化的方式来初始化数组，数组成员都有默认值，不过通过静态初始化方式初始化之后，数组成员的值又立刻被修改了一次。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="多维数组的使用">多维数组的使用<a aria-hidden="true" class="hash-link" href="#多维数组的使用" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="声明-1">声明<a aria-hidden="true" class="hash-link" href="#声明-1" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">int arr[][];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int [][] arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 也可以这样写 int[] arr[]，也是二维数组的声明</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int[] arr[] = new int[3][3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 注意特殊写法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// x 是一维数组，y 是二维数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int[] x, y[];</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="动态初始化-1">动态初始化<a aria-hidden="true" class="hash-link" href="#动态初始化-1" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">int arr[][] = new int[3][2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arr[0][1] = 2;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 后面的可以先不初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int arr[][] = new int[3][];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arr[0] = new int[3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arr[0][2] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 多维数组不必是规则矩阵形式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arr[1] = new int[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arr[1][1] = 2;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="静态初始化-1">静态初始化<a aria-hidden="true" class="hash-link" href="#静态初始化-1" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">int[][] arr = new int[][]{{1, 1, 1}, {2, 2, 2}, {3, 3, 3}};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 类型推断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int[][] arr = {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}};</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="面向对象编程">面向对象编程<a aria-hidden="true" class="hash-link" href="#面向对象编程" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="面向过程与面向对象">面向过程与面向对象<a aria-hidden="true" class="hash-link" href="#面向过程与面向对象" title="Direct link to heading">​</a></h3><p>面向<strong>过程</strong>编程（Procedure Oriented Programming，POP），以函数为最小单位，考虑怎么做；</p><p>面向<strong>对象</strong>编程（Object Oriented Programming, OOP），以类/对象为最小单位，考虑谁来做。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="面向对象的三大特征">面向对象的三大特征<a aria-hidden="true" class="hash-link" href="#面向对象的三大特征" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="封装encapsulation">封装（Encapsulation）<a aria-hidden="true" class="hash-link" href="#封装encapsulation" title="Direct link to heading">​</a></h4><p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的安全性、可扩展性和可维护性。</p><table><thead><tr><th>修饰符</th><th>同一个类</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr><td><code>private</code></td><td>✅</td><td></td><td></td><td></td></tr><tr><td>（空）</td><td>✅</td><td>✅</td><td></td><td></td></tr><tr><td><code>protected</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr><tr><td><code>public</code></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><p>在修饰<code>class</code>时只能用<code>public</code>或者空修饰符。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="继承inheritance">继承（Inheritance）<a aria-hidden="true" class="hash-link" href="#继承inheritance" title="Direct link to heading">​</a></h4><p>子类继承了父类，就继承了父类的<strong>所有方法和属性</strong>。但是父类中的<code>private</code>成员进行了隐藏，不能直接访问。</p><p>父类中的成员，无论是公有还是私有，均被子类继承。只是因为访问控制修饰符的原因，子类不能对继承的私有成员直接进行访问。</p><p>子类不会继承父类的构造器，但是一定会调用父类的构造器。</p><p>Java 中只能实现单继承。</p><p>Java 中所有的类都直接或间接继承自<code>Object</code>类。</p><p>子类可以根据需要方法重写（Overwrite）。</p><ul><li>子类中的方法和父类中的方法必须有相同的名称和参数列表；</li><li>子类方法的<strong>返回值类型不能大于</strong>父类方法的返回值类型；</li><li>子类方法的<strong>访问权限不能小于</strong>父类方法的访问权限；<ul><li>父类中的<code>private</code>方法不能被重写，但是可以在子类中声明相同方法签名的方法，不称为重写；</li><li>父类中的<code>static</code>方法也不能被重写，可以重新声明。</li></ul></li><li>子类方法抛出的<strong>异常不能大于</strong>父类方法的异常。</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="多态polymorphism">多态（Polymorphism）<a aria-hidden="true" class="hash-link" href="#多态polymorphism" title="Direct link to heading">​</a></h4><p>编译时和运行时对象类型不一致，就出现了对象的多态性。子类对象可以替代父类对象使用。</p><p>编译时，看左边（类型声明）；运行时，看右边（对象实例）。</p><p>多态不适用于属性，属性是在编译器确定的，运行时也看左边。</p><p>意味着方法会被完全覆盖，但是属性不会被覆盖。但是依然可以在子类内部通过<code>super</code>关键字调用<strong>直接父类</strong>中被覆盖的方法。</p><p>可以通过向上转型和向下转型来使用继承树中各个类的属性和方法。</p><p><code>instanceof</code>运算符用来判断某一个对象是否是某个类或该类子类的实例，返回<code>true</code>或<code>false</code>。</p><p><code>java.lang.Object#getClass</code>方法可以获取对象的运行时类名。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="抽象"><del>抽象</del><a aria-hidden="true" class="hash-link" href="#抽象" title="Direct link to heading">​</a></h4><p>也算是面向对象的特征之一，如果有人问的话。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="类和对象">类和对象<a aria-hidden="true" class="hash-link" href="#类和对象" title="Direct link to heading">​</a></h3><p>类（Class）是对一类事物的描述，是抽象的、概念上的定义；</p><p>对象（Object）是实际存在的该类事物的每个个体，也称为实例（Instance）。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="类的成员">类的成员<a aria-hidden="true" class="hash-link" href="#类的成员" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="属性">属性<a aria-hidden="true" class="hash-link" href="#属性" title="Direct link to heading">​</a></h4><p>属性（Field）又称为成员变量，分为实例变量（没有<code>static</code>修饰）和类变量（有<code>static</code>修饰）。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="方法">方法<a aria-hidden="true" class="hash-link" href="#方法" title="Direct link to heading">​</a></h4><p>方法的<strong>重载</strong>（Overload）指的是在同一个类内同名但是参数列表不完全相同的多个方法；</p><p>方法的<strong>重写</strong>（Overwrite）指的是在子类中对父类中已有的方法进行重新实现，方法的签名相同（返回值和抛出的异常范围可以更小）。</p><p>参数的值传递：对于基本数据类型，形参（方法内可以操作的参数）就是实参的复制，对形参的改变不会影响到实参；对于引用数据类型，形参是实参内存地址的复制，对形参直接修改不会影响到实参，通过形参名指向的内存地址对该对象/数组内的成员进行操作实际上就是对实参的操作。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="构造器">构造器<a aria-hidden="true" class="hash-link" href="#构造器" title="Direct link to heading">​</a></h4><p>// TODO 补充构造器内容 public 和 protected 的构造器有什么区别吗</p><ul><li>没有返回值</li><li>在创建对象的时候自动执行</li><li>可以用<code>public</code>/<code>protected</code>/<code>private</code>修饰</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="代码块">代码块<a aria-hidden="true" class="hash-link" href="#代码块" title="Direct link to heading">​</a></h4><h4 class="anchor anchorWithStickyNavbar_y2LR" id="内部类">内部类<a aria-hidden="true" class="hash-link" href="#内部类" title="Direct link to heading">​</a></h4><p>在 Java 中，允许在在类中定义类结构，称为内部类。内部类的名称不能与外部类的名称相同。</p><p>可以被以下关键词修饰：</p><ol><li><code>static</code></li><li><code>final</code></li><li><code>abstract</code></li><li><strong>成员内部类</strong>可以被四种不同的权限修饰符修饰</li></ol><h5 class="anchor anchorWithStickyNavbar_y2LR" id="成员内部类">成员内部类<a aria-hidden="true" class="hash-link" href="#成员内部类" title="Direct link to heading">​</a></h5><ul><li>静态内部类<ul><li>可以调用外部类的静态成员，包括私有的；</li><li>在外部可以直接实例化。</li></ul></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">InnerClassTest.StaticA staticA = new InnerClassTest.StaticA();</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>非静态内部类<ul><li>可以调用外部的非静态成员，相当于<code>外部类类名。this. 成员</code>，包括私有的；</li><li>在内部类中<code>this</code>指向自身，<code>外部类类名。this</code>可以访问外部类的<code>this</code>；</li><li>在外部实例化非静态内部类时需要先实例化外部类，通过外部类实例化内部类。</li></ul></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">A.B.C c = new InnerClassTest().new A().new B().new C();</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h5 class="anchor anchorWithStickyNavbar_y2LR" id="局部内部类">局部内部类<a aria-hidden="true" class="hash-link" href="#局部内部类" title="Direct link to heading">​</a></h5><p>定义在方法中。</p><ul><li>局部内部类可以使用外部方法的局部变量，但是该变量必须是<code>final</code>的，Java 8 中在局部内部类使用的外部局部变量会自动声明为<code>final</code>的 Java 8 之前需要手动声明。由局部内部类和局部变量的不同生命周期所致；</li><li>不能使用权限修饰符，和局部变量一样；</li><li>不能使用<code>static</code>修饰，因此也不能包含静态成员。</li></ul><h5 class="anchor anchorWithStickyNavbar_y2LR" id="匿名内部类">匿名内部类<a aria-hidden="true" class="hash-link" href="#匿名内部类" title="Direct link to heading">​</a></h5><ul><li>匿名内部类必须继承父类或实现接口</li><li>匿名内部类只有一个对象</li><li>匿名内部类的对象只能用多态形式引用</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="关键字">关键字<a aria-hidden="true" class="hash-link" href="#关键字" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="class"><code>class</code><a aria-hidden="true" class="hash-link" href="#class" title="Direct link to heading">​</a></h4><p>用于定义类，只能用<code>public</code>或者空权限修饰符。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="this"><code>this</code><a aria-hidden="true" class="hash-link" href="#this" title="Direct link to heading">​</a></h4><ul><li>实例本身的引用；</li><li>在构造器中代表正在初始化的对象；</li><li>可以在构造器中调用其它重载的构造器，必须放在构造器代码块的首行。</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="super"><code>super</code><a aria-hidden="true" class="hash-link" href="#super" title="Direct link to heading">​</a></h4><ul><li>用于显式调用继承来的成员（成员变量/方法）；</li><li>用于调用直接父类的构造器，必须在子类的构造器中使用，必须在代码块的第一行；</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="static"><code>static</code><a aria-hidden="true" class="hash-link" href="#static" title="Direct link to heading">​</a></h4><p><code>static</code>可以用来修饰：</p><ol><li>属性</li><li>方法</li><li>代码块</li><li>内部类</li></ol><p>被修饰的成员有以下特点：</p><ul><li>随着类的加载而加载，只会加载一次</li><li>优先于对象存在</li><li>修饰的成员被所有该类的对象共享</li><li>访问权限允许时，可以不创建对象，直接通过类名调用</li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="final"><code>final</code><a aria-hidden="true" class="hash-link" href="#final" title="Direct link to heading">​</a></h4><p><code>final</code>可以用来修饰：</p><ol><li>类，表示该类不能被继承</li><li>方法，表示该方法不能被重写</li><li>成员变量，表示该变量的值不能被修改，即为常量，必须在声明时赋值或者在构造器中赋值</li><li>局部变量</li><li>形参，表明形参在方法的代码块内不能被修改</li></ol><h4 class="anchor anchorWithStickyNavbar_y2LR" id="abstract"><code>abstract</code><a aria-hidden="true" class="hash-link" href="#abstract" title="Direct link to heading">​</a></h4><p><code>abstract</code>可以用来修饰：</p><ol><li>类，抽象类<ol><li>抽象类不能被实例化，必须有子类继承它并且实现所有的抽象方法之后才能实例化子类</li><li>如果子类没有重写所有的抽象方法，子类也必须声明为抽象类，含有抽象方法的类必须声明为抽象类</li><li>不能用<code>abstract</code>修饰<code>final</code>类</li><li>抽象类可以有构造器</li></ol></li><li>方法，抽象方法<ol><li>含有抽象方法的类必须声明为抽象类</li><li>不能用<code>abstract</code>修饰<code>private</code>方法、静态方法、<code>final</code>方法</li></ol></li></ol><h4 class="anchor anchorWithStickyNavbar_y2LR" id="interface"><code>interface</code><a aria-hidden="true" class="hash-link" href="#interface" title="Direct link to heading">​</a></h4><p>用于定义接口。</p><p>接口的思想就是定义了规范，继承是“是不是”的关系，而接口是“能不能”的关系。</p><ul><li>接口的所有成员变量默认都是<code>public static final</code>修饰的</li><li>接口中的所有方法都默认都是<code>public abstract</code>修饰的</li><li>接口没有构造器</li><li>一个类可以实现多个接口</li><li>接口也可以实现其它接口</li><li>接口与实现类之间也可以表现出多态的特性</li></ul><p>Java 8 中对接口的增强：</p><ol><li><p>静态方法</p></li><li><p>默认方法</p><ol><li><p>如果实现了接口并继承了一个类，并且接口中有默认方法和类中的方法同名同参数列表，则接口中的默认方法会被忽略，遵循类优先原则，子类在通过<code>super</code>调用父类方法的时候会调用类中的方法而不是接口中的默认方法，如果需要调用接口中的默认方法可以通过<code>接口名。super. 方法名 ()</code>来调用。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class InterfaceTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new C().a();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default void a() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;a&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">abstract class B {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void a() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;b&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class C extends B implements A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void a() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.a();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        A.super.a();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li></ol></li></ol><blockquote><p>接口可以完全取代抽象类吗？</p><p>不能，抽象类有类的结构，比如说构造器，抽象类可以私有的成员；接口中只能定义<code>public</code>的成员。抽象类可以实现更多细节，接口更轻量。能用接口实现的就尽量用接口，不能用接口实现的采用抽象类。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_y2LR" id="package"><code>package</code><a aria-hidden="true" class="hash-link" href="#package" title="Direct link to heading">​</a></h4><p>指明本源文件中定义的类所在的包。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="import"><code>import</code><a aria-hidden="true" class="hash-link" href="#import" title="Direct link to heading">​</a></h4><p><code>import</code>用于声明本源文件中用到的外部类的包位置。</p><p><code>java.lang</code>包下的类不需要声明，可以直接用。</p><p><code>import static</code>用于引入外部的静态成员（静态变量/静态方法），可以直接在本源文件中通过名称调用，不用再加上其所在的类名。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="native"><code>native</code><a aria-hidden="true" class="hash-link" href="#native" title="Direct link to heading">​</a></h4><p>用来修饰方法，表明该方法不是用 Java 语言实现的，而是用底层的 C 语言或者 C++ 实现的。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="类的初始化顺序">类的初始化顺序<a aria-hidden="true" class="hash-link" href="#类的初始化顺序" title="Direct link to heading">​</a></h3><p>在编译后的字节码文件中不存在构造器，转而出现了<code>&lt;init&gt;()</code>方法，该方法包括：</p><ol><li>代码块中的代码</li><li>显示赋值的代码</li><li>构造器中的代码</li></ol><p>其中 1 和 2 的执行顺序与代码的实际顺序相同，构造器中的代码总是最后执行。</p><p><code>&lt;init&gt;()</code>方法的数量与构造函数的数量相同，调用构造方法实际上就是调用了对应的该方法。</p><p>也不存在代码块了，代码块中的代码都拷贝到每个<code>&lt;init&gt;()</code>方法中了。显示赋值也消失了，也同时放在该方法中执行。执行顺序与源码中的书写顺序一致。</p><p>最后才是构造器中原有的代码执行。</p><p>在有继承的情况下，先在父类中按照此顺序执行，然后再到子类中按照此顺序执行。</p><p>如果子类重写了父类的方法，则会调用子类中的该方法而不是父类中的方法。</p><p>静态代码块在类初始化的时候执行，所以优先级最高。</p><ol><li>父类：成员变量之前的静态代码块</li><li>父类：成员变量之后的静态代码块</li><li>子类：成员变量之前的静态代码块</li><li>子类：成员变量之后的静态代码块</li><li>父类：成员变量之前的代码块</li><li>父类：显式赋值</li><li>父类：成员变量之后的代码块</li><li>父类：构造方法</li><li>子类：成员变量之前的代码块</li><li>子类：显式赋值</li><li>子类：成员变量之后的代码块</li><li>子类：构造方法</li></ol><h2 class="anchor anchorWithStickyNavbar_y2LR" id="异常处理">异常处理<a aria-hidden="true" class="hash-link" href="#异常处理" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="异常概述">异常概述<a aria-hidden="true" class="hash-link" href="#异常概述" title="Direct link to heading">​</a></h3><p>程序执行中发生的不正常情况称为“异常”。开发过程中的语法错误和逻辑错误不属于异常。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="异常体系结构">异常体系结构<a aria-hidden="true" class="hash-link" href="#异常体系结构" title="Direct link to heading">​</a></h3><p><img alt="image-20200706020124070" src="/assets/images/image-20200706020124070-9d82ad322fcf574bbc8dd18a3eb990b8.png"></p><p><code>Throwable</code>是所有异常的公共父类，只有此类才能被抛出或者抓取。</p><ul><li><code>Error</code>，Java 虚拟机无法解决的严重的问题，如 JVM 内部系统严重错误、资源耗尽等严重情况等，一般不编写针对性的代码进行处理，捕获了也没用，应该从其它方面解决这些问题；</li><li><code>Exception</code>，其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。<ul><li><code>RuntimeException</code>，运行时异常，不建议捕获，应该尽量避免。因为这些异常发生比较频繁，如果在代码中显示捕获的话不利于阅读；</li><li>其它异常，在编译时就能发现并且必须处理的异常，要么捕获，要么一直抛出到最上级。</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="常见异常">常见异常<a aria-hidden="true" class="hash-link" href="#常见异常" title="Direct link to heading">​</a></h3><h3 class="anchor anchorWithStickyNavbar_y2LR" id="异常处理机制">异常处理机制<a aria-hidden="true" class="hash-link" href="#异常处理机制" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="try-catch-finally"><code>try-catch-finally</code><a aria-hidden="true" class="hash-link" href="#try-catch-finally" title="Direct link to heading">​</a></h4><ul><li><code>try</code><ul><li>包裹可能发生异常的代码块。如果出现异常就会在当前执行的语句处中断。</li><li>如果在<code>catch</code>中捕获了该类型的异常就会跳转到对应的<code>catch</code>代码块。</li><li>如果显式抛出异常则当前方法中断，异常交给调用者处理。</li><li>如果都没有则程序中断。</li></ul></li><li><code>catch</code><ul><li>捕获某种类型的异常，可以多个<code>catch</code>并列，在捕获到异常之后进行对应处理。</li></ul></li><li><code>finaly</code><ul><li>不管有没有发生异常，该代码段都会执行，通常用于资源清理工作，确保无论何时资源都能被正常关闭。</li><li>如果该代码块里使用了<code>return</code>语句，那么在<code>try</code>或者<code>catch</code>代码块里的<code> return</code>语句将失效，因为在执行<code> try</code>代码块里的<code>return</code>语句之前会先执行<code>finally</code>代码段里的<code>return</code>，然后方法就终止了。</li><li>还有需要注意的是，如果在<code>finally</code>代码块里没有<code>return</code>语句的情况下，修改返回变量的值是无效的，在执行<code>finally</code>代码块之前就已经将返回值给到<code>return</code>处了，再执行<code>return</code>的时候不会拿最新的变量值，类似于<code>i++</code>的机制。</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_y2LR" id="throws"><code>throws</code><a aria-hidden="true" class="hash-link" href="#throws" title="Direct link to heading">​</a></h4><p>写在参数列表之后，方法体之前。表明当前方法可能会抛出异常的类型，这些异常不会在该方法内被处理。告知调用者在使用此方法的时候应该对这些异常进行处理，要么捕获要么再抛出。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="throw"><code>throw</code><a aria-hidden="true" class="hash-link" href="#throw" title="Direct link to heading">​</a></h4><p>在方法体内中使用，主动抛出一个异常，终止该方法。</p><p>如果是一个编译时异常就需要在<code>throws</code>后声明，如果是运行时异常就不用声明。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="自定义异常">自定义异常<a aria-hidden="true" class="hash-link" href="#自定义异常" title="Direct link to heading">​</a></h3><p>从<code>Exception</code>或者它的子类派生出一个新类即可。</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="多线程">多线程<a aria-hidden="true" class="hash-link" href="#多线程" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="多线程基本概念">多线程基本概念<a aria-hidden="true" class="hash-link" href="#多线程基本概念" title="Direct link to heading">​</a></h3><ul><li>程序（Program）是一段有序执行的静态代码的集合；</li><li>进程（Process）是程序的一次执行过程，有生命周期；</li><li>线程（Thread）是进程的进一步细分，比进程更轻量化，在线程之间切换的开销更小，效率更高，多个线程可以共享相同的内存区域。</li></ul><p>一个 Java 程序至少有三个线程：主线程、垃圾回收线程和异常处理线程。</p><ul><li>并行：多个 CPU 同时执行多个任务；</li><li>并发：一个 CPU 采用时间片同时执行多个任务。</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="线程的创建和使用">线程的创建和使用<a aria-hidden="true" class="hash-link" href="#线程的创建和使用" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="继承thread类">继承<code>Thread</code>类<a aria-hidden="true" class="hash-link" href="#继承thread类" title="Direct link to heading">​</a></h4><ol><li>从 Thread 类中派生出一个新类，重写<code>run</code>方法；</li><li>创建线程类的对象，调用<code>start</code>方法，Java 会新开一个线程，执行<code>run</code>方法。</li></ol><h4 class="anchor anchorWithStickyNavbar_y2LR" id="实现runnable接口">实现<code>Runnable</code>接口<a aria-hidden="true" class="hash-link" href="#实现runnable接口" title="Direct link to heading">​</a></h4><ol><li>新类，实现 Runnable 接口，重写<code>run</code>方法；</li><li>还是通过<code>Thread</code>类来执行，它有一个构造方法接收<code>Runnable</code>类型的参数；</li><li>调用<code>Thread</code>对象的<code>start</code>方法来启动线程。</li></ol><h4 class="anchor anchorWithStickyNavbar_y2LR" id="callable和futuretask"><code>Callable</code>和<code>FutureTask</code><a aria-hidden="true" class="hash-link" href="#callable和futuretask" title="Direct link to heading">​</a></h4><p>Java 5 新增，可以获得线程运行完毕之后的结果，返回值具有泛型支持。</p><p>新类，实现<code>Callable</code>接口，重写<code>call()</code>方法。</p><p>用<code>FutureTask</code>套<code>Callable</code>，再用<code>Thread</code>套<code>FutureTask</code>。</p><p>可以用<code>FutureTask</code>的<code>get()</code>方法获取返回值，这个方法会一直阻塞直到得到结果。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">CallableDemo cd = new CallableDemo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(cd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">new Thread(task).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">log.info(&quot;Task started.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String result = task.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">log.info(&quot;Result got： {}&quot;, result);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_y2LR" id="线程池">线程池<a aria-hidden="true" class="hash-link" href="#线程池" title="Direct link to heading">​</a></h4><p>Java 5 中提供的线程池 API，<code>ExecutorService</code>和<code>Executors</code>。</p><p>可以手动创建线程池。</p><p><code>ExecutorService</code>是接口，常见子类有<code>ThreadPoolExecutor</code>。</p><p>也可以使用<code>Executors</code>工具类来创建预先定义好设置的线程池。</p><ul><li><code>Executors.newCachedThreadPool()</code></li><li><code>newFixedThreadPool()</code></li><li><code>newSingleThreadPool()</code></li><li><code>newScheduledThreadPool()</code></li></ul><p>创建线程池之后会拿到一个<code>ExecutorService</code>接口的对象，其实现类为<code>ThreadPoolExecutor</code>，其中有两个方法可以提交新任务。</p><ul><li><code>submit(Runnable task)</code>执行成功返回<code>null</code></li><li><code>submit(Callable&lt;T&gt; task)</code>有返回值</li><li><code>execute(Runnable command)</code>无返回值</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="thread类中的常用方法"><code>Thread</code>类中的常用方法<a aria-hidden="true" class="hash-link" href="#thread类中的常用方法" title="Direct link to heading">​</a></h3><ul><li><code>run</code>要求子类重写，它的方法体也成为线程体</li><li><code>start</code>线程启动</li><li><code>sleep(long millis)</code>阻塞线程</li><li><code>getName</code>获取线程名称，默认是自动生成的，也可以在实例化对象的时候传递给构造器</li><li><code>setName</code>设置线程名称</li><li><code>static currentThread</code>获取当前线程的实例</li><li><code>getPriority</code>获取线程优先级，默认线程的优先级和它被创建的线程的优先级相同，主线程的默认优先级是 5</li><li><code>setPriority</code>设置线程优先级，范围为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,10]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></span>，越大约高，但是执行时间还得看系统的调度策略</li><li><code>checkAccess</code>判断当前线程有没有权限修改目标线程</li><li><code>stop()</code>废弃的中断线程方法</li><li><code>interrupt</code>中断线程，如果在线程外部中断要确保有权限修改该线程。如果线程被其它方法阻塞的时候中断还会抛出异常</li><li><code>join</code>在线程外执行，阻塞当前线程，一直等到该线程执行完毕</li><li><code>yeld</code>放弃本次 CPU 时间</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="线程的生命周期">线程的生命周期<a aria-hidden="true" class="hash-link" href="#线程的生命周期" title="Direct link to heading">​</a></h3><p>以下是操作系统概念中的线程的生命周期。</p><table><thead><tr><th>状态名</th><th>解释</th><th>触发条件</th></tr></thead><tbody><tr><td>创建</td><td>新建但未开始</td><td>在生成线程对象，并没有调用该对象的<code>start()</code>方法</td></tr><tr><td>就绪</td><td>处于就绪队列</td><td><code>start()</code>之后，但未获得 CPU 时间片</td></tr><tr><td>运行</td><td>正在执行</td><td>获得 CPU 时间片</td></tr><tr><td>阻塞</td><td>处于阻塞队列</td><td>等待资源、<code>wait()</code>、<code>sleep()</code>、<code>suspend()</code></td></tr><tr><td>死亡</td><td>执行完毕</td><td><code>run()</code>方法运行完毕或者调用<code>stop()</code>方法</td></tr></tbody></table><p><img alt="image-20210528143719017" src="/assets/images/image-20210528143719017-2ff4e58e562a48f210e81ca2e37a07d5.png"></p><p>JDK 中用枚举类<code>Thread.State</code>定义了线程的几种状态。</p><table><thead><tr><th>状态名</th><th>解释</th><th>触发条件</th></tr></thead><tbody><tr><td>NEW</td><td>新建但未开始</td><td><code>new</code>之后，<code>start()</code>之前</td></tr><tr><td>RUNNABLE</td><td>可运行</td><td>正在运行或者处于就绪队列</td></tr><tr><td>BLOCKED</td><td>阻塞</td><td>等待监视器锁或者调用<code>wait()</code></td></tr><tr><td>WAITTING</td><td>等待</td><td><code>wait()</code></td></tr><tr><td>TIMED_WAITTING</td><td>可自行返回的等待状态</td><td><code>sleep()</code>、带时间的<code>wait()</code>、带时间的<code>join()</code></td></tr><tr><td>TERMINATED</td><td>执行完毕</td><td><code>run()</code>方法运行完毕或者调用<code>stop()</code>方法</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_y2LR" id="线程的同步">线程的同步<a aria-hidden="true" class="hash-link" href="#线程的同步" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_y2LR" id="同步代码块">同步代码块<a aria-hidden="true" class="hash-link" href="#同步代码块" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">synchronized（锁对象）{}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>规定一段代码，在任何时刻只能有一个对象运行。在运行之前会检查锁对象是否已加锁，如果没有，在运行的时候就给锁对象加锁，运行结束之前解锁。</p><p>关于锁对象，要确保它在每个实例中是同一个对象。以继承<code>Thread</code>方式创建的线程中就不能使用<code>this</code>作为锁对象，因为每个实例中的<code>Thread</code>对象不同；以实现<code>Runnable</code>接口方式创建的线程可以使用<code>this</code>作为锁对象，因为在创建线程的时候可以只有一个该类的实例，然后通过这唯一的实例去创建线程。并且在后一种方式中，所有线程共享数据，不需要用<code>static</code>修饰。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="同步方法">同步方法<a aria-hidden="true" class="hash-link" href="#同步方法" title="Direct link to heading">​</a></h4><p>用<code>synchronized</code>修饰方法，同一时刻只能有一个线程执行此方法。</p><p>同步方法无法自己选择锁对象。对于非静态方法，锁对象是<code>this</code>；对于静态方法，锁对象是当前类的<code>Class</code>对象。 使用的时候就要判断锁对象合不合适。</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="lock"><code>Lock</code><a aria-hidden="true" class="hash-link" href="#lock" title="Direct link to heading">​</a></h4><p>在 Java 5 之后提供了一种新的方式来确保线程安全，可以通过显式定义同步锁对象来实现同步。</p><p><code>java.util.concurrent.locks.Lock</code>接口是控制多个线程对共享资源进行访问的工具。<code>ReentrantLock</code>是该接口的实现类。</p><p><img alt="image-20210528144150033" src="/assets/images/image-20210528144150033-d8885331a11319ca936df28b34e0cd41.png"></p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="线程的通信">线程的通信<a aria-hidden="true" class="hash-link" href="#线程的通信" title="Direct link to heading">​</a></h3><p>在 Object 类中定义了一些方法。</p><ul><li><code>wait</code>在被手动唤醒之前一直暂停此线程，必须由锁对象（线程监视器对象）来调用</li><li><code>notify</code>唤醒一个正在等待的线程，从上次暂停的地方继续执行</li><li><code>notifyAll</code>唤醒所有正在等待的线程，在多个生产者和多个消费者的时候注意用</li></ul><blockquote><p><code>wait()</code>和<code>sleep()</code></p><p><code>Object.wait()</code>会释放锁，<code>Thread.sleep()</code>不会释放锁。</p></blockquote><p>生产者和消费者问题。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="懒汉单例模式的线程安全问题">懒汉单例模式的线程安全问题<a aria-hidden="true" class="hash-link" href="#懒汉单例模式的线程安全问题" title="Direct link to heading">​</a></h3><p>常规方法，使创建对象的操作互斥，只允许创建一个对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class Lazy {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static Lazy INSTANCE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Lazy() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Lazy getInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (INSTANCE == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 外层判断为了提高效率</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 当内层已经创建好对象之后，其它线程和创建对象的线程就不是竞争关系了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 可以直接去取已经创建好的实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (Lazy.class) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (INSTANCE == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 内层判断为了安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    INSTANCE = new Lazy();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return INSTANCE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>还有一种更简单的方法，利用内部类不会随着外部类的初始化而初始化的特点，完成懒汉单例。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class SimpleLazy {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private SimpleLazy() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static SimpleLazy getInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Inner.INSTANCE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 内部类不会随着外部类的初始化而初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 静态代码不会随着外部类的初始化而执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 而是在使用的时候才会初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class Inner {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static final SimpleLazy INSTANCE = new SimpleLazy();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="threadlocal">ThreadLocal<a aria-hidden="true" class="hash-link" href="#threadlocal" title="Direct link to heading">​</a></h3><p>数据容器，和线程绑定。每个线程得到的值不一样。</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="枚举类">枚举类<a aria-hidden="true" class="hash-link" href="#枚举类" title="Direct link to heading">​</a></h2><h2 class="anchor anchorWithStickyNavbar_y2LR" id="注解">注解<a aria-hidden="true" class="hash-link" href="#注解" title="Direct link to heading">​</a></h2><h2 class="anchor anchorWithStickyNavbar_y2LR" id="常用类">常用类<a aria-hidden="true" class="hash-link" href="#常用类" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="object">Object<a aria-hidden="true" class="hash-link" href="#object" title="Direct link to heading">​</a></h3><p><code>Object</code>是所有类的根父类。</p><ul><li><code>java.lang.Object#equals</code>，比较两个对象，默认行为和比较运算符<code>==</code>相同，都是比较内存地址，子类可以根据需要对该方法进行重写，对内容进行比对；</li><li><code>java.lang.Object#hashCode</code>，默认根据内存地址计算对象的哈希值，如果重写了<code>equals</code>方法则原则上需要重写此方法；</li><li><code>java.lang.Object#clone</code>，返回对象的复制，是一个<code>protected</code>方法，子类需要重写此方法并调用<code>super.clone()</code>，也可以自己实现克隆细节，并实现<code>Cloneable</code>接口；</li><li><code>java.lang.Object#finalize</code>，在对象被回收之前垃圾回收器会调用此方法，子类可以重写此方法来在被回收之前做一些事情；可以通过<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>来通知垃圾回收器进行回收，但是否会进行回收是不确定的；</li><li><code>java.lang.Object#toString</code>，默认返回类名和内存地址，子类可以重写此方法来自定义返回内容；</li><li><code>java.lang.Object#getClass</code>，获取当前对象的<strong>运行时</strong>类名。</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="包装类">包装类<a aria-hidden="true" class="hash-link" href="#包装类" title="Direct link to heading">​</a></h3><p>Java 提供了 8 种基本数据类型的包装类，使得基本数据类型的变量具有类的特征。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>Byte</code></td></tr><tr><td><code>short</code></td><td><code>Short</code></td></tr><tr><td><code>int</code></td><td><code>Integer</code></td></tr><tr><td><code>long</code></td><td><code>Long</code></td></tr><tr><td><code>float</code></td><td><code>Float</code></td></tr><tr><td><code>double</code></td><td><code>Double</code></td></tr><tr><td><code>boolean</code></td><td><code>Boolean</code></td></tr><tr><td><code>char</code></td><td><code>Character</code></td></tr></tbody></table><p>其中，<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>和<code>Double</code>都是<code>Number</code>的子类。</p><p>JDK 1.5 提供的自动拆箱和自动封箱的机制可以让基本数据类型和包装类自动转换。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Integer a = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int b = a;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>基本数据类型-&gt;包装类</p><ol><li>自动拆箱/封箱</li><li>使用包装类的构造器，将基本数据类型传入</li></ol><p>包装类-&gt;基本数据类型</p><ol><li>自动拆箱/封箱</li><li>使用包装类的方法<code>xxxValue()</code>，如<code>Integer#intValue()</code></li></ol><h4 class="anchor anchorWithStickyNavbar_y2LR" id="integer">Integer<a aria-hidden="true" class="hash-link" href="#integer" title="Direct link to heading">​</a></h4><p>缓存了<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>128</mn><mo separator="true">,</mo><mn>127</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-128,127]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mclose">]</span></span></span></span></span>的包装类对象。在使用自动装箱的创建<code>Integer</code> 对象的时候会使用到缓存。使用<code>new</code> 创建的对象则不会。</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="arrays">Arrays<a aria-hidden="true" class="hash-link" href="#arrays" title="Direct link to heading">​</a></h3><h3 class="anchor anchorWithStickyNavbar_y2LR" id="string-1">String<a aria-hidden="true" class="hash-link" href="#string-1" title="Direct link to heading">​</a></h3><p><code>String</code>-&gt;基本数据类型</p><p>使用各个包装类的方法，使用的时候注意可能会抛出异常</p><ul><li><code>Integer.parseInt()</code></li><li><code>Float.parseFloat()</code></li></ul><p>基本数据类型-&gt;<code>String</code></p><ul><li><code>String.valueOf()</code></li><li>使用连接运算符<code>+</code>，<code>1 + &quot;&quot; = &quot;1&quot;</code></li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="常用接口">常用接口<a aria-hidden="true" class="hash-link" href="#常用接口" title="Direct link to heading">​</a></h2><h2 class="anchor anchorWithStickyNavbar_y2LR" id="日期时间">日期时间<a aria-hidden="true" class="hash-link" href="#日期时间" title="Direct link to heading">​</a></h2><h2 class="anchor anchorWithStickyNavbar_y2LR" id="集合">集合<a aria-hidden="true" class="hash-link" href="#集合" title="Direct link to heading">​</a></h2><h2 class="anchor anchorWithStickyNavbar_y2LR" id="范型">范型<a aria-hidden="true" class="hash-link" href="#范型" title="Direct link to heading">​</a></h2><h2 class="anchor anchorWithStickyNavbar_y2LR" id="io-流">IO 流<a aria-hidden="true" class="hash-link" href="#io-流" title="Direct link to heading">​</a></h2><h2 class="anchor anchorWithStickyNavbar_y2LR" id="反射">反射<a aria-hidden="true" class="hash-link" href="#反射" title="Direct link to heading">​</a></h2><h2 class="anchor anchorWithStickyNavbar_y2LR" id="动态代理">动态代理<a aria-hidden="true" class="hash-link" href="#动态代理" title="Direct link to heading">​</a></h2><h2 class="anchor anchorWithStickyNavbar_y2LR" id="新特性">新特性<a aria-hidden="true" class="hash-link" href="#新特性" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="java-8">Java 8<a aria-hidden="true" class="hash-link" href="#java-8" title="Direct link to heading">​</a></h3><h3 class="anchor anchorWithStickyNavbar_y2LR" id="java-9">Java 9<a aria-hidden="true" class="hash-link" href="#java-9" title="Direct link to heading">​</a></h3><h3 class="anchor anchorWithStickyNavbar_y2LR" id="java-10">Java 10<a aria-hidden="true" class="hash-link" href="#java-10" title="Direct link to heading">​</a></h3><h3 class="anchor anchorWithStickyNavbar_y2LR" id="java-11">Java 11<a aria-hidden="true" class="hash-link" href="#java-11" title="Direct link to heading">​</a></h3></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/tests/markdown-extension"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« <!-- -->Markdown 扩展测试</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/notes/javascript/typescript"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">TypeScript<!-- --> »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#参考资料" class="table-of-contents__link toc-highlight">参考资料</a></li><li><a href="#java-语言概述" class="table-of-contents__link toc-highlight">Java 语言概述</a><ul><li><a href="#软件开发介绍" class="table-of-contents__link toc-highlight">软件开发介绍</a><ul><li><a href="#人机交互方式" class="table-of-contents__link toc-highlight">人机交互方式</a></li><li><a href="#常用的-dos-命令" class="table-of-contents__link toc-highlight">常用的 DOS 命令</a></li></ul></li><li><a href="#计算机编程语言介绍" class="table-of-contents__link toc-highlight">计算机编程语言介绍</a></li><li><a href="#java-语言概述-1" class="table-of-contents__link toc-highlight">Java 语言概述</a><ul><li><a href="#java-简史" class="table-of-contents__link toc-highlight">Java 简史</a></li><li><a href="#java-技术体系平台" class="table-of-contents__link toc-highlight">Java 技术体系平台</a></li></ul></li><li><a href="#java-语言的环境搭建" class="table-of-contents__link toc-highlight">Java 语言的环境搭建</a></li><li><a href="#开发体验hello-world" class="table-of-contents__link toc-highlight">开发体验——Hello World</a></li><li><a href="#注释" class="table-of-contents__link toc-highlight">注释</a></li><li><a href="#java-api-文档" class="table-of-contents__link toc-highlight">Java API 文档</a></li></ul></li><li><a href="#java-基本语法" class="table-of-contents__link toc-highlight">Java 基本语法</a><ul><li><a href="#关键字与保留字" class="table-of-contents__link toc-highlight">关键字与保留字</a></li><li><a href="#标识符" class="table-of-contents__link toc-highlight">标识符</a><ul><li><a href="#命名规则" class="table-of-contents__link toc-highlight">命名规则</a></li><li><a href="#命名规范" class="table-of-contents__link toc-highlight">命名规范</a></li></ul></li><li><a href="#变量" class="table-of-contents__link toc-highlight">变量</a><ul><li><a href="#概念" class="table-of-contents__link toc-highlight">概念</a></li><li><a href="#作用" class="table-of-contents__link toc-highlight">作用</a></li><li><a href="#使用规则" class="table-of-contents__link toc-highlight">使用规则</a></li><li><a href="#变量分类" class="table-of-contents__link toc-highlight">变量分类</a><ul><li><a href="#按类型分类" class="table-of-contents__link toc-highlight">按类型分类</a></li><li><a href="#按声明位置分类" class="table-of-contents__link toc-highlight">按声明位置分类</a></li></ul></li><li><a href="#变量的初始值" class="table-of-contents__link toc-highlight">变量的初始值</a></li><li><a href="#数据类型的大小和范围" class="table-of-contents__link toc-highlight">数据类型的大小和范围</a></li><li><a href="#自动类型转换" class="table-of-contents__link toc-highlight">自动类型转换</a></li><li><a href="#unicode-与-ascii" class="table-of-contents__link toc-highlight">Unicode 与 ASCII</a></li><li><a href="#string" class="table-of-contents__link toc-highlight">String</a></li><li><a href="#强制类型转换" class="table-of-contents__link toc-highlight">强制类型转换</a></li></ul></li><li><a href="#进制" class="table-of-contents__link toc-highlight">进制</a></li><li><a href="#运算符" class="table-of-contents__link toc-highlight">运算符</a><ul><li><a href="#算术运算符" class="table-of-contents__link toc-highlight">算术运算符</a></li><li><a href="#赋值运算符" class="table-of-contents__link toc-highlight">赋值运算符</a></li><li><a href="#比较运算符" class="table-of-contents__link toc-highlight">比较运算符</a></li><li><a href="#逻辑运算符" class="table-of-contents__link toc-highlight">逻辑运算符</a></li><li><a href="#位运算符" class="table-of-contents__link toc-highlight">位运算符</a></li><li><a href="#三元运算符" class="table-of-contents__link toc-highlight">三元运算符</a></li><li><a href="#运算符的优先级" class="table-of-contents__link toc-highlight">运算符的优先级</a></li></ul></li><li><a href="#程序流程控制" class="table-of-contents__link toc-highlight">程序流程控制</a><ul><li><a href="#顺序结构" class="table-of-contents__link toc-highlight">顺序结构</a></li><li><a href="#分支结构" class="table-of-contents__link toc-highlight">分支结构</a></li><li><a href="#循环结构" class="table-of-contents__link toc-highlight">循环结构</a></li></ul></li></ul></li><li><a href="#数组" class="table-of-contents__link toc-highlight">数组</a><ul><li><a href="#数组的概述" class="table-of-contents__link toc-highlight">数组的概述</a></li><li><a href="#一维数组" class="table-of-contents__link toc-highlight">一维数组</a><ul><li><a href="#声明" class="table-of-contents__link toc-highlight">声明</a></li><li><a href="#动态初始化" class="table-of-contents__link toc-highlight">动态初始化</a></li><li><a href="#静态初始化" class="table-of-contents__link toc-highlight">静态初始化</a></li><li><a href="#默认值" class="table-of-contents__link toc-highlight">默认值</a></li></ul></li><li><a href="#多维数组的使用" class="table-of-contents__link toc-highlight">多维数组的使用</a><ul><li><a href="#声明-1" class="table-of-contents__link toc-highlight">声明</a></li><li><a href="#动态初始化-1" class="table-of-contents__link toc-highlight">动态初始化</a></li><li><a href="#静态初始化-1" class="table-of-contents__link toc-highlight">静态初始化</a></li></ul></li></ul></li><li><a href="#面向对象编程" class="table-of-contents__link toc-highlight">面向对象编程</a><ul><li><a href="#面向过程与面向对象" class="table-of-contents__link toc-highlight">面向过程与面向对象</a></li><li><a href="#面向对象的三大特征" class="table-of-contents__link toc-highlight">面向对象的三大特征</a><ul><li><a href="#封装encapsulation" class="table-of-contents__link toc-highlight">封装（Encapsulation）</a></li><li><a href="#继承inheritance" class="table-of-contents__link toc-highlight">继承（Inheritance）</a></li><li><a href="#多态polymorphism" class="table-of-contents__link toc-highlight">多态（Polymorphism）</a></li><li><a href="#抽象" class="table-of-contents__link toc-highlight"><del>抽象</del></a></li></ul></li><li><a href="#类和对象" class="table-of-contents__link toc-highlight">类和对象</a></li><li><a href="#类的成员" class="table-of-contents__link toc-highlight">类的成员</a><ul><li><a href="#属性" class="table-of-contents__link toc-highlight">属性</a></li><li><a href="#方法" class="table-of-contents__link toc-highlight">方法</a></li><li><a href="#构造器" class="table-of-contents__link toc-highlight">构造器</a></li><li><a href="#代码块" class="table-of-contents__link toc-highlight">代码块</a></li><li><a href="#内部类" class="table-of-contents__link toc-highlight">内部类</a><ul><li><a href="#成员内部类" class="table-of-contents__link toc-highlight">成员内部类</a></li><li><a href="#局部内部类" class="table-of-contents__link toc-highlight">局部内部类</a></li><li><a href="#匿名内部类" class="table-of-contents__link toc-highlight">匿名内部类</a></li></ul></li></ul></li><li><a href="#关键字" class="table-of-contents__link toc-highlight">关键字</a><ul><li><a href="#class" class="table-of-contents__link toc-highlight"><code>class</code></a></li><li><a href="#this" class="table-of-contents__link toc-highlight"><code>this</code></a></li><li><a href="#super" class="table-of-contents__link toc-highlight"><code>super</code></a></li><li><a href="#static" class="table-of-contents__link toc-highlight"><code>static</code></a></li><li><a href="#final" class="table-of-contents__link toc-highlight"><code>final</code></a></li><li><a href="#abstract" class="table-of-contents__link toc-highlight"><code>abstract</code></a></li><li><a href="#interface" class="table-of-contents__link toc-highlight"><code>interface</code></a></li><li><a href="#package" class="table-of-contents__link toc-highlight"><code>package</code></a></li><li><a href="#import" class="table-of-contents__link toc-highlight"><code>import</code></a></li><li><a href="#native" class="table-of-contents__link toc-highlight"><code>native</code></a></li></ul></li><li><a href="#类的初始化顺序" class="table-of-contents__link toc-highlight">类的初始化顺序</a></li></ul></li><li><a href="#异常处理" class="table-of-contents__link toc-highlight">异常处理</a><ul><li><a href="#异常概述" class="table-of-contents__link toc-highlight">异常概述</a></li><li><a href="#异常体系结构" class="table-of-contents__link toc-highlight">异常体系结构</a></li><li><a href="#常见异常" class="table-of-contents__link toc-highlight">常见异常</a></li><li><a href="#异常处理机制" class="table-of-contents__link toc-highlight">异常处理机制</a><ul><li><a href="#try-catch-finally" class="table-of-contents__link toc-highlight"><code>try-catch-finally</code></a></li><li><a href="#throws" class="table-of-contents__link toc-highlight"><code>throws</code></a></li><li><a href="#throw" class="table-of-contents__link toc-highlight"><code>throw</code></a></li></ul></li><li><a href="#自定义异常" class="table-of-contents__link toc-highlight">自定义异常</a></li></ul></li><li><a href="#多线程" class="table-of-contents__link toc-highlight">多线程</a><ul><li><a href="#多线程基本概念" class="table-of-contents__link toc-highlight">多线程基本概念</a></li><li><a href="#线程的创建和使用" class="table-of-contents__link toc-highlight">线程的创建和使用</a><ul><li><a href="#继承thread类" class="table-of-contents__link toc-highlight">继承<code>Thread</code>类</a></li><li><a href="#实现runnable接口" class="table-of-contents__link toc-highlight">实现<code>Runnable</code>接口</a></li><li><a href="#callable和futuretask" class="table-of-contents__link toc-highlight"><code>Callable</code>和<code>FutureTask</code></a></li><li><a href="#线程池" class="table-of-contents__link toc-highlight">线程池</a></li></ul></li><li><a href="#thread类中的常用方法" class="table-of-contents__link toc-highlight"><code>Thread</code>类中的常用方法</a></li><li><a href="#线程的生命周期" class="table-of-contents__link toc-highlight">线程的生命周期</a></li><li><a href="#线程的同步" class="table-of-contents__link toc-highlight">线程的同步</a><ul><li><a href="#同步代码块" class="table-of-contents__link toc-highlight">同步代码块</a></li><li><a href="#同步方法" class="table-of-contents__link toc-highlight">同步方法</a></li><li><a href="#lock" class="table-of-contents__link toc-highlight"><code>Lock</code></a></li></ul></li><li><a href="#线程的通信" class="table-of-contents__link toc-highlight">线程的通信</a></li><li><a href="#懒汉单例模式的线程安全问题" class="table-of-contents__link toc-highlight">懒汉单例模式的线程安全问题</a></li><li><a href="#threadlocal" class="table-of-contents__link toc-highlight">ThreadLocal</a></li></ul></li><li><a href="#枚举类" class="table-of-contents__link toc-highlight">枚举类</a></li><li><a href="#注解" class="table-of-contents__link toc-highlight">注解</a></li><li><a href="#常用类" class="table-of-contents__link toc-highlight">常用类</a><ul><li><a href="#object" class="table-of-contents__link toc-highlight">Object</a></li><li><a href="#包装类" class="table-of-contents__link toc-highlight">包装类</a><ul><li><a href="#integer" class="table-of-contents__link toc-highlight">Integer</a></li></ul></li><li><a href="#arrays" class="table-of-contents__link toc-highlight">Arrays</a></li><li><a href="#string-1" class="table-of-contents__link toc-highlight">String</a></li></ul></li><li><a href="#常用接口" class="table-of-contents__link toc-highlight">常用接口</a></li><li><a href="#日期时间" class="table-of-contents__link toc-highlight">日期时间</a></li><li><a href="#集合" class="table-of-contents__link toc-highlight">集合</a></li><li><a href="#范型" class="table-of-contents__link toc-highlight">范型</a></li><li><a href="#io-流" class="table-of-contents__link toc-highlight">IO 流</a></li><li><a href="#反射" class="table-of-contents__link toc-highlight">反射</a></li><li><a href="#动态代理" class="table-of-contents__link toc-highlight">动态代理</a></li><li><a href="#新特性" class="table-of-contents__link toc-highlight">新特性</a><ul><li><a href="#java-8" class="table-of-contents__link toc-highlight">Java 8</a></li><li><a href="#java-9" class="table-of-contents__link toc-highlight">Java 9</a></li><li><a href="#java-10" class="table-of-contents__link toc-highlight">Java 10</a></li><li><a href="#java-11" class="table-of-contents__link toc-highlight">Java 11</a></li></ul></li></ul></div></div></div></div></main></div></div></div>
<script src="/assets/js/runtime~main.bb4921b8.js"></script>
<script src="/assets/js/main.338ced93.js"></script>
</body>
</html>