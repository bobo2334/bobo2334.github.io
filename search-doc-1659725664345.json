[{"title":"用 KMS 激活 Windows 和 Office","type":0,"sectionRef":"#","url":"blog/activate-windows-and-office-with-kms","content":"","keywords":""},{"title":"激活 Windows​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#激活-windows","content":"只能激活 VL 版本的系统，零售版不能通过这种方式激活。 使用管理员权限运行cmd。 slmgr /skms kms.03k.org slmgr /ato  "},{"title":"激活 Office​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#激活-office","content":"进入 Office 安装目录，用管理员权限执行命令。 # C:\\Program Files (x86)\\Microsoft Office\\Office16 cscript ospp.vbs /sethst:kms.03k.org cscript ospp.vbs /act  "},{"title":"KMS 服务器收集​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#kms-服务器收集","content":"在上面命令中的 KMS 服务器失效的时候可以尝试下面列表中的其它 KMS 服务器。 kms.03k.orgkms.v0v.bid "},{"title":"自建 KMS 服务器​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#自建-kms-服务器","content":"或者也可以自己搭建 KMS 服务器，难度不高，通过 Docker 可以快速部署。 teddysun/kms - Docker Image | Docker Hub "},{"title":"其它激活方式​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#其它激活方式","content":"云萌 Windows 10 激活工具 - 首页 "},{"title":"参考资料​","type":1,"pageTitle":"用 KMS 激活 Windows 和 Office","url":"blog/activate-windows-and-office-with-kms#参考资料","content":"本站上线 KMS 服务~一句命令激活 windows/office | 零散坑知识分享 "},{"title":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","type":0,"sectionRef":"#","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh","content":"","keywords":""},{"title":"补充​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#补充","content":"oh-my-posh 项目已被重构，现在由 Go 语言实现，详情见 Github。 文章中所使用的版本现已被重命名为 oh-my-posh2，由 PowerShell 实现，详情见 Github。 oh-my-posh3 的安装请参考 Windows Terminal + PWSH + oh my posh3 + PSReadLine 打造一个好用的终端，下面的内容已过时。 "},{"title":"前言​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#前言","content":"Windows 中自带的终端使用体验确实说不上好，尝试了许多组合也感觉都不顺手。这次试试微软亲自出的 Windows Terminal1，再加上 oh-my-posh2 插件。 "},{"title":"正文​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#正文","content":""},{"title":"安装 Windows Terminal​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#安装-windows-terminal","content":"Windows Terminal 提供多种安装方式，你可以在 Microsoft Store 中安装；可以自行在该项目的 Github 仓库 1 中上下载安装程序；虽然官方文档未提及，但是你也可以用 Scoop3 安装： scoop install windows-terminal  "},{"title":"安装 oh-my-posh​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#安装-oh-my-posh","content":"oh-my-posh 是针对 Windows PowerShell 设计的主题引擎，类似于 zsh 和 Oh My Zsh 的关系。它可以让你的命令行更强大。 打开 PowerShell，输入以下命令安装： Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser  安装完成之后还更改 PowerShell 的用户配置，让它每次启动的时候自动加载 oh-my-posh 插件；执行以下命令： if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE  不出意外的话接下来会出现记事本，你需要在里面写上以下内容： Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradox  保存该文件，重新打开 PowerShell 你就能看到一个发生改变了的 PowerShell。  oh-my-posh 提供了几组预设的主题供你选择，你可以通过 Set-Theme 命令来更改当前主题，可选的值有 Agnoster/Paradox/Sorin/Darkblood/Avit/Honukai/Fish/Robbyrussell。  这个主题设置只在当前会话生效，为了每次启动 PowerShell 的时候都能加载你想要的主题，你还需要修改以下用户配置文件，就像上一个步骤中做的一样，只需要修改 Set-Theme 命令的部分即可。 "},{"title":"用上微软的 Cascadia Code 字体​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#用上微软的-cascadia-code-字体","content":"或许你已经发现了有些字符显示不正常，那是因为默认的字体没有内嵌这些字符的形状，你还需要换一个字体。 微软的另一个开源项目，Cascadia Code4 就是一款适用于终端和代码展示的字体，你可以使用 Scoop 来安装它；安装字体的时候需要使用到管理员权限，你可以使用 sudo 命令，或者用管理员权限重新打开 PowerShell，再执行安装。 在安装之前，你可能需要添加一下 nerd-fonts 仓库，因为字体软件的元信息都存放于这个仓库中。 scoop bucket add nerd-fonts  在 Scoop 的仓库中存在着好几个版本的 Cascadia Code，其中： Cascadia-Code是原版不带 Powerline 字符的；Cascadia-PL是微软出品的，自带 Powerline 字符的；CascadiaCode-NF是 Nerd Fonts5 项目出品的，后期补丁了大量 Powerline 字符。 没有特殊需求的话可以选择官方出的轻量级的 Cascadia-PL，执行以下命令： sudo scoop install Cascadia-PL  安装完成之后还需设置以下，指定 Windows Terminal 使用该字体。 目前 Windows Terminal 没有专门的设置界面，所有的配置项都在 profiles.json 配置文件里；在配置文件的对应地方设置 fontFace 的值为 Cascadia Code PL： // ... &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles &quot;fontFace&quot;: &quot;Cascadia Code PL&quot; }, // ...  保存配置文件后就能使配置文件生效；此时所有字符应该能正常显示了。  "},{"title":"集成 Git Bash​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#集成-git-bash","content":"首先将 Git 安装目录下的 bin 目录加入 Path 环境变量，如果你是用 Scoop 安装的 Git，则可以忽略此步骤，因为 Scoop 已经帮你完成了这个工作；然后修改 Windows Terminal 的配置文件，在 profiles-&gt;list 中新增一条配置： // ... &quot;list&quot;: [ { &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff4411}&quot;, &quot;name&quot;: &quot;Git Bash&quot;, &quot;commandline&quot;: &quot;bash.exe&quot;, &quot;hidden&quot;: false, &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot; } ] // ...  注意 JSON 的语法格式，在列表中不要少加或者多加逗号。保存配置文件之后就能在 Windows Terminal 中快捷启动 Git Bash 了。  "},{"title":"后记​","type":1,"pageTitle":"用 Windows Terminal 和 oh-my-posh 打造一个好用的终端","url":"blog/build-a-decent-terminal-with-windows-terminal-and-oh-my-posh#后记","content":"新的 Windows Terminal 使用体验还是挺不错的，颜值也 OK，折腾一下也挺好用的。 microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place!↩JanDeDobbeleer/oh-my-posh2: A prompt theming engine for Powershell↩lukesampson/scoop: A command-line installer for Windows.↩microsoft/cascadia-code: This is a fun, new monospaced font that includes programming ligatures and is designed to enhance the modern look and feel of the Windows Terminal.↩ryanoasis/nerd-fonts: Iconic font aggregator, collection, &amp; patcher. 3,600+ icons, 50+ patched fonts: Hack, Source Code Pro, more. Glyph collections: Font Awesome, Material Design Icons, Octicons, &amp; more↩ "},{"title":"CentOS 网络配置","type":0,"sectionRef":"#","url":"blog/configuring-centos-network","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#前言","content":"每次装 CentOS 后无法上网都要去搜教程，现在记下来以后就不用到处去搜了（滑稽）。 "},{"title":"启用网卡​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#启用网卡","content":"ifconfig eth0 up  顺便一提，关闭网卡的命令是ifconfig eth0 down。 "},{"title":"编辑网络配置文件​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#编辑网络配置文件","content":"vi /etc/sysconfig/network-scripts/ifcfg-eth0  按i进入编辑模式，按ESC进入命令模式。命令模式中输入:w保存，:q退出，:wq即为退出并保存。 打开应该是下面这个样子。 DEVICE=eth0 HWADDR=08:00:27:A6:5D:89 TYPE=Ethernet UUID=db391271-1cdf-4df2-b040-12f259d5e361 ONBOOT=no NM_CONTROLLED=yes BOOTPROTO=dhcp  ONBOOT为是否开机启动，值可为 yse/no；BOOTPROTO为获取 IP 地址的方式，值可为 dhcp/static/bootp； ONBOOT修改为yes，BOOTPROTO按需修改，其他的不需要修改，下面是示例。 "},{"title":"两种获取 IP 的方式​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#两种获取-ip-的方式","content":""},{"title":"动态获取 IP（dhcp）​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#动态获取-ipdhcp","content":"DEVICE=eth0 HWADDR=08:00:27:A6:5D:89 TYPE=Ethernet UUID=db391271-1cdf-4df2-b040-12f259d5e361 ONBOOT=yes #开机启动 NM_CONTROLLED=yes BOOTPROTO=dhcp #动态  "},{"title":"静态获取 IP（static）​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#静态获取-ipstatic","content":"DEVICE=eth0 HWADDR=08:00:27:A6:5D:89 TYPE=Ethernet UUID=db391271-1cdf-4df2-b040-12f259d5e361 ONBOOT=yes #开机启动 NM_CONTROLLED=yes BOOTPROTO=static #静态 IPADDR=192.168.233.234 #IP 地址 NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.233.1 #网关  static 方式还要手动设置 DNS。 vi /etc/resolv.conf  "},{"title":"重启网络服务​","type":1,"pageTitle":"CentOS 网络配置","url":"blog/configuring-centos-network#重启网络服务","content":"service network restart  "},{"title":"计算 zsh 启动时间","type":0,"sectionRef":"#","url":"blog/calculating-zsh-startup-time","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"计算 zsh 启动时间","url":"blog/calculating-zsh-startup-time#前言","content":"最近发现 zsh 启动速度慢，每次启动后要过 2 秒左右才完全启动。虽然在完全启动之前也可以输入命令，但是还是让人不爽。 "},{"title":"使用time命令​","type":1,"pageTitle":"计算 zsh 启动时间","url":"blog/calculating-zsh-startup-time#使用time命令","content":"time zsh -i -c exit  zsh -i -c exit 0.36s user 0.25s system 88% cpu 0.688 total  "},{"title":"使用zprof模块​","type":1,"pageTitle":"计算 zsh 启动时间","url":"blog/calculating-zsh-startup-time#使用zprof模块","content":"在~/.zshrc文件中的开头写入zmodload zsh/zprof，在结尾写入zprof，启动 zsh 之后就能看到哪些加载项影响了启动速度。 # ~/.zshrc # 首行加入 zmodload zsh/zprof # 中间省略 # ... # 末行加入 zprof  num calls time self name ----------------------------------------------------------------------------------- 1) 1 91.87 91.87 38.76% 78.87 78.87 33.28% nvm_auto 2) 1 60.75 60.75 25.63% 60.75 60.75 25.63% is_update_available 3) 2 22.79 11.39 9.62% 22.79 11.39 9.62% compaudit 4) 2 80.84 40.42 34.11% 20.08 10.04 8.47% (anon) 5) 1 35.70 35.70 15.06% 12.91 12.91 5.45% compinit 6) 1 10.37 10.37 4.38% 10.28 10.28 4.34% _zsh_highlight_load_highlighters 7) 1 13.00 13.00 5.48% 7.54 7.54 3.18% nvm_rc_version 8) 1 5.38 5.38 2.27% 5.38 5.38 2.27% nvm_echo 9) 1 5.05 5.05 2.13% 5.05 5.05 2.13% _zsh_highlight_bind_widgets 10) 1 4.88 4.88 2.06% 4.88 4.88 2.06% __sdkman_export_candidate_home 11) 1 3.86 3.86 1.63% 3.86 3.86 1.63% __sdkman_prepend_candidate_to_path 12) 1 1.36 1.36 0.57% 1.36 1.36 0.57% regexp-replace 13) 1 0.75 0.75 0.32% 0.75 0.75 0.32% colors 14) 7 0.65 0.09 0.28% 0.65 0.09 0.28% add-zsh-hook 15) 3 0.52 0.17 0.22% 0.52 0.17 0.22% bashcompinit 16) 4 0.51 0.13 0.21% 0.51 0.13 0.21% is-at-least 17) 4 0.28 0.07 0.12% 0.28 0.07 0.12% compdef 18) 2 0.30 0.15 0.13% 0.15 0.08 0.06% complete 19) 8 0.12 0.02 0.05% 0.12 0.02 0.05% is_plugin 20) 1 5.46 5.46 2.30% 0.07 0.07 0.03% nvm_err 21) 2 0.05 0.02 0.02% 0.05 0.02 0.02% is_theme 22) 1 91.91 91.91 38.78% 0.04 0.04 0.02% nvm_process_parameters 23) 2 0.03 0.02 0.01% 0.03 0.02 0.01% env_default 24) 2 0.02 0.01 0.01% 0.02 0.01 0.01% __sdkman_echo_debug 25) 1 0.02 0.02 0.01% 0.02 0.02 0.01% detect-clipboard 26) 1 0.01 0.01 0.01% 0.01 0.01 0.01% nvm_is_zsh  "},{"title":"参考资料​","type":1,"pageTitle":"计算 zsh 启动时间","url":"blog/calculating-zsh-startup-time#参考资料","content":"Quit using nvm：快删掉这个占据 Zsh 启动时间一半的怪物！ - Spencer's Blogzsh: 22 Zsh Modules "},{"title":"Debian 配置备份","type":0,"sectionRef":"#","url":"blog/debian-environment-backup","content":"","keywords":""},{"title":"软件源​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#软件源","content":"执行命令。 apt edit-sources  替换内容，这里使用了 清华大学开源软件镜像站 1。 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free  或者使用 阿里巴巴开源镜像站点 2 deb http://mirrors.aliyun.com/debian/ bullseye main non-free contrib # deb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contrib deb http://mirrors.aliyun.com/debian-security/ bullseye-security main # deb-src http://mirrors.aliyun.com/debian-security/ bullseye-security main deb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib # deb-src http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib deb http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib # deb-src http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib  "},{"title":"更新系统​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#更新系统","content":"apt update apt upgrade  "},{"title":"安装小工具​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#安装小工具","content":"apt install curl wget tmux bat htop btop exa neofetch trash-cli croc  "},{"title":"配置别名​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#配置别名","content":"执行命令。 nano .profile  加入内容。 alias ll='ls -alFGh' alias l='exa -lha --modified --created --time-style long-iso --group-directories-first' alias dc='docker-compose' alias ..='cd ..' alias ...='cd ../..' alias bat='batcat'  "},{"title":"docker​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#docker","content":"wget https://get.docker.com/ -O get-docker.sh # sh get-docker.sh --mirror Aliyun sh get-docker.sh systemctl enable docker docker run --rm hello-world  "},{"title":"docker-compose3​","type":1,"pageTitle":"Debian 配置备份","url":"blog/debian-environment-backup#docker-compose","content":"# wget https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-linux-x86_64 -O /opt/docker-compose wget https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-linux-x86_64 -O /opt/docker-compose chmod u+x /opt/docker-compose ln -s /opt/docker-compose /usr/local/sbin/docker-compose  或者通过 Linuxbrew 4 安装。 debian | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror↩debian 镜像-debian 下载地址-debian 安装教程 - 阿里巴巴开源镜像站↩Releases · docker/compose↩Linuxbrew：Linux 上的 Homebrew↩ "},{"title":"使用 Vant Weapp 自定义微信小程序 TabBar","type":0,"sectionRef":"#","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#前言","content":"微信小程序原生的 TabBar 虽然设置简单，但是样式不好看，也不能使用字体图标，但是微信小程序有自定义 TabBar 的机制。 Vant WeApp1 是有赞出品的针对微信小程序的一套开源组件库，结合 van-tabbar2 和微信的自定义 TabBar 机制 3 可以实现一套比较好看的 TabBar。 "},{"title":"新建 custom-tab-bar 组件​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#新建-custom-tab-bar-组件","content":"如图所示，在微信小程序工程文件夹根目录下新建一个名为 custom-tab-bar 的组件。  其中各个文件中的代码如下： { &quot;component&quot;: true, &quot;usingComponents&quot;: { &quot;van-tabbar&quot;: &quot;@vant/weapp/tabbar/index&quot;, &quot;van-tabbar-item&quot;: &quot;@vant/weapp/tabbar-item/index&quot; } }  // custom-tab-bar/index.js Component({ /** * 组件的属性列表 */ properties: {}, /** * 组件的初始数据 */ data: { active: -1, list: [{ icon: &quot;search&quot;, text: &quot;搜索&quot;, url: &quot;/pages/index/index&quot;, }, { icon: &quot;question-o&quot;, text: &quot;答题&quot;, url: &quot;/pages/question/index&quot;, }, { icon: &quot;ellipsis&quot;, text: &quot;关于&quot;, url: &quot;/pages/user/index&quot;, }, ], }, /** * 组件的方法列表 */ methods: { onChange(event) { wx.switchTab({ url: this.data.list[event.detail].url, }); }, init() { const { route } = getCurrentPages().pop(); const active = this.data.list.findIndex( (item) =&gt; item.url === `/${route}` ); console.log(&quot;active:&quot;, active); this.setData({ active, }); }, }, });  &lt;!-- custom-tab-bar/index.wxml --&gt; &lt;van-tabbar active=&quot;{{ active }}&quot; bind:change=&quot;onChange&quot;&gt; &lt;van-tabbar-item wx:for=&quot;{{list}}&quot; wx:key=&quot;index&quot; icon=&quot;{{item.icon}}&quot;&gt; {{item.text}} &lt;/van-tabbar-item&gt; &lt;/van-tabbar&gt;  "},{"title":"启用自定义 TabBar 设置​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#启用自定义-tabbar-设置","content":"修改 app.js 中 tabBar 设置，设置 custom 为 true。其中 list 中的对象只需保留 path 属性。  "},{"title":"在每个 Tab 页中配置​","type":1,"pageTitle":"使用 Vant Weapp 自定义微信小程序 TabBar","url":"blog/customize-wechat-mini-program-tabbar-with-vant-weapp#在每个-tab-页中配置","content":"在开启了自定义 TabBar 设置后，可以在每个页面中通过 getTabBar() 获取 TabBar 组件实例。 现在需要在每个 Tab 页中设置当前 Tab 页图标高亮。 可以在每个 Tab 页的 onShow() 生命周期方法中调用 TabBar 的 init() 方法，修改当前激活页，来高亮当前 Tab 页的图标。 /** * 生命周期函数 -- 监听页面显示 */ onShow: function () { this.getTabBar().init(); },  Vant - 轻量、可靠的移动端组件库 (gitee.io)↩Tabbar 标签栏 - Vant Weapp↩自定义 tabBar | 微信开放文档↩ "},{"title":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","type":0,"sectionRef":"#","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#前言","content":"Vuepress1 是一个基于 Vue 的静态网站生成器；Github Pages2 是 Github 提供的免费的静态网站托管服务；Github Actions3 是 Github 仓库中集成的 CI/CD4 服务。 Vuepress 是一个 Node.js 项目，它可以根据配置将 Markdown 文件转为 HTML 文件。你可以将输出的静态文件托管在 Github Pages 中，这样你就得到了一个可以访问的域名来展示这些静态的 HTML 文件。 传统的做法是在本地安装好 Noed.js 环境，自己手动构建项目之后将构建产物上传到 Github 仓库，从而触发 Github Pages 的构建。现在可以利用 Github Actions 来代替手工劳动，Github Actions 可以自动被触发，它运行在 Github 提供的虚拟环境中，可以执行一系列任务从而代替重复枯燥的手动构建和部署的步骤。 "},{"title":"创建 Github 仓库​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#创建-github-仓库","content":"在创建的 Github 仓库时要注意仓库名称，假如你的用户名是 foo。 如果你创建了一个名为foo.github.io的仓库，你将可以通过https://foo.github.io来访问此仓库的 Github Pages 内容； 如果你创建其他名称的仓库如bar，你可以通过https://foo.github.io/bar/来访问此仓库的 Github Pages 内容。 你可以根据你期望的访问方式来选择仓库名称。 "},{"title":"配置 Github Actions​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#配置-github-actions","content":"Github Actions 的配置文件应该放在项目根目录下的.github/workflows/文件夹中，你可以在一个项目中配置多个 Actions。配置文件是 YAML 格式，文件名形如*.yml。 每一个 Action 中可以包括多个 job，每个 job 可以包括多个 step。在 step 中你可以直接运行命令，或者引用其他人编写好的 Action 脚本。在本文的配置文件中，我们引用了 github-pages-deploy-action5 来完成 Github Pages 部署，而不用关系其实现细节。 完成本文目标的 Github Actions 配置文件内容如下。 name: &quot;github actions build and deploy gh-pages&quot; on: push: branches: - master jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2.3.1 with: persist-credentials: false - name: install and build run: | npm install npm run build - name: Deploy uses: JamesIves/github-pages-deploy-action@4.1.4 with: BRANCH: gh-pages FOLDER: docs/.vuepress/dist  其中的一些关键配置解释如下。 on.push.branches，在推送到master分支时触发此 Action；jobs.build-and-deploy，在一个 Action 中可以有多个 job，这是其中的一个，名称是自己取的；每个任务可以有多个 step；jobs.build-and-deploy.steps[0]，用actions/checkout检出仓库内容；jobs.build-and-deploy.steps[1]，执行npm命令安装开发环境；jobs.build-and-deploy.steps[2]，用JamesIves/github-pages-deploy-action部署docs/.vuepress/dist文件夹中的内容到gh-pages分支中。 在编写好配置文件后可以提交并推送文件至 master 分支，这会自动触发 Action 的执行，并且你可以在 Actions 栏目中查看执行日志。  "},{"title":"配置 Github Pages​","type":1,"pageTitle":"利用 Github Actions 部署 Vuepress 项目到 Github Pages","url":"blog/deploy-vuepress-project-to-github-pages-with-github-actions#配置-github-pages","content":"我们的构建产物放在 gh-pages 分支，我们需要告诉 Github Pages 源文件位置。 在 Github 仓库的 Settings 栏目中，从左侧的设置导航栏找到 Pages 设置。在这里你可以设置 gh-pages 为数据源。  如果没出错的话，在配置完成之后你就可以通过 Github Pages 给你提供的域名来访问你的静态网站了。 首页 | VuePress↩GitHub Pages | Websites for you and your projects, hosted directly from your GitHub repository. Just edit, push, and your changes are live.↩Learn GitHub Actions - GitHub Docs↩什么是 CI/CD？一文带你理解 CI 持续集成和 CD 持续交付/部署 - 红帽↩JamesIves/github-pages-deploy-action: Automatically deploy your project to GitHub Pages using GitHub Actions. This action can be configured to push your production-ready code into any branch you'd like.↩ "},{"title":"Docker 穿透防火墙的问题","type":0,"sectionRef":"#","url":"blog/docker-and-system-firewall","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Docker 穿透防火墙的问题","url":"blog/docker-and-system-firewall#前言","content":"有些服务只需要在本地访问，不需要向外暴露端口，不然会有安全隐患，总有一大堆机器扫描你的端口，尝试接入你的服务。 通过 Docker 暴露的端口，即使没有在防火墙中手动放行，在外部还是可以访问到。 "},{"title":"解决办法​","type":1,"pageTitle":"Docker 穿透防火墙的问题","url":"blog/docker-and-system-firewall#解决办法","content":"在进行端口映射的时候指定监听地址为127.0.0.1，如127.0.0.1:3000:80。在没指定的情况下，如3000:80，监听地址为0.0.0.0。 这在使用docker run命令和docker-compose命令的时候都可以生效。 docker run命令示例如下。 docker run -p 127.0.0.1:80:80 nginx  使用docker-compose命令时，docker-compose.yml内容示例如下。 version: '3.3' services: nginx: ports: - '127.0.0.1:80:80' image: nginx  "},{"title":"参考资料​","type":1,"pageTitle":"Docker 穿透防火墙的问题","url":"blog/docker-and-system-firewall#参考资料","content":"无视系统防火墙的 docker - 博客 - binsitedocker 无视防火墙问题总结 - Icharle | Don't forget your first thoughtsdocker 开放的端口是如何实现绕过防火墙的？ - 知乎Docker 与 IPtables - 简书 "},{"title":"EditorConfig 统一编码风格","type":0,"sectionRef":"#","url":"blog/editorconfig","content":"","keywords":""},{"title":"简介​","type":1,"pageTitle":"EditorConfig 统一编码风格","url":"blog/editorconfig#简介","content":"EditorConfig 配置文件被许多优秀的代码编辑器默认支持，只要.editorconfig文件存在于项目的根目录下，它就会被编辑器读取并应用。 将项目文件格式写入名为.editorconfig的配置文件，如文件编码、换行风格、缩进风格等，以便多个开发人员在项目里保持一致的编码风格。 "},{"title":"示例​","type":1,"pageTitle":"EditorConfig 统一编码风格","url":"blog/editorconfig#示例","content":"# EditorConfig is awesome: https://EditorConfig.org root = true [*] end_of_line = lf charset = utf-8 insert_final_newline = true trim_trailing_whitespace = true indent_style = space indent_size = 4 [{*.ts, *.js}] indent_size = 2  用#标注注释； 配置可以分段，在[]之中声明要匹配的文件，可以用{}来声明多种匹配规则，用英文逗号,分隔这些规则； *，匹配任意字符串，除了/；**，匹配任意字符串；?，匹配单个字符；[name]，匹配name中的任意单个字符，即n、a、m和e；[!name]，匹配不出现在name中的单个字符；{s1, s2, s3}，联合多个匹配；{1..9}，匹配任意1至9之间的数字。 用key=value的形式定义属性，常用的一些属性如下。 配置项\t可选值\t备注indent_style\ttab/space\t缩进风格 indent_size\t数字\t空格缩进数量 end_of_line\tlf/cr/crlf\t换行符风格 charset\tutf-8/...\t文件编码 trim_trailing_whitespace\ttrue/false\t移除行尾空白字符 insert_final_newline\ttrue/false\t文件永远以空行结尾 root\ttrue/false\t该属性表名此配置文件是最顶层的配置文件，不会再往上层寻找配置文件了 可以在每个文件夹层级都定义配置文件，在进行格式化文件的时候，EditorConfig 1 会从当前目录至上级目录一直寻找.editorconfig文件，直到文件系统的根目录或者到某个包含root=true的配置文件为止。最终生效的配置文件是将所有寻找到的配置文件合并后的结果，路径短的配置内容会覆盖路径长的配置内容。 EditorConfig↩ "},{"title":"开启 Docker Remote API 并启用 TLS","type":0,"sectionRef":"#","url":"blog/enable-docker-remote-api-with-tls-protection","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#前言","content":"Portainer1 是一款 Docker 可视化管理面板，它不仅可以管理本地的 Docker 实例，还可以通过 Docker Remote API 访问管理远程 Docker 资源。Docker Remote API 就是通过 HTTP 协议暴露 Docker 资源，启用 TLS 可以实现远程访问鉴权。 Docker 的官方文档提供了详细的开启 Docker Remote API 和开启 TLS 的教程 2。但是在签发证书的过程中涉及到的命令比较多，且繁琐，我就从网络上寻找到了别人写好的签发证书的脚本 3，可以很方便地替代纯手工操作。 本文中的操作都在 CentOS 7 中完成。 "},{"title":"签发证书​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#签发证书","content":"将脚本命名为auto-tls-certs.sh。其中需要配置的内容有： CODE，作为文件名的后缀，用于区分文件；IP，机器的公网 IP 地址；PASSWORD，证书密码。 脚本内容如下： #!/bin/bash # # ------------------------------------------------------------- # 自动创建 Docker TLS 证书 # ------------------------------------------------------------- # 以下是配置信息 # --[BEGIN]------------------------------ CODE=&quot;tx&quot; IP=&quot;1.1.1.1&quot; PASSWORD=&quot;pass&quot; COUNTRY=&quot;CN&quot; STATE=&quot;BEIJING&quot; CITY=&quot;BEIJING&quot; ORGANIZATION=&quot;Org&quot; ORGANIZATIONAL_UNIT=&quot;Dev&quot; COMMON_NAME=&quot;$IP&quot; EMAIL=&quot;.&quot; # --[END]-- # Generate CA key openssl genrsa -aes256 -passout &quot;pass:$PASSWORD&quot; -out &quot;ca-key-$CODE.pem&quot; 4096 # Generate CA openssl req -new -x509 -days 365 -key &quot;ca-key-$CODE.pem&quot; -sha256 -out &quot;ca-$CODE.pem&quot; -passin &quot;pass:$PASSWORD&quot; -subj &quot;/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$COMMON_NAME/emailAddress=$EMAIL&quot; # Generate Server key openssl genrsa -out &quot;server-key-$CODE.pem&quot; 4096 # Generate Server Certs. openssl req -subj &quot;/CN=$COMMON_NAME&quot; -sha256 -new -key &quot;server-key-$CODE.pem&quot; -out server.csr echo &quot;subjectAltName = IP:$IP,IP:127.0.0.1&quot; &gt;&gt; extfile.cnf echo &quot;extendedKeyUsage = serverAuth&quot; &gt;&gt; extfile.cnf openssl x509 -req -days 365 -sha256 -in server.csr -passin &quot;pass:$PASSWORD&quot; -CA &quot;ca-$CODE.pem&quot; -CAkey &quot;ca-key-$CODE.pem&quot; -CAcreateserial -out &quot;server-cert-$CODE.pem&quot; -extfile extfile.cnf # Generate Client Certs. rm -f extfile.cnf openssl genrsa -out &quot;key-$CODE.pem&quot; 4096 openssl req -subj '/CN=client' -new -key &quot;key-$CODE.pem&quot; -out client.csr echo extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf openssl x509 -req -days 365 -sha256 -in client.csr -passin &quot;pass:$PASSWORD&quot; -CA &quot;ca-$CODE.pem&quot; -CAkey &quot;ca-key-$CODE.pem&quot; -CAcreateserial -out &quot;cert-$CODE.pem&quot; -extfile extfile.cnf rm -vf client.csr server.csr chmod -v 0400 &quot;ca-key-$CODE.pem&quot; &quot;key-$CODE.pem&quot; &quot;server-key-$CODE.pem&quot; chmod -v 0444 &quot;ca-$CODE.pem&quot; &quot;server-cert-$CODE.pem&quot; &quot;cert-$CODE.pem&quot; # 打包客户端证书 mkdir -p &quot;tls-client-certs-$CODE&quot; cp -f &quot;ca-$CODE.pem&quot; &quot;cert-$CODE.pem&quot; &quot;key-$CODE.pem&quot; &quot;tls-client-certs-$CODE/&quot; cd &quot;tls-client-certs-$CODE&quot; tar zcf &quot;tls-client-certs-$CODE.tar.gz&quot; * mv &quot;tls-client-certs-$CODE.tar.gz&quot; ../ cd .. rm -rf &quot;tls-client-certs-$CODE&quot; # 拷贝服务端证书 mkdir -p /etc/docker/certs.d cp &quot;ca-$CODE.pem&quot; &quot;server-cert-$CODE.pem&quot; &quot;server-key-$CODE.pem&quot; /etc/docker/certs.d/  使用sh auto-tls-certs.sh命令来生成证书，并且生成好的证书会被自动打包为.tar.gz归档，非常方便。下面的图片展示了执行脚本后生成的文件列表。  "},{"title":"配置 Docker​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#配置-docker","content":"只需关注.pem文件，把证书找个专门的位置存放。 mkdir /etc/.docker cp ~/docker-cert/*.pem /etc/.docker/  修改 Docker 启动文件。 nano /lib/systemd/system/docker.service  修改Service下的ExecStart配置。 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -D -H tcp://0.0.0.0:2376 --tlsverify --tlscacert=/etc/.docker/ca-tx.pem --tlscert=/etc/.docker/server-cert-tx.pem --tlskey=/etc/.docker/server-key-tx.pem   重启 Docker。 systemctl daemon-reloadservice docker restart  "},{"title":"开放端口​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#开放端口","content":"在防火墙、安全组中放行 2376 端口。 "},{"title":"测试​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#测试","content":"把证书的压缩包tls-client-certs-tx.tar.gz下载到本机，解压得到证书文件。  用curl命令测试，如果有 JSON 格式的信息输出则配置成功。 curl https://你的 IP/info --cert cert-tx.pem --key key-tx.pem --cacert ca-tx.pem   "},{"title":"用 Portainer 连接​","type":1,"pageTitle":"开启 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection#用-portainer-连接","content":"Portainer 是一款非常好用的 Docker 可视化管理工具，通过暴露 Docker Remote API 可以远程连接并管理 Docker 资源。 在Endpoints页面中点击Add endpoint，Environment type选择Docker。 在对应的输入框中填写 IP 地址和端口号，开启 TLS，选择三个对应的证书文件。  Documentation↩Protect the Docker daemon socket | Docker Documentation↩Docker 开启 TLS 访问，更加安全 - 实用教程 - 高亚轩的 BLOG↩ "},{"title":"以容器的方式暴露 Docker Remote API 并启用 TLS","type":0,"sectionRef":"#","url":"blog/enable-docker-remote-api-with-tls-protection-via-container","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"以容器的方式暴露 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection-via-container#前言","content":"之前在「开启 Docker Remote API 并启用 TLS」1 中记录过 Docker 暴露 Remote API 并配置 TLS 支持，虽然其中引用了别人的脚本来简化证书的签发步骤，但是在证书签发完成之后还是需要对 Docker 的启动命令进行修改，还是一个比较繁琐的步骤。 后来我发现了 docker-remote-api-tls2 项目，它提供了一个 Docker 镜像，在运行镜像之后它会自动完成证书签发和 API 转发步骤。 "},{"title":"部署​","type":1,"pageTitle":"以容器的方式暴露 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection-via-container#部署","content":"可以通过 Docker Compose 方便地启动这个容器，下面是docker-compose.yml文件的内容。 version: &quot;3&quot; services: api: image: kekru/docker-remote-api-tls:v0.3.0 ports: - 2376:443 environment: - CREATE_CERTS_WITH_PW=dockercompose - CERT_EXPIRATION_DAYS=3650 - CA_EXPIRATION_DAYS=36500 - CERT_HOSTNAME=192.168.229.129.nip.io volumes: - /root/compose/docker-remote-api-with-tls/certs:/data/certs - /var/run/docker.sock:/var/run/docker.sock:ro restart: unless-stopped  有以下几点需要注意： 第 6 行，容器内的端口是 443，需要映射到容器外 2376 端口；第 8 行，CREATE_CERTS_WITH_PW设置证书密码；第 9 行，CERT_EXPIRATION_DAYS设置证书过期时间，默认 365 天；第 10 行，CA_EXPIRATION_DAYS设置 CA 证书过期时间，默认 900 天；第 11 行，CERT_HOSTNAME设置域名，如果没有域名可以用 nip.io3 来得到一个可以解析到任意 IP 的域名。形如192.168.229.129.nip.io的域名会被解析至192.168.229.129；还有其他形式的域名可以在 nip.io 网站中查看；第 13 行，挂载证书目录，首次启动时证书会被自动创建并存放在此目录中；第 14 行，挂载docker.sock。 通过docker compose up -d启动容器。根据配置，证书会被自动创建在/root/compose/docker-remote-api-with-tls/certs目录中。 该目录的结构如下： certs/ ├── ca-cert.pem ├── ca-key.pem ├── client │ ├── ca.pem │ ├── cert.pem │ └── key.pem ├── server-cert.pem └── server-key.pem  其中，客户端需要的证书文件存放在client目录中。此时 Docker Remote API 已经暴露在 2376 端口，客户端可以使用证书文件来通过认证。 如果需要重新签发证书文件，只需要清空certs文件夹并重启容器即可。 "},{"title":"补充​","type":1,"pageTitle":"以容器的方式暴露 Docker Remote API 并启用 TLS","url":"blog/enable-docker-remote-api-with-tls-protection-via-container#补充","content":"国内的 IP 请使用已备案域名，不然可能会被阻断，导致连接不上。 开启 Docker Remote API 并启用 TLS↩kekru/docker-remote-api-tls: Docker Image that forwards to the Docker API Socket and requires TLS Client authentication↩nip.io - wildcard DNS for any IP Address↩ "},{"title":"修复 PATH 环境变量","type":0,"sectionRef":"#","url":"blog/fix-path-environment","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"修复 PATH 环境变量","url":"blog/fix-path-environment#前言","content":"折腾 Shell 的时候搞坏了 PATH 环境变量，导致所有命令都找不到。 "},{"title":"临时修复​","type":1,"pageTitle":"修复 PATH 环境变量","url":"blog/fix-path-environment#临时修复","content":"在 Shell 中执行以下命令来在此次会话中设置 PATH。这样一些基础工具就能工作了。 export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin  "},{"title":"排查错误​","type":1,"pageTitle":"修复 PATH 环境变量","url":"blog/fix-path-environment#排查错误","content":"从 Shell 启动文件中排查错误，看看最近修改了什么，以及什么命令可能会影响到 PATH 变量。 如果你使用 Bash，你可能需要排查下面的文件。 /etc/profile/etc/bash.bashrc/etc/profile.d/*~/.profile~/.bashrc 如果你使用 Zsh，你可能需要排查下面的文件。 /etc/zprofile/etc/zshrc~/.zprofile~/.zshrc "},{"title":"参考资料​","type":1,"pageTitle":"修复 PATH 环境变量","url":"blog/fix-path-environment#参考资料","content":"linux 下环境变量 PATH 设置错误的补救_铭霏的博客-CSDN 博客_linux 环境变量修复Bash Startup Files (Bash Reference Manual)macos - ZSH: .zprofile, .zshrc, .zlogin - What goes where? - Ask Different "},{"title":"获取天翼光猫 F412 超级管理员帐号密码","type":0,"sectionRef":"#","url":"blog/get-super-admin-password-of-f412","content":"","keywords":""},{"title":"开启 telnet 服务​","type":1,"pageTitle":"获取天翼光猫 F412 超级管理员帐号密码","url":"blog/get-super-admin-password-of-f412#开启-telnet-服务","content":"控制面板 -&gt; 所有控制面板项 -&gt; 程序和功能 -&gt; 启用或关闭 Windows 功能。 "},{"title":"获取帐号密码​","type":1,"pageTitle":"获取天翼光猫 F412 超级管理员帐号密码","url":"blog/get-super-admin-password-of-f412#获取帐号密码","content":"打开 cmd，输入命令：telnet 192.168.1.1登录帐号：root登录密码：Zte521输入命令：sendcmd 1 DB p UserInfo "},{"title":"fnm：Node.js 版本管理器","type":0,"sectionRef":"#","url":"blog/fnm-the-node-js-version-manager","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"fnm：Node.js 版本管理器","url":"blog/fnm-the-node-js-version-manager#前言","content":"Node.js 版本管理器有很多。 下表列出我体验过的 Node.js 版本管理器。 Node.js 版本管理器\t开发语言\t运行平台n 1\tShell\tmacOS、Linux nvm 2\tShell\tmacOS、Linux nodebrew 3\tPerl\tmacOS、Linux fnm 4\tRust\tmacOS、Linux、Windows nvs 5\tJavaScript\tmacos、Linux、Windows 其中： n，不好，要 root 权限；nvm，严重拖慢 Shell 的启动速度；nodebrew，还不错，但是需要 Perl；fnm，个人感觉最好的；nvs，安装不方便。 本文介绍其中的 fnm。fnm 有以下优势： Rust 编写，直接运行二进制文件即可；没有其他依赖，不需要安装解释器；不会过多影响 Shell 启动速度；兼容.nvmrc配置文件。 "},{"title":"在 macOS 上安装​","type":1,"pageTitle":"fnm：Node.js 版本管理器","url":"blog/fnm-the-node-js-version-manager#在-macos-上安装","content":"你可以使用 Homebrew 安装。 brew install fnm  安装完成之后在 Shell 启动文件里加入初始化命令，如~/.zshrc。 # echo &quot;eval $(fnm env)&quot; &gt;&gt; ~/.zshrc eval $(fnm env)  "},{"title":"在 Linux 上安装​","type":1,"pageTitle":"fnm：Node.js 版本管理器","url":"blog/fnm-the-node-js-version-manager#在-linux-上安装","content":"你可以使用 Homebrew 安装。 brew install fnm  安装完成之后在 Shell 启动文件里加入初始化命令，如~/.bashrc。 # echo &quot;eval $(fnm env)&quot; &gt;&gt; ~/.bashrc eval $(fnm env)  "},{"title":"在 Windows 上安装​","type":1,"pageTitle":"fnm：Node.js 版本管理器","url":"blog/fnm-the-node-js-version-manager#在-windows-上安装","content":"你可以使用 Scoop 或者 Chocolatey 安装。 scoop install fnm # choco install fnm  安装完成之后在 Shell 启动文件里加入初始化命令。 以下命令用于创建并用记事本打开 Shell 启动文件。 if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE  之后在其中加入下面命令并保存。 fnm env | Out-String | Invoke-Expression  "},{"title":"使用​","type":1,"pageTitle":"fnm：Node.js 版本管理器","url":"blog/fnm-the-node-js-version-manager#使用","content":"# 列出可以下载的版本 fnm list-remote # 下载最新 lts 版本 fnm install --lts # 列出已安装版本 fnm list # 使用某个版本 fnm use v16.15.1 # 用某个版本运行命令 fnm exec --using=v16.15.1 node --version # 卸载某个版本 fnm uninstall v16.15.1  jasongin/nvs: Node Version Switcher - A cross-platform tool for switching between versions and forks of Node.js↩Schniz/fnm: 🚀 Fast and simple Node.js version manager, built in Rust↩hokaccha/nodebrew: Node.js version manager↩nvm-sh/nvm: Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions↩tj/n: Node version management↩ "},{"title":"使用 Google 搜索时指定 No Counrty Redirect","type":0,"sectionRef":"#","url":"blog/google-no-counrty-redirect","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"使用 Google 搜索时指定 No Counrty Redirect","url":"blog/google-no-counrty-redirect#前言","content":"在使用爱国上网的过程中，IP 地址经常在不同国家间变动。默认情况下 Google 搜索的结果会偏好当前 IP 属地的语言，这就导致在使用日本 IP 时会有一堆日文结果看不懂。 你可以在搜索参数中加上gws_rd=cr来组织这样的默认行为，并且加上gl=cn来强制使用中文。 "},{"title":"使用​","type":1,"pageTitle":"使用 Google 搜索时指定 No Counrty Redirect","url":"blog/google-no-counrty-redirect#使用","content":"搜索时使用如下请求，%s替换为搜索词。gl参数可以改为任意国家代码。 https://www.google.com/search?q=%s&amp;pws=0&amp;gl=cn&amp;gws_rd=cr  "},{"title":"在 Chrome 中设置​","type":1,"pageTitle":"使用 Google 搜索时指定 No Counrty Redirect","url":"blog/google-no-counrty-redirect#在-chrome-中设置","content":"在 Chrome 搜索引擎的设置中添加一个新的搜索引擎，然后将其设为默认搜索引擎。  "},{"title":"参考资料​","type":1,"pageTitle":"使用 Google 搜索时指定 No Counrty Redirect","url":"blog/google-no-counrty-redirect#参考资料","content":"建议大家都把 Google 给 ncr 一下 - V2EXHow to Force Google Chrome to Use Google.com Instead of Country Specific Version "},{"title":"在 Proxmox VE 中安装群晖 DSM","type":0,"sectionRef":"#","url":"blog/install-synology-dsm-in-proxmox-ve","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#前言","content":"感觉比在 ESXi 中安装要简单不少。本文中使用 DS918+ 型号引导和系统。 "},{"title":"文中从互联网上下载的文件备份​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#文中从互联网上下载的文件备份","content":"文中有一些文件是从互联网上下载的，为了防止其中的某些资源在某些时刻时效，这里做一个备份。 "},{"title":"下载引导​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#下载引导","content":"在 XPEnology Community1 下载 DS918+ v1.04b 引导文件，得到synoboot.img。  "},{"title":"下载系统​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#下载系统","content":"v1.04b 支持 DSM 6.2 或 6.2.1 系统，去 群晖网站 2 下载系统；首先选择系统版本，这里选择 6.2.1 的第一个版本 6.2.1-23824，得到DSM_DS918+_23739.pat。   "},{"title":"创建虚拟机​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#创建虚拟机","content":"在 PVE 的 Web 控制台中创建虚拟机。 常规。需要注意一下 VM ID，后面导入引导磁盘的时候用的到；  操作系统。不使用任何介质；  系统。没什么需要更改的，保持默认设置即可；  磁盘。删除默认的磁盘；  CPU。根据需要设置；  内存。根据需要设置；  网络。网卡模型选择 E1000，取消勾选防火墙；  确认；  删除 CD/DVD 驱动器；  添加一个串行端口，可以在控制台上看到引导日志，对于排查错误很有帮助。  "},{"title":"导入引导磁盘​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#导入引导磁盘","content":"img格式的镜像是不能直接作为磁盘使用的，需要你手动把它转换为qcow2格式并导入到虚拟机中。 首先需要上传synoboot.img到 PVE 主机内，可以通过 SFTP 上传，存放位置没有要求，临时用用，用完可以在 PVE 上删除。 使用 SSH 连接上 PVE 主机，执行命令。 执行下面的命令来转换磁盘格式。 qemu-img convert -f raw -O qcow2 synoboot.img synoboot.qcow2  执行下面的命令来导入磁盘。其中104是虚拟机 ID，local-lvm是存储位置的名称；你可能要根据你的情况对命令进行一些修改。 qm importdisk 104 synoboot.qcow2 local-lvm  命令执行完毕之后可以在 PVE Web 控制台中查看到一个未使用的磁盘。  双击该磁盘或点击「编辑」即可添加这个磁盘到虚拟机。总线选择 SATA。  "},{"title":"硬盘直通​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#硬盘直通","content":"这里直接直通 SATA/SAS 控制器，要确保你的 PVE 操作系统没有安装在该控制器上的硬盘内，不然会导致 PVE 无法正常启动。 如果你没有其他硬盘控制器（如 NVME）用来安装 PVE 的话就不要选择直通硬盘控制器，你可以选择其他方法来直通硬盘。 直通硬盘控制器的优点是 DSM 可以读取到硬盘的 S.M.A.R.T.3 信息。 使用 SSH 连接上 PVE 主机，执行命令。 编辑/etc/default/grub文件。 nano /etc/default/grub  # 在里面找到 # GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot; # 如果是 intel cpu 请改为 GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet intel_iommu=on iommu=pt&quot; # 如果是 amd cpu 请改为 GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet amd_iommu=on iommu=pt&quot;  更新 grub。 update-grub  重启主机。 reboot  在 Web 控制台中向虚拟机添加 PCI 设备。  "},{"title":"设置引导顺序​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#设置引导顺序","content":"在「选项」-&gt;「引导顺序」中设置引导顺序。勾选从sata0启动，把其他启动项都去掉。  "},{"title":"启动和安装系统​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#启动和安装系统","content":"在 Web 控制台中启动虚拟机。 通过串口控制台查看 IP。在启动虚拟机后需要快速打开串口控制台，要不然可能会错过一些日志信息。   或是通过路由器的管理页面查看 DSM 的 IP 地址；  再或者使用 Synology Assistant4 寻找 DSM 的 IP 地址；  访问该 IP 地址即可看见 DSM 安装向导。点击「设置」开始安装向导；  点击「手动安装」，不要点「立即安装」，不然会安装最新的系统导致无法启动；  点击「浏览」，上传自己下载的系统文件DSM_DS918+_23824.pat，之后再点击「立即安装」；   系统安装完毕。  可以去串口控制台看日志，日志打印完毕就代表启动成功了；并且在串口控制台内还可以看到 IP 地址。如果网页没有自动刷新的话你可以手动刷新一下网页。  "},{"title":"DSM 设置​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#dsm-设置","content":"设置用户名和密码。  关闭自动更新。  不要使用 QuickConnect，正版群晖可以使用，黑群晖就不要用了。  搞定。  "},{"title":"创建存储空间​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#创建存储空间","content":"在「存储空间管理员」套件中创建存储空间。注意在创建存储空间的时候不要勾选使用引导盘。  系统工作正常。   "},{"title":"参考资料​","type":1,"pageTitle":"在 Proxmox VE 中安装群晖 DSM","url":"blog/install-synology-dsm-in-proxmox-ve#参考资料","content":"以下是在编写本文时使用到的、但未在文中明确引用的参考资料，希望对你有帮助。 笔记本上 PVE 虚拟机安装黑群晖并设置硬盘直通_哔哩哔哩_bilibiliPVE7.安装黑群晖（记录）_哔哩哔哩_bilibiliProxmox VE(PVE) 系统开启 IOMMU 功能实现硬件直通 - NAS 阁佛西博客 - Proxmox VE pve 硬盘直通 DSM 6.2 Loader - Loaders - XPEnology Community↩Synology Archive Download Site - Index of /download/Os/DSM↩S.M.A.R.T. - 维基百科，自由的百科全书↩下载中心 - DS918+ | Synology 群晖科技↩ "},{"title":"SSH 连接保活","type":0,"sectionRef":"#","url":"blog/keeping-ssh-connections-alive","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"SSH 连接保活","url":"blog/keeping-ssh-connections-alive#前言","content":"某些情况下路由器会丢弃长时间不活跃的 TCP 连接，通过正确配置可以防止 SSH 连接闲置后意外被断开。 可以配置客户端或者服务端定期发送心跳包来保持连接活跃；选择其一配置即可。 "},{"title":"客户端配置​","type":1,"pageTitle":"SSH 连接保活","url":"blog/keeping-ssh-connections-alive#客户端配置","content":"修改~/.ssh/config文件。 Host * ServerAliveInterval 60 ServerAliveCountMax 5  "},{"title":"服务端配置​","type":1,"pageTitle":"SSH 连接保活","url":"blog/keeping-ssh-connections-alive#服务端配置","content":"修改/etc/ssh/sshd_config文件。 ClientAliveInterval 60 ClientAliveCountMax 5  重启 SSH 服务。 systemctl restart sshd  "},{"title":"参考资料​","type":1,"pageTitle":"SSH 连接保活","url":"blog/keeping-ssh-connections-alive#参考资料","content":"ssh 与远程机器保持心跳（linux） - MTJOssh_config(5): OpenSSH SSH client config files - Linux man page "},{"title":"使用 GPG 签名和加密","type":0,"sectionRef":"#","url":"blog/gpg","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#前言","content":"GNU Privacy Guard（GnuPG 或 GPG）是一个密码学软件，用于加密、签名通信内容及管理非对称密码学的密钥。GnuPG 是自由软件，遵循 IETF 订定的 OpenPGP 技术标准设计，并与 PGP 保持兼容。 "},{"title":"安装​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#安装","content":"在 macOS 上可以使用 Homebrew 安装。 brew install --cask gpg-suite  在 Debian 上可以使用 apt 安装。 apt install gunpg  "},{"title":"创建自己的公钥和私钥​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#创建自己的公钥和私钥","content":"--full-gen-key：使用完整向导创建密钥 gpg --full-gen-key gpg (GnuPG/MacGPG2) 2.2.34; Copyright (C) 2022 g10 Code GmbH This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card # 选择 4，只生成一个主私钥，后面再生成子私钥使用 Your selection? 4 RSA keys may be between 1024 and 4096 bits long. What keysize do you want? (3072) 4096 Requested keysize is 4096 bits Please specify how long the key should be valid. 0 = key does not expire &lt;n&gt; = key expires in n days &lt;n&gt;w = key expires in n weeks &lt;n&gt;m = key expires in n months &lt;n&gt;y = key expires in n years # 主私钥永不过期 Key is valid for? (0) 0 Key does not expire at all # y Is this correct? (y/N) y GnuPG needs to construct a user ID to identify your key. # uid 名称 Real name: Bug-Proof # uid 电子邮件 Email address: bug-proof@example.org # uid 备注 Comment: for test only You selected this USER-ID: &quot;Bug-Proof (for test only) &lt;bug-proof@example.org&gt;&quot; # O Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O We need to generate a lot of random bytes. It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy. gpg: revocation certificate stored as '/Users/x/.gnupg/openpgp-revocs.d/8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272.rev' public and secret key created and signed. Note that this key cannot be used for encryption. You may want to use the command &quot;--edit-key&quot; to generate a subkey for this purpose. pub rsa4096/0x7DCE475DEA06B272 2022-07-04 [SC] Key fingerprint = 8A8F B3D3 C4C8 1471 E7D0 DBA7 7DCE 475D EA06 B272 uid Bug-Proof (for test only) &lt;bug-proof@example.org&gt;  "},{"title":"列出密钥​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#列出密钥","content":"-k，--list-keys：列出公钥-K，--list-secret-keys：列出私钥--keyid-format long：显示完整的 keyid # 列出公钥 gpg --keyid-format long -k /Users/x/.gnupg/pubring.kbx ------------------------------- pub rsa4096/7DCE475DEA06B272 2022-07-04 [SC] 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272 uid [ultimate] Bug-Proof (for test only) &lt;bug-proof@example.org&gt;  # 列出私钥 gpg --keyid-format long -K /Users/x/.gnupg/pubring.kbx ------------------------------- sec rsa4096/7DCE475DEA06B272 2022-07-04 [SC] 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272 uid [ultimate] Bug-Proof (for test only) &lt;bug-proof@example.org&gt;  下表是结果中的一些关键词解释。 缩写\t原文\t解释pub\tpublic key\t公钥 sec\tsecret key\t私钥 uid\tuser identification\t用户信息 sub\tpublic subkey\t子公钥 ssb\tsecret subkey\t子私钥 S\tSign\t表示可以用于签名 C\tCertify\t可以用于认证 E\tEncrypt\t加密 A\tAuthenticate\t认证 "},{"title":"管理密钥和子密钥​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#管理密钥和子密钥","content":"主私钥不应该直接使用，主私钥只用来管理主密钥和子密钥，使用子私钥来解密和签名。 gpg --edit-key Bug-Proof gpg --edit-key 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272  --edit-key：后跟用户名或者指纹 之后会进入交互式命令行，在其中可以使用命令来对密钥进行管理。 addkey，增加子密钥key &lt;n&gt;，后跟密钥 ID，有些单体命令需要提前选择要操作的 key，使用key 0取消选择，key *选择所有 expire，更改子密钥的过期时间delkey，删除子密钥revkey，吊销子密钥change-usage，更改子密钥用户 expire，如果没有选择子密钥，此命令更改主密钥的过期时间trust，更改此密钥的信任级别passwd，更改主密钥密码change-usage，更改主密钥用途save，保存更改quit，退出 "},{"title":"生成子密钥​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#生成子密钥","content":"gpg --edit-key 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272 gpg (GnuPG/MacGPG2) 2.2.34; Copyright (C) 2022 g10 Code GmbH This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Secret key is available. sec rsa4096/7DCE475DEA06B272 created: 2022-07-04 expires: never usage: SC trust: ultimate validity: ultimate [ultimate] (1). Bug-Proof (for test only) &lt;bug-proof@example.org&gt; # addkey 创建子密钥 gpg&gt; addkey Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card # 创建一个 RSA 格式的子密钥，仅用于签名 Your selection? 4 RSA keys may be between 1024 and 4096 bits long. # 密钥长度，默认 3072 What keysize do you want? (3072) Requested keysize is 3072 bits Please specify how long the key should be valid. 0 = key does not expire &lt;n&gt; = key expires in n days &lt;n&gt;w = key expires in n weeks &lt;n&gt;m = key expires in n months &lt;n&gt;y = key expires in n years # 设置过期时间 1 年 Key is valid for? (0) 1y Key expires at Wed Jul 5 19:51:48 2023 CST # y Is this correct? (y/N) y # y Really create? (y/N) y We need to generate a lot of random bytes. It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy. sec rsa4096/7DCE475DEA06B272 created: 2022-07-04 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa3072/D45B326AA437793B created: 2022-07-05 expires: 2023-07-05 usage: S [ultimate] (1). Bug-Proof (for test only) &lt;bug-proof@example.org&gt; # addkey 创建子密钥 gpg&gt; addkey Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card # 创建一个 RSA 格式的子密钥，仅用于签名 Your selection? 6 RSA keys may be between 1024 and 4096 bits long. # 密钥长度，默认 3072 What keysize do you want? (3072) Requested keysize is 3072 bits Please specify how long the key should be valid. 0 = key does not expire &lt;n&gt; = key expires in n days &lt;n&gt;w = key expires in n weeks &lt;n&gt;m = key expires in n months &lt;n&gt;y = key expires in n years # 设置过期时间 1 年 Key is valid for? (0) 1y Key expires at Wed Jul 5 19:52:02 2023 CST # y Is this correct? (y/N) y # y Really create? (y/N) y We need to generate a lot of random bytes. It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy. sec rsa4096/7DCE475DEA06B272 created: 2022-07-04 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa3072/D45B326AA437793B created: 2022-07-05 expires: 2023-07-05 usage: S ssb rsa3072/E7728368B3AAB2B7 created: 2022-07-05 expires: 2023-07-05 usage: E [ultimate] (1). Bug-Proof (for test only) &lt;bug-proof@example.org&gt; gpg&gt; save  "},{"title":"管理 uid​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#管理-uid","content":"adduid，增加用户信息uid &lt;n&gt;，后跟 uid 索引，选择某个 uid 操作，使用uid 0取消选择，uid *选择所有save，保存修改 "},{"title":"上传公钥到公开服务器​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#上传公钥到公开服务器","content":"除非必要，不要上传公钥到公开的公钥服务器，上传之后就不能删除了，只能进行修改和吊销，你的用户名和电子邮件地址所有人都能看到。 "},{"title":"签名和验证​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#签名和验证","content":"签名的使用场景是确保自己发送给别人的信息在传输过程中不被修改。签名使用自己的私钥，接收者用我的公钥进行验证。 -s,--sign：签名--clear-sing：签名和原文放一起，都是 ASCII 形式-b，--detach-sign：签名和文件分离--verify：验证-a，--armor：输出 ASCII 内容，而不是二进制内容-u，--local-user：指定使用某个私钥签名 准备一个文件message.txt作为测试文件，其内容如下。 Hello  # 签名，会生成 message.txt.gpg 文件 # 发送的时候两个文件一起发送 gpg -u D45B326AA437793B -s message.txt # 验证 # 验证的时候要把原文和签名放在一起 gpg --verify message.txt.gpg gpg: Signature made Tue Jul 5 20:29:49 2022 CST gpg: using RSA key 589AFC0EF76D48A4C1165E63D45B326AA437793B gpg: Good signature from &quot;Bug-Proof (for test only) &lt;bug-proof@example.org&gt;&quot; [ultimate]  # 签名，会生成 message.txt.asc，是文本文件，签名和原文放在一起 # 发送的时候只用发送 message.txt.asc gpg -u D45B326AA437793B --clear-sign message.txt cat message.txt.asc -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA256 Hello -----BEGIN PGP SIGNATURE----- iQGzBAEBCAAdFiEEWJr8DvdtSKTBFl5j1FsyaqQ3eTsFAmLELz8ACgkQ1FsyaqQ3 eTvY2Av/XCDbRdK8kM4r5PRnALVKYGsVVJC84JPfxa7iPG1/1bUtRMZm69aGMApa sm0CHDElRTwVZf3orIZ2u/Ahmlrdne9GULa3FkZGSZ5DY9xGHCbk7zmIJJXwTJZw 7as6uexU5Qb3sEA+RrbhanDv6Q36LS0772MwB/ijcHppakbxUPPLhdZOSAjm+0s6 Qy6JYW6iTjaXMcxS4xCPJ4LGFDeV6uOjuDNfBOL3ZdyT/jgIFm5LW5Sb4xiFn/gk RZit0xga38RgczmBWWOCj8TMoSz7VBuHWNl+5OlcGrE5Fnemv2p1BkcZ47tTfm1T SF+bWMUsgRLvH15kUtfweQ58BDX2dZWb3SrAjMwACoRDMZ314grPXJE/Tl5ZXvc4 7wtCI+g7E7eqNJ3w3kWqb2LNo1BuWAjiaaHmTJ7gmGtG6VqX1Muk2JyyWr49LyZA YHQFXVfVYBmih5FgrU3l7mKWfTv+niVRp6JQXxtXnbH1SOwZdnz+HKR2UEf2IwRD +HyHkNcH =w3M/ -----END PGP SIGNATURE----- # 验证 gpg --verify message.txt.asc gpg: Signature made Tue Jul 5 20:31:59 2022 CST gpg: using RSA key 589AFC0EF76D48A4C1165E63D45B326AA437793B gpg: Good signature from &quot;Bug-Proof (for test only) &lt;bug-proof@example.org&gt;&quot; [ultimate] gpg: WARNING: not a detached signature; file 'message.txt' was NOT verified!  # 签名，生成 message.txt.sig，签名文件是二进制的 gpg -u D45B326AA437793B -b message.txt # 验证 gpg --verify message.txt.sig gpg: assuming signed data in 'message.txt' gpg: Signature made Tue Jul 5 20:40:21 2022 CST gpg: using RSA key 589AFC0EF76D48A4C1165E63D45B326AA437793B gpg: Good signature from &quot;Bug-Proof (for test only) &lt;bug-proof@example.org&gt;&quot; [ultimate]  # 签名，生成 message.txt.asc，只存放签名不存放原文 gpg -u D45B326AA437793B -a -b message.txt cat message.txt.asc -----BEGIN PGP SIGNATURE----- iQGzBAABCAAdFiEEWJr8DvdtSKTBFl5j1FsyaqQ3eTsFAmLEO5QACgkQ1FsyaqQ3 eTtA/AwAtYnst04ORGPaBnq/Rz7QLjg+L0FlNFL3+BELAjaPfYAmxjW/rsKQIS6B r7JVXZsIs9EwzVMQFA6EI0NY1pOomAz4szzf/jqipJT3TadXjyh1Wx3Js/+xdOhm aUboz2aHxeEDvq2g1bF3nbOQ8kE1TJTZUX7fGD6BeFnCF2HVkHb1MEBzZ9xCJGFE njVF52gP/GFInHPUuIa2GCeEtGv/Dsr5IjODqZwohxVJq0rGvhBGTcmGv/6pOeLp B4g7uauqGv6QZtiK5gf4BfrPyeGXVHiSD2V5mKOSKRi0gTaUTf0UEl1UehpWOfdo vwX0CnidD5uxzqMhPP5o587eLx9DczFw4IsscjflSSbBp7eW5t6EXm+KPkOj22vc qpc81dQQfXCm1FjOHedmfyJLPt+RXOM53KBHT6CaNUUzWx2a4x4kbsfC0auzMbXU nye9hARzbSNvMD6cRqY/y0yAsYK/6ilXeX5qKwwXA/D0IFl0md8eZfsOQqYPA3E3 JJWVt5Hw =ESB9 -----END PGP SIGNATURE----- # 验证 gpg --verify message.txt.asc gpg: assuming signed data in 'message.txt' gpg: Signature made Tue Jul 5 21:24:36 2022 CST gpg: using RSA key 589AFC0EF76D48A4C1165E63D45B326AA437793B gpg: Good signature from &quot;Bug-Proof (for test only) &lt;bug-proof@example.org&gt;&quot; [ultimate]  "},{"title":"加密和解密​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#加密和解密","content":"加密用接收者的公钥，解密用接收者的私钥。 -e，--encrypt：加密-c，--symmetric：对称加密-d，--decrypt：解密-r，--recipient：指定接收者公钥-a，--armor：输出 ASCII 内容，而不是二进制内容-o，--output：指定输出文件名，而不是输出到标准输出 # 加密，生成 message.txt.gpg，内容为二进制格式 gpg -r 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272 -e message.txt # 加密，生成 message.txt.asc，内容为文本格式 gpg -r 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272 -a -e message.txt  # 解密，输出到屏幕 gpg -d message.txt.gpg gpg -d message.txt.asc # 解密，输出到文件 gpg -d message.txt.gpg -o message-decrypted.txt gpg -d message.txt.asc -o message-decrypted.txt  "},{"title":"对称加密​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#对称加密","content":"GPG 除了可以使用密钥进行非对称加密，还可以使用对称加密，即加密和解密都用同一个密码，不需要密钥。 -c，--symmetric：对称加密--cipher-algo：选择加密算法，默认是 AES-128 # 对称加密，会有弹窗提示你输入密码，生成 message.txt.gpg gpg --symmetric message.txt # 对称加密，会有弹窗提示你输入密码，生成 message.txt.asc gpg -a --symmetric message.txt  # 解密 gpg -d message.txt.gpg gpg -d message.txt.asc  "},{"title":"签名并加密​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#签名并加密","content":"# 签名并加密，输出 message.txt.asc，文本文件 gpg -u D45B326AA437793B -r 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272 -a -s -e message.txt # 解密并验证 gpg -d message.txt.asc -o message-decrypted.txt  "},{"title":"导出密钥​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#导出密钥","content":"下面的命令用于导出公钥。导出的公钥不仅仅是主公钥，还包括所有子密钥的公钥。 gpg -a -o bug-proof.pub --export 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272  下面的命令用于导出主私钥。在备份的时候记得把吊销证书一起备份了。 要在密钥指纹后加上叹号!，不然会连子密钥的私钥一起导出了。 # 导出主密钥 gpg -a -o bug-proof.sec --export-secret-keys 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272! # 导出主密钥和子密钥 gpg -a -o bug-proof.all.sec --export-secret-keys 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272  下面的命令用于单独导出子私钥。要在密钥指纹后加上叹号!，不然所有子密钥的私钥一起导出了。 gpg -a -o bug-proof.s.ssb --export-secret-subkeys D45B326AA437793B! gpg -a -o bug-proof.e.ssb --export-secret-subkeys E7728368B3AAB2B7!  "},{"title":"删除密钥​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#删除密钥","content":"# 删除主私钥 gpg --delete-secret-keys 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272! # 删除子私钥 gpg --delete-secret-keys D45B326AA437793B! gpg --delete-secret-keys E7728368B3AAB2B7! # 删除公钥 gpg --delete-keys 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272  "},{"title":"导入密钥​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#导入密钥","content":"# 导入公钥 gpg --import bug-proof.pub # 导入主私钥 gpg --import bug-proof.sec # 导入子私钥 gpg --import bug-proof.s.ssb # 导入子私钥 gpg --import bug-proof.e.ssb  "},{"title":"生成吊销证书​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#生成吊销证书","content":"在你忘记主密钥的密码，或者失去主密钥控制权的时候可以使用吊销证书来吊销密钥。吊销之后会生成一个新的公钥，其中包含了吊销信息，你需要把这个公钥发布到你一贯发布公钥的地方，通知其他人此密钥已吊销。 -o，--output：指定输出文件名，而不是输出到标准输出--gen-revoke，--generate-revocation：生成吊销证书 gpg -o bug-proof.revoke.cert --gen-revoke 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272 sec rsa4096/7DCE475DEA06B272 2022-07-04 Bug-Proof (for test only) &lt;bug-proof@example.org&gt; # y Create a revocation certificate for this key? (y/N) y Please select the reason for the revocation: 0 = No reason specified 1 = Key has been compromised 2 = Key is superseded 3 = Key is no longer used Q = Cancel (Probably you want to select 1 here) # 选择吊销原因 Your decision? 0 Enter an optional description; end it with an empty line: # 自己写吊销原因，可以不写 &gt; Reason for revocation: No reason specified (No description given) # y Is this okay? (y/N) y ASCII armored output forced. Revocation certificate created. Please move it to a medium which you can hide away; if Mallory gets access to this certificate he can use it to make your key unusable. It is smart to print this certificate and store it away, just in case your media become unreadable. But have some caution: The print system of your machine might store the data and make it available to others!  "},{"title":"吊销密钥​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#吊销密钥","content":"吊销密钥只需要公钥和吊销证书，把公钥和吊销证书合并之后公钥会发生变化，发布新公钥即可对其他人表明已吊销证书。 这个步骤是吊销整个密钥，如果需要吊销子密钥的话可以在--edit-key命令中完成。 吊销密钥的步骤如下。 导出吊销证书，这一步要提前做，把吊销证书和私钥单独保存导入吊销证书，和现有的公钥合并导出合并之后的公钥发布公钥其他人导入你的新公钥就知道你的密钥已经吊销了 # 上一步已经提前导出了吊销证书 gpg --import bug-proof.revoke.cert # 查看证书列表，会看到 revoked 标记 gpg --keyid-format long -k /Users/x/.gnupg/pubring.kbx ------------------------------- pub rsa4096/7DCE475DEA06B272 2022-07-04 [SC] [revoked: 2022-07-05] 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272 uid [ revoked] Bug-Proof (for test only) &lt;bug-proof@example.org&gt; # 导出新公钥 gpg -a -o bug-proof.revoked.pub --export 8A8FB3D3C4C81471E7D0DBA77DCE475DEA06B272  "},{"title":"最佳实践​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#最佳实践","content":"主私钥只用来管理主密钥和子密钥，日常的签名和加密用途只用子密钥，可以为不同用途分别生成不同的子密钥。 主密钥平时不导入到本地，而是保存在其他地方。 同时也要记得生成吊销证书并保存，主密钥可以丢，吊销证书一定不能丢。 "},{"title":"GPG 和 Git​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#gpg-和-git","content":"因为 Git 设置中的 username 和 email 都是可以随意修改的，所以并不一定能保证某个 Git 提交是真的你做的。 首先你需要把你的公钥上传至 Git 服务器，如 Github 或者 Gitlab。 设置 Git，使用子密钥签名。 git config --global user.signingkey D45B326AA437793B  # 签名提交 git commit -S -m &quot;commit message&quot; # 签名合并提交 git merge -S signed-branch # 验证提交 git log --show-signature # 签名标签 git tag -s v1.5 -m 'my signed 1.5 tag' # 验证标签 git tag -v &lt;tag-name&gt;  "},{"title":"什么情况下需要更新公钥​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#什么情况下需要更新公钥","content":"密钥吊销之后更改主密钥的有效期之后修改 uid 信息之后对子密钥进行修改之后 "},{"title":"参考资料​","type":1,"pageTitle":"使用 GPG 签名和加密","url":"blog/gpg#参考资料","content":"Gnu 隐私卫士 (GnuPG) 袖珍 HOWTO (中文版)2021 年，用更现代的方法使用 PGP（上） - C 的博客 |UlyC2021 年，用更现代的方法使用 PGP（中） - C 的博客 |UlyC2021 年，用更现代的方法使用 PGP（下） - C 的博客 |UlyCGPG 使用笔记GnuPG 学习笔记 - FBICLOUDSigning commits with GPG | GitLabGit - 签署工作 "},{"title":"在 Linux 中安装 Homebrew","type":0,"sectionRef":"#","url":"blog/linuxbrew-the-homebrew-on-linux","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"在 Linux 中安装 Homebrew","url":"blog/linuxbrew-the-homebrew-on-linux#前言","content":"Homebrew 1 是一款用 Ruby 编写的、针对 macOS 系统的包管理器。后来又更新了对 Linux 的支持，现在你可以在你的 Linux 系统中引入一个新的包管理器。 Homebrew 可以是对系统中默认包管理器的补充。有些需要的软件包并不收录在官方的软件仓库中，这种情况下就需要你自己下载或编译二进制文件，自己安装。Homebrew 的软件包收录范围广、更新快，可以简化你安装软件包的过程。 "},{"title":"安装依赖​","type":1,"pageTitle":"在 Linux 中安装 Homebrew","url":"blog/linuxbrew-the-homebrew-on-linux#安装依赖","content":"Homebrew 的安装和使用的过程依赖 Git。Homebrew 在安装软件包时可能会从源码在本机上编译二进制文件，所以需要用到 GCC 和 glibc。 如果你的操作系统是Debian或其派生的发行版，可以用apt来安装这些软件包。 apt install build-essential procps curl file git  如果你使用的操作系统是 Red Hat 系的，你可以使用yum来安装这些软件包。 sudo yum groupinstall 'Development Tools' sudo yum install procps-ng curl file git sudo yum install libxcrypt-compat # needed by Fedora 30 and up  这些安装命令参考自 Homebrew 文档中的 Homebrew on Linux 部分 2。 "},{"title":"安装 Homebrew​","type":1,"pageTitle":"在 Linux 中安装 Homebrew","url":"blog/linuxbrew-the-homebrew-on-linux#安装-homebrew","content":"Homebrew 本身和其安装的软件包都存放在用户目录下，所以安装和使用 Homebrew 不要求 root 权限。实际上出于安全考虑，Homebrew 禁止你用 root 权限运行它，因为软件包的安装脚本在 root 权限下可能会破坏你的系统（不管是有意还是无意的）。 Homebrew 推荐你将它安装在 linuxbrew 的用户目录下，该目录位于/home/linuxbrew/.linuxbrew，Homebrew 本身和它所安装的软件包都会存放于此目录中。 首先创建一个名为 linuxbrew 的用户，并配置其用户目录。 useradd -s /bin/bash linuxbrew mkdir /home/linuxbrew chown linuxbrew /home/linuxbrew  切换到 linuxbrew 用户执行安装脚本。 su - linuxbrew -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;  配置环境变量。创建文件/etc/profile.d/homebrew.sh，并把以下代码加入该文件中。 nano /etc/profile.d/homebrew.sh  HOMEBREW_PREFIX=&quot;/home/linuxbrew/.linuxbrew&quot; eval $(${HOMEBREW_PREFIX}/bin/brew shellenv) if [[ -r &quot;${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh&quot; ]] then source &quot;${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh&quot; else for COMPLETION in &quot;${HOMEBREW_PREFIX}/etc/bash_completion.d/&quot;* do [[ -r &quot;${COMPLETION}&quot; ]] &amp;&amp; source &quot;${COMPLETION}&quot; done fi  重启 Shell 后测试。运行下面的命令来测试 Homebrew 是否能正常工作，如果得到「Your system is ready to brew.」的提示则证明你的安装过程如期完成。如果你的 Homebrew 不能正常运行，它应该会给你提示。brew 要求用非 root 权限运行，所以你需要在使用 brew 命令的时候先切换到 Homebrew 用户。其安装的软件包可以在 root 用户下运行。 su - linuxbrew -c &quot;brew doctor&quot;  "},{"title":"安装软件包​","type":1,"pageTitle":"在 Linux 中安装 Homebrew","url":"blog/linuxbrew-the-homebrew-on-linux#安装软件包","content":"在使用brew命令之前你需要先切换到 linuxbrew 用户，但是通过 Homebrew 安装的软件包是可以供所有用户使用的。 下面的命令用于安装一个名为 hello 的软件包，其提供了一个名为hello的可执行文件，用于在控制台输出「Hello, world!」。 su - linuxbrew -c &quot;brew install hello&quot;  你可以使用brew search命令来搜索软件包；或者在网页 Homebrew Formulae 3 中搜索软件包，但是并不是所有软件包都适用于 Linux。 "},{"title":"进阶使用​","type":1,"pageTitle":"在 Linux 中安装 Homebrew","url":"blog/linuxbrew-the-homebrew-on-linux#进阶使用","content":"Homebrew 在 Linux 中的用法和其在 macOS 中一样。如果你没有用过 Homebrew，你可以参考一下brew help命令和brew commands命令的帮助以及 Homebrew 的官方文档 4。 The Missing Package Manager for macOS (or Linux) — Homebrew↩Homebrew on Linux — Homebrew Documentation↩homebrew-core — Homebrew Formulae↩Documentation — Homebrew Documentation↩ "},{"title":"挂载腾讯云 COS 到本地文件夹","type":0,"sectionRef":"#","url":"blog/mount-tencent-cos-on-local-file-system","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#前言","content":"2022-06-18 更新：本文中的解决办法有更好的方案，请查看 使用 s3fs 挂载腾讯云 COS 中的内容。 腾讯云提供了一个软件 cosfs 用于挂载 COS 到本地，可以使用标准的文件操作命令来操作 COS 中的内容。由于后端是云存储而不是真正的本地存储，所以有些操作的性能比较低。不推荐通过此种方式在其中修改文件内容或文件名称，仅仅下载文件和上传新文件的操作还是可以的。 腾讯云内网访问 COS 的下载流量不计费，可以通过腾讯云服务器把 COS 内容挂载到服务器，然后通过别的途径在外网下载，例如用 Rclone 通过 SFTP 把 COS 的内容复制到外网的机器，这样就不计下载流量的费用了，但是 API 调用次数还是要收费的。 文中所涉及的操作系统是 Debian，应该也适用于其他 Debian 系的操作系统。 "},{"title":"安装软件​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#安装软件","content":"cosfs1 依赖于 fuse，首先安装 fuse。 apt install fuse  安装 cosfs，官方提供了deb和rpm格式的安装包，Debian 系统用deb格式的，下载安装包之前可以先去 发布页面 2 检查一下是否有新版本。 # wget https://ghproxy.com/https://github.com/tencentyun/cosfs/releases/download/v1.0.19/cosfs_1.0.19-ubuntu20.04_amd64.deb wget https://github.com/tencentyun/cosfs/releases/download/v1.0.19/cosfs_1.0.19-ubuntu20.04_amd64.deb dpkg -i cosfs_1.0.19-ubuntu20.04_amd64.deb  "},{"title":"编写配置文件​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#编写配置文件","content":"配置文件应该存放在/etc/passwd-cosfs中。其中可以有多行，每行的格式如下。 &lt;BucketName-APPID&gt;:&lt;SecretId&gt;:&lt;SecretKey&gt;  例如你可以这样写。 examplebucket-1250000000:AKIDHTVVaVR6e3****:PdkhT9e2rZCfy6****  同时需要更改该文件的权限。 chmod 640 /etc/passwd-cosfs  "},{"title":"挂载​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#挂载","content":"先创建一个挂载点。 mkdir /mnt/cos  挂载，其中ourl指定了地域链接。 cosfs examplebucket-1250000000 /mnt/ -ourl=http://cos.ap-guangzhou.myqcloud.com  挂载之后就可以像对待普通文件系统的方式来操作 COS 中的文件了。 "},{"title":"取消挂载​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#取消挂载","content":"umount /mnt/cos  "},{"title":"局限性​","type":1,"pageTitle":"挂载腾讯云 COS 到本地文件夹","url":"blog/mount-tencent-cos-on-local-file-system#局限性","content":"该方法有一定 局限性 3，只在特定情况下好用，使用时要考虑性能问题。 随机或者追加写文件会导致整个文件的重写；元数据操作，例如 list directory，性能较差，因为需要远程访问 COS 服务器；文件/文件夹的 rename 操作不是原子的；多个客户端挂载同一个 COS bucket 时，依赖用户自行协调各个客户端的行为。例如避免多个客户端写同一个文件等等；不支持 hard link；不适合用在高并发读/写的场景，这样会让系统的 load 升高。 对象存储 COSFS 工具 - 工具指南 - 文档中心 - 腾讯云↩Releases · tencentyun/cosfs↩tencentyun/cosfs↩ "},{"title":"使用 s3fs 挂载腾讯云 COS 中的内容","type":0,"sectionRef":"#","url":"blog/mount-tencent-cos-using-s3fs","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"使用 s3fs 挂载腾讯云 COS 中的内容","url":"blog/mount-tencent-cos-using-s3fs#前言","content":"之前写过一篇文章关于挂载腾讯云 COS 内容到本地，其中使用到了一款名为 cosfs 的软件，后来我发现该软件是 s3fs 的一个分支。并且腾讯云 COS 兼容 S3 的 API，所以索性直接用 s3fs 算了。 之前那篇文章中也缺失了开机自动挂载的部分，我最近发现了一个内含 s3fs 的 Docker 镜像，可以通过 Docker 容器自动启动来实现开机自动挂载。 "},{"title":"项目介绍​","type":1,"pageTitle":"使用 s3fs 挂载腾讯云 COS 中的内容","url":"blog/mount-tencent-cos-using-s3fs#项目介绍","content":"docker-s3fs-client1 提供了内嵌 s3fs 的 Docker 镜像，该镜像可以把远程的 Amazon S3 仓库的内容挂载到容器中。 腾讯云 COS 兼容 Amazon S3 的 API，所以可以使用 s3fs 挂载腾讯云 COS 中的内容。 "},{"title":"使用示例​","type":1,"pageTitle":"使用 s3fs 挂载腾讯云 COS 中的内容","url":"blog/mount-tencent-cos-using-s3fs#使用示例","content":"接下来使用 Docker Compose 来配置并部署 docker-s3fs-client 容器。 s3fs/docker-compose.yml version: '3.8' services: s3fs: image: efrecon/s3fs restart: unless-stopped cap_add: - SYS_ADMIN security_opt: - 'apparmor:unconfined' devices: - /dev/fuse volumes: - /mnt/s3fs:/opt/s3fs/bucket:rshared environment: AWS_S3_BUCKET: xxxx-xxxxxx AWS_S3_ACCESS_KEY_ID: xxxxxxxxxxxxxxxxxx AWS_S3_SECRET_ACCESS_KEY: xxxxxxxxxxxxxxxxxx AWS_S3_URL: https://cos.ap-shanghai.myqcloud.com  在docker-compose.yml的volumes部分中，/mnt/s3fs:/opt/s3fs/bucket:rshared意味把宿主机mnt/s3fs文件夹挂载到容器里，你可能需要提前手动创建该文件夹；/opt/s3fs/bucket是固定的，并且rshared也是必不可少的。 docker-compose.yml中配置的环境变量看名称一般都知道什么意思，在挂载腾讯云 COS 的时候可以参考其 相关文档 2。 执行以下命令来启动容器，注意在包含docker-compose.yml的s3fs文件夹中执行。 docker-compose up -d  如果配置正确的话，容器正常启动后就能在宿主机中正常访问腾讯云 COS 的内容了。 根据上面的配置，可以在宿主机的mnt/s3fs目录中访问被挂载的腾讯云 COS 的内容。如果不能正确访问请查看容器日志排查错误。 efrecon/docker-s3fs-client: Alpine-based s3fs client: mount from container, make available to other containers↩对象存储 在兼容 S3 的第三方应用中使用 COS 的通用配置 - 最佳实践 - 文档中心 - 腾讯云↩ "},{"title":"为《求生之路 2》制作动态喷漆","type":0,"sectionRef":"#","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#前言","content":" 动态的喷漆也是这个游戏的乐趣之一，尝试自己制作一下动态喷漆，将 GIF 图片转换为可以在游戏中使用的动态喷涂文件。 文中使用的工具和成品可以从 这里 下载。 "},{"title":"准备工作​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#准备工作","content":"一张 GIF 图片；GIF 图片分解工具，用于把动态图的每一帧分解出来，文中使用的是 GifSplitter1；VTFEdit2，核心工具，用于制作 VTF 格式的动态图。 "},{"title":"分解 GIF​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#分解-gif","content":"这里使用的是 GifSplitter，目的是将 GIF 图片的每一帧都分解出来；其他功能类似的软件和在线工具都可以。  "},{"title":"制作 VTF​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#制作-vtf","content":"打开 VTFEdit，点击左上角的「导入」按钮，选择并导入上一步中分离出来的所有图片。  接下来设置贴图尺寸，选中「限定贴图尺寸」，高度和宽度都设置为 128，其他设置保持默认。  再切换到「信息」页中，查看文件大小；要确保其小于 512KB，否则无法喷出。如果文件太大的话，就把要导入的图片删除一些，再重复这些步骤，直至满足条件。 再满足条件之后就可以保存了，保存的时候注意不要使用中文文件名，不然在游戏里浏览文件的时候中文名会乱码。  "},{"title":"在游戏中导入​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#在游戏中导入","content":"打开游戏，在游戏设置中依次找到「导入喷漆图案」，选择上一步中制作好的 VTF 文件。  "},{"title":"后记​","type":1,"pageTitle":"为《求生之路 2》制作动态喷漆","url":"blog/making-dynamic-spray-paint-for-left-4-dead-2#后记","content":"整个制作过程也不复杂，核心工具是 VTFEdit；至于分解 GIF 的工具就很多了，可以很灵活地选择其他软件来完成这个任务。 最重要的是控制文件大小，不能超过限制，不然在游戏中无法使用。如果文件大小太大的话可以考虑在分解出的图片中删除一些图片，来达到减小文件大小的目的。比如可以隔帧删除，每隔一张图片就删除一张图片，应该会很有效。 GifSplitter - Break GIF animation down into individual image frames↩VTFEdit - Valve Developer Community↩ "},{"title":"配置 oh-my-zsh","type":0,"sectionRef":"#","url":"blog/oh-my-zsh","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#前言","content":"oh-my-zsh1 是 zsh2 的一款插件管理器，提供了很多 zsh 的插件和主题。 zsh 的优点是兼容 bash 语法，可以在日常工作中替换掉 bash，并且可以享受 zsh 的很多特性。 "},{"title":"安装​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#安装","content":"安装 oh-my-zsh 之前需要先安装 zsh 和 git，oh-my-zsh 依赖它们在能正常工作。 在 zsh 中执行以下命令安装 oh-my-zsh。 sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;  安装脚本就是帮你克隆了 oh-my-zsh 的仓库到~/.oh-my-zsh，并且给你新建了一个~/.zshrc文件模板，用于在 zsh 启动时加载 oh-my-zsh。 你之前的.zshrc文件内容被转移到.zshrc.pre-oh-my-zsh，现在的.zshrc的内容是全新的，如果你之前在用户配置文件里做了重要配置，你需要将.zshrc.pre-oh-my-zsh里的内容附加到现在的.zshrc之后，以确保之前的功能正常使用。 "},{"title":"主题​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#主题","content":"oh-my-zsh 默认自带了许多主题，这些主题文件存放在~/.oh-my-zsh/themes/文件夹下。你可以在 oh-my-zsh 主题 wiki3 中参考这些主题的预览图。 编辑.zshrc文件，修改ZSH_THEME配置，执行exec zsh命令或重启终端即可看到新主题的效果。 ZSH_THEME=&quot;robbyrussell&quot;  "},{"title":"第三方主题​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#第三方主题","content":"除了默认自带的主题外，你还可以使用第三方主题，如 Dracula4 主题。 下面的命令用于克隆 Dracula 主题的仓库到本地的~/zsh-dracula文件夹。 git clone https://github.com/dracula/zsh.git ~/zsh-dracula  你可以手动复制~/zsh-dracula下的dracula.zsh-theme文件和lib文件夹至~/.oh-my-zsh/custome/themes/文件夹下来完成主题的安装。 也可以使用以下命令创建一个主题的软连接到主题文件夹，来完成主题的安装。 ln -s ~/zsh-dracula/dracula.zsh-theme $ZSH_CUSTOM/themes/dracula.zsh-theme  在安装完成之后编辑.zshrc文件，修改ZSH_THEME配置，执行exec zsh命令或重启终端即可看到新主题的效果。 ZSH_THEME=&quot;dracula&quot;  "},{"title":"插件​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#插件","content":"oh-my-zsh 默认自带了许多插件，这些插件文件存放在~/.oh-my-zsh/plugins/文件夹下。你可以在 oh-my-zsh 插件 wiki5 中查阅默认插件的目录和文档。 编辑.zshrc文件，修改plugins配置，把插件名称写入其中即可启用插件，每个插件名称之间用空格或换行分隔，不要用逗号。注意过多的插件会影响启动时间。执行exec zsh命令或重启终端即可让配置文件生效。 plugins=(git theme)  下面记录一些自用的插件。 "},{"title":"git6​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#git","content":"默认启用的插件，提供了一些 Git 命令的别名和 Git 相关的常用命令，详情可参考其文档 6。 "},{"title":"theme7​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#theme","content":"用命令预览主题，不需要修改配置文件。 theme，随机加载主题lstheme，列出所有主题theme &lt;name&gt;，预览指定主题 "},{"title":"z8​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#z","content":"提供一个z命令用于常用目录快速跳转，日常中可以替换掉cd，在通过z命令切换目录后下次切换只需要输入部分文件名。 下面的命令演示了z plug命令切换到~/.oh-my-zsh/plugins目录。 /usr/bin$ z plug # Even 'z p' might suffice ~/.oh-my-zsh/plugins$  "},{"title":"safe-paste9​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#safe-paste","content":"防止粘贴进终端的多行代码直接执行。 "},{"title":"sudo10​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#sudo","content":"按两次ESC为你当前的命令或前一次命令加上sudo前缀。 "},{"title":"第三方插件​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#第三方插件","content":""},{"title":"zsh-syntax-highlighting11​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#zsh-syntax-highlighting","content":"命令语法高亮。 克隆仓库。 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting  编辑.zshrc文件，修改plugins配置，加上zsh-syntax-highlighting。 plugins=(git theme zsh-syntax-highl3ighting)  "},{"title":"zsh-autosuggestions12​","type":1,"pageTitle":"配置 oh-my-zsh","url":"blog/oh-my-zsh#zsh-autosuggestions","content":"根据历史命令和命令提示插件来给你输入建议。 克隆仓库。 git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions  编辑.zshrc文件，修改plugins配置，加上zsh-autosuggestions。 ohmyzsh/ohmyzsh: 🙃 A delightful community-driven (with 1900+ contributors) framework for managing your zsh configuration. Includes 300+ optional plugins (rails, git, macOS, hub, docker, homebrew, node, php, python, etc), 140+ themes to spice up your morning, and an auto-update tool so that makes it easy to keep up with the latest updates from the community.↩Installing ZSH · ohmyzsh/ohmyzsh Wiki↩Themes · ohmyzsh/ohmyzsh Wiki↩Dark theme for Zsh and 223+ apps — Dracula↩Plugins · ohmyzsh/ohmyzsh Wiki (github.com)↩ohmyzsh/plugins/git at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/themes at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/z at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/safe-paste at master · ohmyzsh/ohmyzsh↩ohmyzsh/plugins/sudo at master · ohmyzsh/ohmyzsh↩zsh-users/zsh-syntax-highlighting: Fish shell like syntax highlighting for Zsh.↩ "},{"title":"Nodebrew：Node.js 安装以及版本切换","type":0,"sectionRef":"#","url":"blog/nodebrew-the-nodejs-version-manager","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#前言","content":"在许多 Linux 包管理器中 Node.js 的版本比较混乱，或者在官方软件仓库中不存在 Node.js 软件包；自己动手安装又比较繁琐；在某些情况下需要切换 Node.js 版本就更麻烦了，这时 Nodebrew 就派上用场了。 Nodebrew 是 Node.js 版本管理器，用 Perl 编写，可以简化你关于 Node.js 安装、卸载、版本管理等过程。 Nodebrew 没有为 Windows 而设计，不支持在 Windows 使用。 "},{"title":"安装​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#安装","content":"Nodebrew 1 的安装过程就是把 Perl 脚本下载到本地，然后将其所在的目录加入PATH环境变量中。 "},{"title":"安装位置​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#安装位置","content":"你可以通过设置环境变量NODEBREW_ROOT来指定 Nodebrew 的安装位置。当然你也可以省略这一步骤，如果没有这个环境变量，Nodebrew 会默认安装在$HOME/.nodebrew。 "},{"title":"通过安装脚本安装​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#通过安装脚本安装","content":"执行下面的命令来下载 Nodebrew 到本地。 curl -L git.io/nodebrew | perl - setup  之后你还需要将其加入到PATH中。你需要将下面的命令（二选一）加入到你的 Shell 配置文件中，例如/etc/profile、~/.profile或~/.bashrc等文件。 # Node.js 安装在用户目录，每个用户独立 export PATH=$HOME/.nodebrew/current/bin:$PATH  # Node.js 安装在统一目录，所有用户共用 # 请修改 NODEBREW_ROOT 为你期望的安装位置 export NODEBREW_ROOT=/somewhere export PATH=$NODEBREW_ROOT/current/bin:$PATH  使用下面的命令重载配置文件，配置文件的路径就是你上一步骤中修改的配置文件的路径。或者你也可以直接重新登录终端来使配置生效。 source /etc/profile  使用下面的命令来初始化 Nodebrew 文件夹。 nodebrew setup_dirs  "},{"title":"通过 Homebrew 来安装​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#通过-homebrew-来安装","content":"Homebrew 2 是一个包管理器，由 Ruby 编写，可以在 macOS 或 Linux 平台上运行。 使用下面的命令来通过brew命令安装 Nodebrew。 brew install nodebrew  之后你还需要将其加入到PATH中。你需要将下面的命令（二选一）加入到你的 Shell 配置文件中，例如/etc/profile、~/.profile或~/.bashrc等文件。 # Node.js 安装在用户目录，每个用户独立 export PATH=$HOME/.nodebrew/current/bin:$PATH  # Node.js 安装在统一目录，所有用户共用 export NODEBREW_ROOT=$HOMEBREW_PREFIX/var/nodebrew export PATH=$NODEBREW_ROOT/current/bin:$PATH  使用下面的命令重载配置文件，配置文件的路径就是你上一步骤中修改的配置文件的路径。或者你也可以直接重新登录终端来使配置生效。 source /etc/profile  使用下面的命令来初始化 Nodebrew 文件夹。 nodebrew setup_dirs  "},{"title":"使用​","type":1,"pageTitle":"Nodebrew：Node.js 安装以及版本切换","url":"blog/nodebrew-the-nodejs-version-manager#使用","content":"使用下面的命令来安装并使用最新稳定版的 Node.js。之后node和npm命令就可以用了。 nodebrew install stable nodebrew use stable  更多使用帮助请参考其 Github 仓库页面 1 和命令行中提供的说明信息。 hokaccha/nodebrew: Node.js version manager↩The Missing Package Manager for macOS (or Linux) — Homebrew↩ "},{"title":"OpenWrt 安装后配置","type":0,"sectionRef":"#","url":"blog/openwrt-post-installation","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"OpenWrt 安装后配置","url":"blog/openwrt-post-installation#前言","content":"OpenWrt 是一个用于嵌入式设备的 Linux 发行版，通常作为路由器的操作系统。 "},{"title":"OpenWrt_CN​","type":1,"pageTitle":"OpenWrt 安装后配置","url":"blog/openwrt-post-installation#openwrt_cn","content":"OpenWrt_CN 1 中收录了一些适合国内用户的发行版。 我主要在虚拟机中使用 OpenWrt，所以选择了 ImmortalWrt 2，它的优点是简洁，出厂附带的软件包非常少，内置软件源和该发行版对齐发行，比较稳定；并且我常用的软件都能在软件源中找到。 "},{"title":"安装​","type":1,"pageTitle":"OpenWrt 安装后配置","url":"blog/openwrt-post-installation#安装","content":"略 "},{"title":"更改局域网 IP 地址​","type":1,"pageTitle":"OpenWrt 安装后配置","url":"blog/openwrt-post-installation#更改局域网-ip-地址","content":"使用下面的命令编辑网络配置文件，修改其中br-lan的部分。 vi /etc/config/network  使用下面的命令重启网络服务。 service restart network  更多帮助可以参考 官方文档 3。 "},{"title":"包管理器 opkg​","type":1,"pageTitle":"OpenWrt 安装后配置","url":"blog/openwrt-post-installation#包管理器-opkg","content":"OpenWrt 使用 opkg 4 作为包管理器。 opkg 软件源配置在/etc/opkg/distfeeds.conf和/etc/opkg/customfeeds.conf中；设置官方软件源的镜像设置前者即可。 下面是 opkg 常用的命令。 opkg update opkg upgrade &lt;&gt; opkg install &lt;&gt; opkg remove &lt;&gt; opkg list &lt;&gt; opkg list-installed opkg list-upgradable opkg info &lt;&gt;  "},{"title":"安装软件示例​","type":1,"pageTitle":"OpenWrt 安装后配置","url":"blog/openwrt-post-installation#安装软件示例","content":"某些时候连接不上官方软件源，需要爱国上网；可以使用 SSH 把本地的代理端口带过去。 ssh root@192.168.233.4 -R 7890:localhost:7890  之后在 SSH 会话中设置代理。 export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890  下面的命令用于安装一些常用软件。 # 更新索引 opkg update # openclash opkg install luci-app-openclash # zerotier opkg install luci-i18n-zerotier-zh-cn # tailscale opkg install tailscale # wireguard # 安装完之后重启才能生效 opkg install luci-proto-wireguard luci-i18n-wireguard-zh-cn  OpenWrt_CN | OpenWrt_简中↩ImmortalWrt Downloads↩[OpenWrt Wiki] IPv4 configuration↩[OpenWrt Wiki] Opkg package manager↩ "},{"title":"Proxmox VE 安装后配置","type":0,"sectionRef":"#","url":"blog/proxmox-ve-post-installation","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#前言","content":"Proxmox VE 基于 Debian，所以和 Debian 的操作还是有很多一样的地方。 "},{"title":"系统软件源镜像​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#系统软件源镜像","content":"执行命令。 apt edit-sources  替换内容，这里使用了 清华大学开源软件镜像站 1。 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free  或者使用 阿里巴巴开源镜像站点 2 deb http://mirrors.aliyun.com/debian/ bullseye main non-free contrib # deb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contrib deb http://mirrors.aliyun.com/debian-security/ bullseye-security main # deb-src http://mirrors.aliyun.com/debian-security/ bullseye-security main deb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib # deb-src http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib deb http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib # deb-src http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib  "},{"title":"Proxmox VE 软件源镜像​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#proxmox-ve-软件源镜像","content":"这里使用了 清华大学开源软件镜像站 3 echo &quot;deb https://mirrors.tuna.tsinghua.edu.cn/proxmox/debian bullseye pve-no-subscription&quot; &gt; /etc/apt/sources.list.d/pve-no-subscription.list  删除 pve-enterprise 源。 # rm /etc/apt/sources.list.d/pve-enterprise.list trash-put /etc/apt/sources.list.d/pve-enterprise.list  "},{"title":"更新​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#更新","content":"apt update apt upgrade  "},{"title":"安装一些小工具​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#安装一些小工具","content":"apt install curl wget tmux bat htop btop exa neofetch trash-cli  "},{"title":"配置别名​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#配置别名","content":"执行命令。 nano .profile  加入内容。 alias bat='batcat' alias ll='exa -lha --modified --created --time-style long-iso --group-directories-first'  "},{"title":"CT 模板镜像​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#ct-模板镜像","content":"直接从 清华大学开源软件镜像站 4 复制下载链接到 Web 控制台下载。 "},{"title":"Windows VirtIO 驱动​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#windows-virtio-驱动","content":"从 Proxmox VE wiki5 中可以找到下载地址。 "},{"title":"挂载点​","type":1,"pageTitle":"Proxmox VE 安装后配置","url":"blog/proxmox-ve-post-installation#挂载点","content":"local：/var/lib/vz/local-lvm：/dev/pve，不能直接访问其中的文件其它硬盘：/mnt/虚拟机配置文件：/etc/pve/qemu-server/ debian | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror↩debian 镜像-debian 下载地址-debian 安装教程 - 阿里巴巴开源镜像站↩proxmox | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror↩Index of /proxmox/images/system/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror↩Windows VirtIO Drivers - Proxmox VE↩ "},{"title":"优雅地重载 Caddyfile","type":0,"sectionRef":"#","url":"blog/reload-caddyfile-gracefully","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"优雅地重载 Caddyfile","url":"blog/reload-caddyfile-gracefully#前言","content":"修改 Caddyfile 之后不需要重新启动 Caddy 服务，Caddy 提供了caddy reload命令可以重新加载配置文件。 记录两个脚本用于格式化 Caddyfile 并重载配置文件。脚本的内容可能需要根据实际情况作某些修改。 "},{"title":"Docker​","type":1,"pageTitle":"优雅地重载 Caddyfile","url":"blog/reload-caddyfile-gracefully#docker","content":"如果你使用docker命令启动 Caddy 容器，可以使用下面的脚本来让 Caddy 重新加载配置文件。该脚本内容参考于 Caddy Docker 镜像文档 1。 #!bin/bash caddy_container_id=$(docker ps | grep caddy | awk '{print $1;}') docker exec -w /etc/caddy $caddy_container_id caddy fmt --overwrite Caddyfile docker exec -w /etc/caddy $caddy_container_id caddy reload  "},{"title":"Docker Compose​","type":1,"pageTitle":"优雅地重载 Caddyfile","url":"blog/reload-caddyfile-gracefully#docker-compose","content":"如果你使用docker-compose命令启动 Caddy 容器，可以使用下面的脚本来让 Caddy 重新加载配置文件。该脚本需要和docker-compose.yml位于同一目录下，并在该目录下执行此脚本。 #!bin/bash docker-compose exec -w /etc/caddy caddy caddy fmt --overwrite Caddyfile docker-compose exec -w /etc/caddy caddy caddy reload  Caddy - Official Image | Docker Hub↩ "},{"title":"restic：轻量、跨平台的增量备份工具","type":0,"sectionRef":"#","url":"blog/restic-backup-tool","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#前言","content":"restic 是一款用 Go 语言实现的备份工具，具有跨平台运行、增量备份和历史版本备份的特性。 restic 可以使用本地位置或网络位置作为存储库。 有很多情况会导致数据丢失，比如 VPS 提供商跑路、机房失火、设备丢失以及人员误操作等，所以数据备份是一项很重要的工作。重要数据必须要备份。 "},{"title":"概念介绍​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#概念介绍","content":"restic 不直接备份文件，它会把文件分为固定大小的块，把这些文件块存入存储库。 restic 的每次备份都称为一个快照，快照里保存了对一个或多个文件块的引用。当多次备份相同文件的时候可以引用相同的文件块，不会占用很多空间；当文件变化不大的时候，也不需要对变化后的文件再完整备份一次，只需要在存储库中加入变化的文件块即可。 所以 restic 可以做到增量备份和多版本备份，并且空间占用也不多。 restic 在 Github1 开源。 "},{"title":"安装 restic​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#安装-restic","content":"restic 是一个单文件的可执行程序，没有其它依赖。你可以手动从其 Github Releases2 页下载可执行程序；你也可以通过包管理器安装 restic；restic 也可以通过 Docker 运行。安装细节可以参考其官方文档中的 Installation3 部分。 在 restic 正确安装后，你可以得到一个restic命令。 ➜ ~ restic restic is a backup program which allows saving multiple revisions of files and directories in an encrypted repository stored on different backends. Usage: restic [command] Available Commands: backup Create a new backup of files and/or directories cache Operate on local cache directories cat Print internal objects to stdout check Check the repository for errors copy Copy snapshots from one repository to another diff Show differences between two snapshots dump Print a backed-up file to stdout find Find a file, a directory or restic IDs forget Remove snapshots from the repository generate Generate manual pages and auto-completion files (bash, fish, zsh) help Help about any command init Initialize a new repository key Manage keys (passwords) list List objects in the repository ls List files in a snapshot migrate Apply migrations mount Mount the repository prune Remove unneeded data from the repository rebuild-index Build a new index recover Recover data from the repository not referenced by snapshots restore Extract the data from a snapshot self-update Update the restic binary snapshots List all snapshots stats Scan the repository and show basic statistics tag Modify tags on snapshots unlock Remove locks other processes created version Print version information Flags: --cacert file file to load root certificates from (default: use system certificates) --cache-dir directory set the cache directory. (default: use system default cache directory) --cleanup-cache auto remove old cache directories -h, --help help for restic --insecure-tls skip TLS certificate verification when connecting to the repo (insecure) --json set output mode to JSON for commands that support it --key-hint key key ID of key to try decrypting first (default: $RESTIC_KEY_HINT) --limit-download int limits downloads to a maximum rate in KiB/s. (default: unlimited) --limit-upload int limits uploads to a maximum rate in KiB/s. (default: unlimited) --no-cache do not use a local cache --no-lock do not lock the repository, this allows some operations on read-only repositories -o, --option key=value set extended option (key=value, can be specified multiple times) --password-command command shell command to obtain the repository password from (default: $RESTIC_PASSWORD_COMMAND) -p, --password-file file file to read the repository password from (default: $RESTIC_PASSWORD_FILE) -q, --quiet do not output comprehensive progress report -r, --repo repository repository to backup to or restore from (default: $RESTIC_REPOSITORY) --repository-file file file to read the repository location from (default: $RESTIC_REPOSITORY_FILE) --tls-client-cert file path to a file containing PEM encoded TLS client certificate and private key -v, --verbose n be verbose (specify multiple times or a level using --verbose=n, max level/times is 3) Use &quot;restic [command] --help&quot; for more information about a command.  "},{"title":"查看命令帮助​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#查看命令帮助","content":"在使用restic及其子命令时，可以通过使用--help参数来获取一些帮助文档。 restic --help restic backup --help restic ls --help restic snapshots --help  在学习和使用 restic 的过程中，你也可以查看其线上文档 4 来获取帮助。 "},{"title":"初始化存储库​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#初始化存储库","content":"resitc 不使用配置文件，它会从环境变量中获取配置项。所以你可以通过export命令把配置项放入当前 Shell 会话的环境变量中。 在使用 restic 进行数据备份之前你需要先确定一个目录作为存储库，并用 restic 初始化这个目录。 这里需要使用两个配置项。 RESTIC_REPOSITORY：存储库位置。可以是本地位置，也可以是网络位置；RESTIC_PASSWORD：存储库密码。 下面是使用本地存储库的例子。 export RESTIC_REPOSITORY=&quot;/Volumes/extra/restic&quot; export RESTIC_PASSWORD=&quot;pass&quot;  需要注意的是，使用export暴露的环境变量只在当前 Shell 会话生效，当你重启 Shell 后这些环境变量就不存在了。 # 初始化存储库 restic init  存储库只需初始化一次，并且 restic 对存储库相关的操作都需要存储库的密码，你要保管好存储库密码。 "},{"title":"备份数据​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#备份数据","content":"使用restic backup命令来备份数据。 restic backup [flags] FILE/DIR [FILE/DIR] ...  # 下面的命令用于把 /data 目录下的文件做备份。每次备份都会生成一个快照。 restic backup ~/data  "},{"title":"查询快照记录​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#查询快照记录","content":"使用restic snapshots命令来查看快照记录，每个快照都有一个 ID。 restic snapshots [flags] [snapshotID ...]  "},{"title":"查看快照内容​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#查看快照内容","content":"使用restic ls命令来查看快照中的内容。 restic ls [flags] snapshotID [dir...]  # 列出快照中的所有目录和文件，会递归列出目录中的内容 restic ls 9e73578b # 可以用`latest`代替最新的快照 ID，列出最近的一次快照中的内容 restic ls latest # 列出快照中`/`目录下的内容，不会递归子文件夹 restic ls 9e73578b / # 列出快照中`/data`目录下的内容，不会递归子文件夹 restic ls 9e73578b /data  "},{"title":"恢复数据​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#恢复数据","content":"使用restic restore命令来从快照恢复数据。 restic restore [flags] snapshotID  # 恢复快照里的内容至 ~/restore-target 目录 restic restore -t ~/restore-target 9e73578b # 恢复快照里的内容至 ~/restore-target 目录，只恢复快照中的 /data/file1 内容 restic restore -t ~/restore-target -i /data/file1 9e73578b  "},{"title":"删除快照​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#删除快照","content":"使用restic forget命令来删除快照。 restic forget [flags] [snapshot ID] [...]  # 删除 ID 为 9e73578b 的快照 restic forget 9e73578b  可以设置淘汰策略来批量删除历史快照。 # 使用淘汰策略批量删除快照 restic forget --keep-last 12 --keep-hourly 24 --keep-daily 7 --keep-weekly 4 --keep-monthly 12  上面的命令定义了一些淘汰策略，不满足此策略的快照会被删除。 永远保留最新的 12 个快照；对于过去 24 小时的快照，每个小时都保留一个最新的快照；对于过去的 7 天，每天都保留一个最新的快照；对于过去的 4 周，每周都保留一个最新的快照；对于过去的 12 个月，每个月都保留一个最新的快照。 删除快照并不会释放存储库的存储空间，因为删除快照只是删除了对文件块的引用，文件块是不会被删除的。 使用restic prune命令来检查所有的文件块并删除没有被任何快照引用的文件块，从而释放存储库的空间。也可以在使用restic forget命令时加上--prune参数，restic 在删除快照之后会紧跟着执行prune命令。 # 扫描所有文件块，删除没有被任何一个快照引用的文件块 restic prune # 在 forget 之后自动执行 prune 命令来释放空间 restic forget --prune --keep-last 12 --keep-hourly 24 --keep-daily 7 --keep-weekly 4 --keep-monthly 12  "},{"title":"多机器共用存储库​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#多机器共用存储库","content":"如果你有多个机器需要备份数据，可以共用一个存储库。 每个快照都有一个 Host 属性，对应着实施备份操作的主机名（Hostname）。默认情况下 restic 直接读取系统中的 Hostname，你也可以通过--host或-H参数手动指定主机名。该参数可用于许多命令，如backup、snapshots或forget等命令中。 快照和快照之间是没有继承关系的，你删除之前的快照不会影响到之后的快照。 在使用restic forget命令使用淘汰策略删除快照时，如果不指定主机名会对分别对所有主机下的快照分别执行淘汰策略；如果指定了主机名则只会对对应主机名的快照执行淘汰策略。 "},{"title":"后记​","type":1,"pageTitle":"restic：轻量、跨平台的增量备份工具","url":"blog/restic-backup-tool#后记","content":"做了备份也不是一劳永逸的。你可能还需要异地多备份，仅仅备份在本地是不方便也是不安全的。 使用对象存储服作为存储库是一个不错的选择，基本上所有的对象存储服务器都兼容 Amazon S3 的 API，都可以作为 restic 的存储库使用。 对象存储的收费项目有下载流量费用、API 调用费用和存储空间费用。上传流量一般是不收费的，同时 API 调用费用和存储空间费用都不高。下载流量费用收费较高，但是在进行备份的时候没有多少下载流量，在紧急情况下恢复文件的时候可以买限时流量包包来降低下载流量的费用。花点钱赎回自己的数据总比数据都消失了要好。 有些对象存储在内网的下载流量也不收费，比如腾讯云的对象存储在腾讯云服务器中使用的话，下载流量就不计费，只收 API 调用的费用，你可以通过腾讯云的服务器来中转对象存储中的内容。关于此内容可以参考「挂载腾讯云 COS 到本地文件夹」5。 在数据备份到对象存储之后，可以定期从对象存储中下载数据到本地的移动硬盘中，达成异地备份。存储库迁移可以使用rclone工具，把对象存储中的所有内容复制到本地即可完成迁移，rclone可以只复制有变化的内容并且删除多余的内容。 要定期做数据恢复测试，检查备份是否正常，是否能按期望恢复数据。备份不测试，等于没备份。 restic/restic: Fast, secure, efficient backup program↩Releases · restic/restic↩Installation — restic 0.13.1 documentation↩Restic Documentation — restic 0.13.1 documentation↩挂载腾讯云 COS 到本地文件夹↩ "},{"title":"重置 MySQL root 密码","type":0,"sectionRef":"#","url":"blog/reset-mysql-root-password","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#前言","content":"注意：如果你的数据库中存有重要数据，请在保证机器离线的情况下进行以下的操作，最稳妥的办法就是拔掉网线！ "},{"title":"方法一：修改配置文件​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#方法一修改配置文件","content":""},{"title":"开启安全模式​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#开启安全模式","content":"修改 MySQL 的配置文件。 vi /etc/my.cnf  在[mysqld]段里加上一行skip-grant-tables，保存并退出。 "},{"title":"重新启动 MySQL​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#重新启动-mysql","content":"service mysqld restart  "},{"title":"修改密码​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#修改密码","content":"mysql -uroot use mysql; update user set Password=password('newpass') where User='root'; flush privileges; exit;  "},{"title":"关闭安全模式​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#关闭安全模式","content":"将第一步在 MySQL 配置文件里加入的skip-grant-tables删掉。 "},{"title":"完成​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#完成","content":"重启 MySQL 之后就可以用新密码登录了。 service mysqld restart  "},{"title":"方法二：通过命令行传递参数​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#方法二通过命令行传递参数","content":""},{"title":"停止 MySQL​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#停止-mysql","content":"service mysqld stop  "},{"title":"以不检查权限的方式启动 MySQL​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#以不检查权限的方式启动-mysql","content":"mysqld --skip-grant-tables &amp;  "},{"title":"修改密码​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#修改密码-1","content":"mysql -uroot  use mysql; update user set Password=password('newpass') where User='root'; flush privileges; exit;  "},{"title":"完成​","type":1,"pageTitle":"重置 MySQL root 密码","url":"blog/reset-mysql-root-password#完成-1","content":"用正常的方式重启 MySQL 之后就可以用新密码登录了。 service mysqld restart  "},{"title":"使用 restic 定时备份文件","type":0,"sectionRef":"#","url":"blog/restic-scheduled-backup","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#前言","content":"restic 不会在后台运行，没有定时备份的功能。如果你有定时备份文件的需求，你可以使用 lobaro/restic-backup-docker 项目，这个项目提供了一个 Docker 镜像，可以很方便地使用 restic 定时进行文件备份。 "},{"title":"项目介绍​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#项目介绍","content":"lobaro/restic-backup-docker1 是一个 Docker 镜像，镜像中包含 restic2 和 cron，可以通过 cron 来定时执行 restic 的备份任务。容器的配置都可以通过设置环境变量来完成。你需要进行如下配置，正确配置后就可以定期执行 restic 的备份任务了。 把要备份的文件和目录挂载到容器中/data目录下；配置好 restic 相关的环境变量；配置 cron 表达式。 "},{"title":"使用示例​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#使用示例","content":"下面演示使用 Docker Compose 配置运行 restic-backup-docker 容器，定时备份文件到腾讯云 COS 中。 restic-backup-docker/docker-compose.yml version: '3'services: restic: image: lobaro/restic-backup-docker hostname: a-computer.local restart: unless-stopped volumes: - ./excludes.txt:/var/excludes.txt:ro - caddy_data:/data/caddy_data:ro - mysql_data:/data/mysql_data:ro environment: TZ: Asia/Shanghai BACKUP_CRON: 0 */6 * * * RESTIC_REPOSITORY: s3:https://cos.ap-shanghai.myqcloud.com/xxxxx-xxxxxxxxxx AWS_ACCESS_KEY_ID: xxxxxxxxxx AWS_SECRET_ACCESS_KEY: xxxxxxxxxx RESTIC_PASSWORD: xxxxxxxxxx RESTIC_JOB_ARGS: --limit-upload 5000 --exclude-file /var/excludes.txt RESTIC_FORGET_ARGS: --prune --keep-last 12 --keep-hourly 24 --keep-daily 7 --keep-weekly 4 --keep-monthly 12volumes: caddy_data: external: true mysql_data: external: true 创建excludes.txt文本文件，作为 restic 的--exclude-file参数内容。restic 在备份过程中会忽略掉匹配这些规则的文件。 注意以#开头的行会被视为注释，如果你想排除某个以#开头的文件或文件夹，请使用\\#来转义。 restic-backup-docker/excludes.txt *log* *cache* tmp \\#recycle  docker-compose.yml文件中的hostname设置容器的主机名，restic 在进行备份的时候会用上主机名，表名此次备份是从哪台主机上创建的。 接下来对docker-compose.yml文件中的environment部分进行说明： TZ，设置容器内的时区，格式为 IANA time zone3；BACKUP_CRON，执行备份任务的 cron 表达式，0 */6 * * *表示每 6 小时执行一次。可以使用一些 在线工具 4 来验证 cron 表达式；RESTIC_REPOSITORY，restic 备份目的地，这里备份到腾讯云的 COS 中，腾讯云 COS 兼容 Amazon S3 协议。具体可以参考 腾讯云 COS 文档 5 和 restic 文档 6。容器在启动时候会检测该仓库是否用 restic 初始化过，如果没有的话则会自动初始化仓库；AWS_ACCESS_KEY_ID，腾讯云 COS 相关配置；AWS_SECRET_ACCESS_KEY，腾讯云 COS 相关配置；RESTIC_PASSWORD，restic 仓库的密码；RESTIC_JOB_ARGS，执行restic backup命令时附加的额外参数，详情可参考 restic 文档 7；RESTIC_FORGET_ARGS，执行restic forget命令时附加的额外参数，详情可参考 restic 文档 8。 接下来对docker-compose.yml文件中的volumes部分进行说明： ./excludes.txt:/var/excludes.txt:ro，挂载excludes.txt；caddy_data:/data/caddy_data:ro，挂载caddy_data卷到容器内/data目录下；mysql_data:/data/mysql_data:ro，挂载mysql_data卷到容器内/data目录下；/root:/data/root:ro，挂载/root目录到容器内/data目录下。 "},{"title":"启动容器​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#启动容器","content":"在restic-backup-docker目录下执行命令。 # 验证 docker-compose.yml 文件的格式是否正确 docker-compose config # 启动容器 docker-compose up -d  "},{"title":"测试配置​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#测试配置","content":"# 手动执行一次备份任务 docker-compose exec restic backup # 查看 restic 的备份历史 docker-compose exec restic restic snapshots # 查看上一次`restic backup`命令的结果 docker-compose exec restic cat /var/log/backup-last.log # 查看最近一次失败的`restic backup`命令的结果 docker-compose exec restic cat /var/log/backup-error-last.log # 查看 cron 日志 docker-compose logs -f docker-compose exec restic cat /var/log/cron.log # 在容器内启动一个 Shell，方面执行其他命令 docker-compose exec restic sh  "},{"title":"更多用法​","type":1,"pageTitle":"使用 restic 定时备份文件","url":"blog/restic-scheduled-backup#更多用法","content":"lobaro/restic-backup-docker 还有很多其他用法，例如： 在容器内自动挂载 NFS 目录；在容器内使用restic mount命令；在备份前后执行自定义脚本。 本文中并没有涵盖所有的用法说明，关于更多用法请参考 lobaro/restic-backup-docker9。 lobaro/restic-backup-docker - Docker Image | Docker Hub↩restic：轻量、跨平台的增量备份工具↩Noda Time | Time zones↩Crontab.guru - The cron schedule expression editor↩对象存储 在兼容 S3 的第三方应用中使用 COS 的通用配置 - 最佳实践 - 文档中心 - 腾讯云↩Preparing a new repository — restic 0.13.1 documentation↩Backing up — restic 0.13.1 documentation↩Removing backup snapshots — restic 0.13.1 documentation↩lobaro/restic-backup-docker: A docker container to automate backups with restic↩ "},{"title":"Scoop：Windows 包管理器","type":0,"sectionRef":"#","url":"blog/scoop-the-windows-package-manager","content":"","keywords":""},{"title":"引入 Scoop​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#引入-scoop","content":"包管理器用于管理软件的生命周期：安装软件及其依赖，配置软件环境变量、更新软件和卸载软件。 Scoop1 是 Windows 上的一款包管理器，它是用 PowerShell 编写的，它可以帮助使用者特别是开发人员管理软件环境，快速构建开发环境。常用的开发工具都可以通过 Scoop 安装和管理。 Scoop 的本质是一系列 PowerShell 脚本的集合，所以运行 Scoop 需要 PowerShell 环境。并且它是针对 Windows 系统设计的，不具有跨平台性。 Scoop 对软件的管理功能依赖于提前定义好的针对每个软件包的配置文件，这些文件为 JSON 格式，称为 Manifest，由众多开发者维护，并托管在 Github。一个 Manifest 对应一个软件，其中包含了该软件的下载地址、安装/卸载脚本和其它必要信息。存放 Manifest 的仓库被称为 Bucket，对应一个 Git 仓库。Manifest 和 Bucket 是 Scoop 中的核心概念。 Scoop 对 Manifest 和 Bucket 的管理依赖于 Git。目前 Scoop 的官方 Bucket 托管在 GitHub。 Scoop 安装软件的过程依赖于 7-zip 和其它类型的解包软件如 innounp，Scoop 会将安装包里的文件解压至软件安装目录。.zip、.7z、.msi和大部分的.exe文件都能解包，软件的安装过程都是自动的，并不是传统的可视化界面方式，不需要人工干预，都由 Scoop 自动管理，程序文件放在统一的位置。软件开发者并不需要专门为 Scoop 制作专门的安装包，通用的软件安装程序都可以通过 Scoop 安装。 通过 Scoop 安装的软件大多是「绿色软件」，即不会写入注册表、不会创建桌面快捷方式，软件单独运行，不会有过多的依赖。Scoop 会根据 Manifest 中的信息为软件创建开始菜单中的快捷方式、创建命令链接、配置环境变量，通过 Scoop 安装软件不会污染系统环境。 "},{"title":"安装前准备​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#安装前准备","content":"Scoop 的安装和使用都需要访问到 Github，考虑到国内网络情况的特殊性，请你自备代理软件以确保能正常访问 GitHub。 大部分的命令行应用不会读取系统代理设置，所以有些情况下及时你启动了代理软件命令行应用也不会通过代理软件访问网络，你可能需要手动设置命令行环境的代理。 在 PowerShell 中，你可以执行以下命令来设置代理，请酌情替换其中的地址和端口号。 $Env:http_proxy=&quot;http://127.0.0.1:11223&quot; $Env:https_proxy=&quot;http://127.0.0.1:11223&quot;  该命令只在当前会话生效，当你关闭了 PowerShell 再次打开一个新的会话时则你需要再次执行该命令才能让代理设置生效。 你可以将这些命令写入$PROFILE文件来避免在每次新会话中重复执行命令的工作。PowerShell 在每次会话启动之后都会执行一次$PROFILE配置文件中的命令。 以下命令用于创建并用记事本打开$PROFILE文件。 if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE  在打开的记事本中写入设置代理的命令，保存该文件，并重新打开 PowerShell 即可生效。 $Env:http_proxy=&quot;http://127.0.0.1:11223&quot; $Env:https_proxy=&quot;http://127.0.0.1:11223&quot;  "},{"title":"前提​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#前提","content":"Scoop 依赖以下系统环境才能正常工作。 PowerShell 5+.NET Framework 4.5+ 对于现代的 Windows 10 系统来说，这些条件已自动满足，对于较为古老的 Windows 7 系统用户来说，你可能需要手动升级 PowerShell 到PowerShell 5，并安装.NET Framework 4.5。 Scoop 依赖 Git 和 7-zip 来完成基本的工作，但是你不需要手动安装这些软件。你只需要确保良好的网络环境。 "},{"title":"设置安装位置​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#设置安装位置","content":"// TODO 补充此章节，还有各个步骤的截图 "},{"title":"安装 Scoop​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#安装-scoop","content":"接下来的命令都在 PowerShell 中执行。 下面的命令用于允许执行外部 PowerShell 脚本。你可能看到提示信息，请输入「Y」并按下回车键。 Set-ExecutionPolicy RemoteSigned -scope CurrentUser  下面的命令用于安装 Scoop。 Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')  在安装完成之后你将得到一个新的可执行命令scoop。下面的命令用于安装 7-zip 和 Git。 scoop install 7zip git  等待命令执行完毕之后你就可以在命令行中使用7z和git命令，Scoop 已经为你配置好了环境变量和命令链接。 在安装好 Git 之后你需要为 Git 设置代理，以下命令用来为 Git 设置代理，请酌情替换其中的地址和端口号。 git config --global http.proxy http://127.0.0.1:11223 git config --global https.proxy http://127.0.0.1:11223  对 Git 的设置是永久性的，以下命令用于取消为 Git 设置代理，使用时请去掉注释前缀。 # git config --global --unset http.proxy # git config --global --unset https.proxy  下面的命令用于添加extras软件仓库。 scoop bucket add extras  "},{"title":"Scoop 的目录结构​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#scoop-的目录结构","content":"// TODO 补充此章节，还有各个步骤的截图 "},{"title":"Scoop 软件管理命令​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#scoop-软件管理命令","content":"命令\t示例\t备注scoop search &lt;关键词&gt;\tscoop search firefox\t搜索和关键词相关的软件包 scoop info &lt;包名&gt;\tscoop info firefox\t查看软件包信息 scoop install &lt;包名&gt;\tscoop install nodejs-lts adopt8-hotspot\t安装指定软件，可以一次性安装多个软件，用空格分割这些软件名 scoop uninstall &lt;包名&gt;\tscoop uninstall nodejs-lts\t卸载指定软件 scoop reinstall &lt;包名&gt;\tscoop reinstall nodejs-lts\t重新安装指定软件 scoop reset &lt;包名&gt;\tscoop reset python\t重新执行软件安装后脚本，以解决冲突 scoop list 列出所有已安装软件 scoop list &lt;关键词&gt;\tscoop list node\t列出和关键词相关的已安装软件 scoop status 查询更新信息 scoop update &lt;包名&gt;\tscoop update vscode\t更新指定的软件 scoop update 更新 Scoop 和所有仓库信息 "},{"title":"Scoop 仓库管理命令​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#scoop-仓库管理命令","content":"仓库相关命令均以scoop bucket开始。 命令\t示例\t备注scoop bucket known 列出知名软件仓库 scoop bucket add &lt;知名仓库名&gt;\tscoop bucket add jetbrains\t添加知名软件仓库，不用输入仓库地址 scoop bucket add &lt;别名&gt; &lt;仓库地址&gt;\tscoop bucket add bobo2334 https://github.com/bobo2334/scoop-bucket.git\t添加第三方软件仓库 scoop bucket rm &lt;别名&gt;\tscoop bucket rm nerd-fonts\t移除软件仓库 scoop bucket list 列出所有已添加的软件仓库 "},{"title":"卸载 Scoop​","type":1,"pageTitle":"Scoop：Windows 包管理器","url":"blog/scoop-the-windows-package-manager#卸载-scoop","content":"如果 Scoop 不能让你满意的话，你可以用下面的命令来移除 Scoop。这将会删除所有你用 Scoop 安装的软件，最后删除 Scoop 它自身。 scoop uninstall scoop  Scoop↩ "},{"title":"Gitea：轻量级自建 Git 服务","type":0,"sectionRef":"#","url":"blog/self-hosted-git-service-gitea","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#前言","content":"最近发生了一些事件：Github 封禁某些国家用户的账号；Gitee 公开仓库变私有，公开需通过审核。 这些大平台提供的服务看起来也不是那么可靠。这时候你可以自建一个 Git 服务平台自用，自己保管数据。 "},{"title":"为什么选择 Gitea​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#为什么选择-gitea","content":"下面列出了 Gitea1 的优点。 Gitea 占用资源低，300MB 内存足以满足个人使用，其在官方网页上的介绍说明在树莓派上足以运行；用 Go 语言实现，可以部署在很多平台上，并且不会有依赖问题；安装方便，使用 Docker 可以直接部署；外部依赖少，可以使用 SQLite 作为数据库，个人使用完全足够，数据迁移也方便；开源；功能丰富，仓库有 Issues、Pull Requests、Projects、Releases、Wiki 以及 Activity 等板块；并且可以设置 Webhooks、Push Mirrow、镜像仓库等。用户界面模仿 Github，学习成本低，使用体验良好；有完整的用户和组织系统。 Gitea 没有集成 CI/CD 工具，因为 CI/CD 工具比较耗资源。 "},{"title":"安装​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#安装","content":"可以使用 Docker Compose 快速部署 Gitea 实例。 以下是docker-compose.yml的内容示例。 version: &quot;3&quot; services: server: image: gitea/gitea restart: unless-stopped ports: - 127.0.0.1:13000:3000 - 127.0.0.1:2222:22 volumes: - data:/data volumes: data:  以下是对docker-compose.yml文件的简短说明。 ports：容器的 3000 端口为 Web UI 的监听端口；容器的 22 端口为 SSH 端口，用于 SSH 方式访问 Git 仓库；volumes：Gitea 的数据都保存在容器内的/data目录中，包括所有 Git 仓库的文件都保存在此目录中。 "},{"title":"反向代理以及 HTTPS 配置​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#反向代理以及-https-配置","content":"可以使用 Web 服务器对 Gitea 的 Web UI 进行反向代理，通过域名暴露在公网中。 下面是使用 Caddy 进行反向代理的示例，这是 Caddyfile 的部分内容。Caddy 会自动申请域名证书并配置 HTTPS。 *.iuok.me { tls { dns cloudflare xxxxxx } @gitea host gitea.iuok.me handle @gitea { reverse_proxy localhost:13000 import hsts } handle { abort } }  "},{"title":"初次设置​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#初次设置","content":"在浏览器中输入你的 Gitea 域名进行访问，初次访问的时候会进入设置页面。 可以选择是否开启 SSH，如果把 SSH 端口设置为 0 则意味关闭 SSH 访问。 完成安装后如果再需要更改某些设置需要手动在配置文件中更改，配置文件位于容器中的/data/gitea/conf/app.ini。配置文件的配置细节可以参考其官方文档 2。 "},{"title":"使用​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#使用","content":"如果你只想自己一个人用的话需要设置不允许新用户注册，并且把自己的账号和仓库都设置为私有的；公共的仓库可以在主页被访客浏览。 使用体验和 Github 差不多。 "},{"title":"双因素认证​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#双因素认证","content":"为了提高账户的安全性，可以设置账户的双因素认证。 在「Settings」-&gt;「Security」-&gt;「Two-Factor Authentication」中可以开启双因素认证。使用支持 TOTP 的令牌软件都可以生成登录令牌；如 Authy、Google Authenticator 或 Bitwarden 等软件。 开启之后在登录时除了输入密码之外，还会要求你输入一个动态验证码，该验证码随时间变化。 开了双因素认证之后在使用 HTTPS 方式访问 Git 仓库时就不能用原来的密码了，需要你单独生成一个 Access Token 来访问仓库。Access Token 需要在「Settings」-&gt;「Applications」-&gt;「Manage Access Tokens 」中创建。 "},{"title":"镜像仓库​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#镜像仓库","content":"在 Gitea 中可以创建镜像仓库，用于定时从源仓库中同步内容。 在创建仓库的时候选择迁移仓库，在迁移选项中勾选「This repository will be a mirror」即可创建一个镜像仓库。 只有创建仓库的时候可以选择创建镜像仓库，不可以把现有仓库改为镜像仓库；镜像仓库之后可以改为普通仓库。 "},{"title":"数据备份​","type":1,"pageTitle":"Gitea：轻量级自建 Git 服务","url":"blog/self-hosted-git-service-gitea#数据备份","content":"自建的服务要做好数据备份工作，因为 VPS 提供商也不一定可靠，也有可能发生意外事故，导致数据丢失。 Gitea 的数据文件结构比较简单，直接备份 Docker Volume 对应的目录即可。 默认情况下，Docker Volume 位于/var/lib/docker/volume下，备份docker-compose.yml中对应的数据卷中的内容即可。 可以使用 restic 备份到其它服务商提供的对象存储中；注意要异地备份，备份在本机无意义。 恢复数据的时候手动创建 Volume，把备份内容还原，然后再启动 Gitea 容器即可。 Gitea↩Documentation - Docs↩ "},{"title":"Scoop：用 aria2 加速下载","type":0,"sectionRef":"#","url":"blog/scoop-with-aria2-for-multi-thread-download","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Scoop：用 aria2 加速下载","url":"blog/scoop-with-aria2-for-multi-thread-download#前言","content":"aria21 是一款流行的多线程下载器。Scoop 在默认情况下使用单线程下载，你可以通过安装 aria2 来让 Scoop 支持多线程下载。 "},{"title":"安装 aria2​","type":1,"pageTitle":"Scoop：用 aria2 加速下载","url":"blog/scoop-with-aria2-for-multi-thread-download#安装-aria2","content":"在 PowerShell 中执行用下面的命令来安装 aria2。 scoop install aria2  不需要多余配置，Scoop 在执行下载动作前会检测你是否安装了 aria2，如果检测到你已经安装了 aria2 则自动调用其进行多线程下载。 "},{"title":"配置 aria2​","type":1,"pageTitle":"Scoop：用 aria2 加速下载","url":"blog/scoop-with-aria2-for-multi-thread-download#配置-aria2","content":"在 Scoop 中有一些关于 aria2 的配置 2，在某些情况下你可能想了解。 配置项\t默认值\t说明aria2-enabled\ttrue\t是否启用 aria2 aria2-warning-enabled\ttrue\t是否在每次下载之前输出提示信息，内容为 aria2 下载的说明 aria2-retry-wait\t2\taria2 重试等待时间，单位为秒 aria2-split\t5\t下载时使用的链接数 aria2-max-connection-per-server\t5\t每个服务器的最大连接数 aria2-min-split-size\t5M\t最小分段大小，如果将要下载的文件大小小于该参数的 2 倍，则下载的过程中不会对文件进行分段 aria2-options 其它需要传递给 aria2 的参数，可以参考 aria2 的文档 3 你可以通过scoop config命令来更改这些配置项的值。 例如你想停止使用 aria2 进行多线程下载，你可以通过执行下面的命令实现。 scoop config aria2-enabled false  aria2/aria2: aria2 is a lightweight multi-protocol &amp; multi-source, cross platform download utility operated in command-line. It supports HTTP/HTTPS, FTP, SFTP, BitTorrent and Metalink.↩ScoopInstaller/Scoop: A command-line installer for Windows.↩aria2c(1) — aria2 1.36.0 documentation↩ "},{"title":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","type":0,"sectionRef":"#","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#前言","content":"在用 IntelliJ IDEA 运行 Java Web 项目时，在 Tomcat 的日志输出区域会出现乱码，效果如下图所示。 在网络上查了一些资料 1，记录下解决办法。  "},{"title":"原因分析​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#原因分析","content":"可能是因为 IDEA 控制台中所采用的字符编码与 Tomcat 输出所采用的字符编码不一致，导致了出现乱码。 IDEA 控制台输出采用的是 GBK 编码，Tomcat 输出采用的是 UTF-8 编码。 "},{"title":"解决办法​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#解决办法","content":""},{"title":"法一：修改 IDEA 控制台输出编码为 UTF-8​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#法一修改-idea-控制台输出编码为-utf-8","content":"在 IDEA 的上方工具栏中，依次选择Help-&gt;Edit Custome VM Options...。  在vmoptions中添加如下一行参数，之后重启 IDEA。 -Dfile.encoding=UTF-8  该文件实际位于C:\\Users\\&lt;用户名&gt;\\AppData\\Roaming\\JetBrains\\IntelliJIdea2020.3\\idea64.exe.vmoptions，所以直接修改此文件应该也可行。  "},{"title":"法二：修改 Tomcat 输出编码为 GBK​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#法二修改-tomcat-输出编码为-gbk","content":"在 Tomcat 安装位置下的 conf 文件中存在logging.properties配置文件。 修改其中的配置，将java.util.logging.ConsoleHandler.encoding的属性由UTF-8改为GBK。 保存之后重启 Tomcat 即可。  "},{"title":"结果​","type":1,"pageTitle":"解决 IntelliJ IDEA 中 Tomcat 日志输出乱码的问题","url":"blog/solve-the-problem-of-tomcat-log-output-messy-code-in-intellij-idea#结果","content":"两种方法均可以解决问题。  idea tomcat 乱码问题的解决及相关设置 - 行而思 - 博客园↩ "},{"title":"ztncui：自建 Zerotier 网页控制器","type":0,"sectionRef":"#","url":"blog/self-hosted-zerotier-controller","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"ztncui：自建 Zerotier 网页控制器","url":"blog/self-hosted-zerotier-controller#前言","content":"自建 Zerotier 行星节点和网页控制器可以解除 50 个设备数量限制，但是客户端还是使用的国外根服务器，并不能改善网络稳定性。 "},{"title":"运行项目​","type":1,"pageTitle":"ztncui：自建 Zerotier 网页控制器","url":"blog/self-hosted-zerotier-controller#运行项目","content":"使用docker-compose可以快速运行项目。docker-compose.yml的内容如下。 version: '3' services: ztncui: image: keynetworks/ztncui restart: unless-stopped ports: - '3000:3000' environment: MYADDR: 172.38.38.38 HTTP_ALL_INTERFACES: &quot;yes&quot; ZTNCUI_PASSWD: PASS TZ: Asia/Shanghai volumes: - ztncui:/opt/key-networks/ztncui/etc/ - zerotier-one:/var/lib/zerotier-one/ volumes: ztncui: null zerotier-one: null  其中一些环境变量需要设置。 MYADDR：机器的公网 IP 地址HTTP_ALL_INTERFACES：监听所有网络接口ZTNCUI_PASSWD：设置admin用户的密码。 ztncui和zerotier-one两个 Volume 持久化配置信息，防止重新创建容器后丢失配置。 在当前目录下用docker-compose up -d启动容器。 防火墙需要放行3000端口。 "},{"title":"网络配置​","type":1,"pageTitle":"ztncui：自建 Zerotier 网页控制器","url":"blog/self-hosted-zerotier-controller#网络配置","content":"访问IP:3000可以进入网页管理 UI，也可以用反响代理服务器来转发此端口的流量，并用域名和 HTTPS 访问。用户名是admin，密码是你之前配置的环境变量ZTNCUI_PASSWD的值。 控制面板的使用方法和操作逻辑和官方控制面板差不多。 在底部的导航栏中点击「Networks」，再点击Add network创建一个网络。给网络起一个名字之后你就能在「Networks」中看见你刚刚创建的网络了。  点击该网络名就能进入该网络设置的设置页面。  点击「Easy setup」按钮为网络设置网段。在该页面中点击「Generate network address」按钮可以随机生成网段，点击「Submit」按钮保存信息。  点击「Private」按钮设置私有网络/公开网络。  点击「Routes」按钮设置静态路由。  "},{"title":"客户端​","type":1,"pageTitle":"ztncui：自建 Zerotier 网页控制器","url":"blog/self-hosted-zerotier-controller#客户端","content":"使用各个平台的原生客户端直接可以连接到自建网络。Network ID 填自己的就行了。 客户端在加入私有网络的时候需要在网络管理页面手动批准认证；勾选对应的「Authorized」列选框即可。  "},{"title":"参考资料​","type":1,"pageTitle":"ztncui：自建 Zerotier 网页控制器","url":"blog/self-hosted-zerotier-controller#参考资料","content":"ZeroTier Planet 行星服务器，一键私有部署，可突破 50 台设备限制 - 小众软件Jonnyan404/zerotier-planet: 一分钟自建 zerotier-planetkey-networks/ztncui: ZeroTier network controller UIkey-networks/ztncui-containerized: A Docker image that contains ZeroTier One and ztncui to set up a standalone ZeroTier network controller with a web user interface in a container. "},{"title":"SSH 密钥登录","type":0,"sectionRef":"#","url":"blog/ssh-certificate-authentication","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#前言","content":"SSH 默认采用密码登录，这种方法有很多缺点，简单的密码不安全，复杂的密码不容易记忆，每次手动输入也很麻烦。密钥登录是比密码登录更好的解决方案。1 "},{"title":"生成秘钥​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#生成秘钥","content":"可以用 OpenSSH 中的ssh-keygen命令行工具来生成秘钥。-t参数指定了加密方式，通常为rsa或dsa。 ssh-keygen -t rsa  生成的密钥文件默认就会是~/.ssh/id_rsa（私钥）和~/.ssh/id_rsa.pub（公钥）。 也可以用 PuTTY 中提供的 PuTTY Key Generator（puttygen.exe）2 来用可视化用户界面来生成秘钥文件。  "},{"title":"把公钥放在服务器上​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#把公钥放在服务器上","content":"用户公钥保存在~/.ssh/authorized_keys文件中，如果该文件不存在，你可以手动创建一个。 然后将公钥的文本内容放入其中，每行一个。 "},{"title":"关闭密码登录​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#关闭密码登录","content":"编辑/etc/ssh/sshd_config文件，找到对应的配置项并修改。 # 不允许密码直接登录 PasswordAuthentication no # 不允许空密码登录 PermitEmptyPasswords no # 不允许交互式密码登录 ChallengeResponseAuthentication no # 不允许 root 用户使用密码登录 PermitRootLogin prohibit-password # 使用秘钥登录 PubkeyAuthentication yes  重启sshd，让配置生效。 sudo systemctl restart sshd  "},{"title":"测试配置是否生效​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#测试配置是否生效","content":"使用ssh命令连接远程服务器，使用-i参数传递私钥文件。 ssh -i .\\centos7\\.vagrant\\machines\\default\\virtualbox\\private_key vagrant@192.168.33.12  "},{"title":"参考资料​","type":1,"pageTitle":"SSH 密钥登录","url":"blog/ssh-certificate-authentication#参考资料","content":"How To Configure SSH Key-Based Authentication on a Linux Server | DigitalOcean14.3. Using OpenSSH Certificate Authentication Red Hat Enterprise Linux 6 | Red Hat Customer Portal SSH 密钥登录 - SSH 教程 - 网道↩Download PuTTY: latest release (0.76)↩ "},{"title":"为 SSH 登录启用多重要素验证","type":0,"sectionRef":"#","url":"blog/ssh-2fa","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"为 SSH 登录启用多重要素验证","url":"blog/ssh-2fa#前言","content":"通过 libpam-google-authenticator 为 SSH 启用多重要素验证，在使用密码或者秘钥登录之后还要输入一个基于时间变化的密码才能登录，增加服务器安全性。 本文中使用 Debian 11 系统作为例子。 "},{"title":"安装 libpam-google-authenticator​","type":1,"pageTitle":"为 SSH 登录启用多重要素验证","url":"blog/ssh-2fa#安装-libpam-google-authenticator","content":"安装 libpam-google-authenticator。 apt update apt install libpam-google-authenticator -y  运行设置向导。 google-authenticator  记住 secret key，导入到支持 TOTP 的软件里生成密码。 Do you want authentication tokens to be time-based (y/n) y Your new secret key is: ****************  在下一步中验证密码，密码是从密码生成器中得到的。 Enter code from app (-1 to skip): *******  下面有备用密码，记录下来，当你的密码生成器丢失的时候有用，每个密码可以用一次。 Your emergency scratch codes are: ******** ******** ******** ******** ********  更新配置文件。 Do you want me to update your &quot;/root/.google_authenticator&quot; file? (y/n) y  设置最大时间误差 30 秒，默认可以使用前一个、现在的和后一个验证码通过认证。 By default, a new token is generated every 30 seconds by the mobile app. In order to compensate for possible time-skew between the client and the server, we allow an extra token before and after the current time. This allows for a time skew of up to 30 seconds between authentication server and client. If you experience problems with poor time synchronization, you can increase the window from its default size of 3 permitted codes (one previous code, the current code, the next code) to 17 permitted codes (the 8 previous codes, the current code, and the 8 next codes). This will permit for a time skew of up to 4 minutes between client and server. Do you want to do so? (y/n) y  设置每 30 秒最多重试 3 次。 If the computer that you are logging into isn't hardened against brute-force login attempts, you can enable rate-limiting for the authentication module. By default, this limits attackers to no more than 3 login attempts every 30s. Do you want to enable rate-limiting? (y/n) y  "},{"title":"配置 SSH 服务器​","type":1,"pageTitle":"为 SSH 登录启用多重要素验证","url":"blog/ssh-2fa#配置-ssh-服务器","content":"修改/etc/pam.d/sshd文件。 nano /etc/pam.d/sshd  注释掉@include common-auth，并加入新行。 # Standard Un*x authentication. # @include common-auth auth required pam_google_authenticator.so  修改/etc/ssh/sshd_config文件。 nano /etc/ssh/sshd_config  修改以下几项。其中AuthenticationMethods指定了先使用秘钥方式登录，再要求验证额外密码。 ChallengeResponseAuthentication yes PasswordAuthentication no AuthenticationMethods publickey,keyboard-interactive  重启 ssh 服务器。 systemctl restart sshd  "},{"title":"SSH 服务器启动错误排查​","type":1,"pageTitle":"为 SSH 登录启用多重要素验证","url":"blog/ssh-2fa#ssh-服务器启动错误排查","content":"首先停止 sshd 服务。 systemctl stop sshd  手动启动 sshd，指定-d参数，该参数会让 sshd 打印出更多错误信息。 /usr/bin/sshd -d  根据打印出的信息排查错误。错误修复之后再通过服务启动 sshd。 systemctl start sshd  "},{"title":"参考资料​","type":1,"pageTitle":"为 SSH 登录启用多重要素验证","url":"blog/ssh-2fa#参考资料","content":"多重要素验证 - 维基百科，自由的百科全书How to Setup Two-Factor Authentication (2FA) for SSH on Debian 9 Using Google Authenticator - Vultr.com[SOLVED] SSH Service Failed to Start / Networking, Server, and Protection / Arch Linux Forums "},{"title":"通过代理连接 SSH 服务器","type":0,"sectionRef":"#","url":"blog/ssh-under-proxy","content":"","keywords":""},{"title":"正文​","type":1,"pageTitle":"通过代理连接 SSH 服务器","url":"blog/ssh-under-proxy#正文","content":"下面的命令用于通过 SOCKS5 代理连接到 SSH 服务器。其中127.0.0.1:7890是本地 SOCKS5 代理的地址和端口号。 ssh -oProxyCommand=&quot;nc -x 127.0.0.1:7890 %h %p&quot; root@198.198.198.198  "},{"title":"参考资料​","type":1,"pageTitle":"通过代理连接 SSH 服务器","url":"blog/ssh-under-proxy#参考资料","content":"透过代理连接 SSH [Lainme's Blog] "},{"title":"SSH 端口转发","type":0,"sectionRef":"#","url":"blog/ssh-port-forwarding","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"SSH 端口转发","url":"blog/ssh-port-forwarding#前言","content":"SSH 除了能连接远程服务器外，还可以做端口转发的工作，并且利用安全隧道来保障通信安全。 "},{"title":"动态转发​","type":1,"pageTitle":"SSH 端口转发","url":"blog/ssh-port-forwarding#动态转发","content":"动态转发指的是 SSH 在本机暴露一个 SOCKS5 端口，通过此端口进行的所有通信都转发到远程服务器，通过远程服务器访问外网。通过这种方式可以实现一个简易代理。 ssh -D local-port tunnel-host -N  -D，动态转发；-N，不打开 Shell，只进行端口转发。 下面这条命令的用途是通过本机2121端口的流量都会被转发到tunnel-host，然后通过tunnel-host再发送该流量。 ssh -D 2121 tunnel-host -N  可以写在 ssh_config（~/.ssh/config）中。 DynamicForward &lt;tunnel-host&gt;:&lt;local-port&gt;  "},{"title":"本地转发​","type":1,"pageTitle":"SSH 端口转发","url":"blog/ssh-port-forwarding#本地转发","content":"本地转发指的是 SSH 在本机暴露一个端口，通过此端口的请求都会转发到远程服务器，然后远程服务器会将请求转发到目标服务器的目标端口。 ssh -L local-port:target-host:target-port tunnel-host  下面这条命令的用途是，当访问本地2121端口时，流量会被转发到tunnel-host，再由tunnel-host把流量发送到www.example.com:80。 ssh -L 2121:www.example.com:80 tunnel-host -N  可以写在 ssh_config（~/.ssh/config）中。 Host test.example.com LocalForward client-IP:client-port server-IP:server-port  "},{"title":"远程转发​","type":1,"pageTitle":"SSH 端口转发","url":"blog/ssh-port-forwarding#远程转发","content":"远程转发指的是在远程主机监听某个端口，通过该端口的流量都转发到本机，再通过本机发送该流量。 ssh -R remote-port:target-host:target-port -N remotehost  下面这条命令的作用是通过远程主机8080端口的流量都转发到本地主机的80端口。 ssh -R 8080:localhost:80 -N my.public.server  可以写在 ssh_config（~/.ssh/config）中。 Host remote-forward HostName test.example.com RemoteForward remote-port target-host:target-port  "},{"title":"参考资料​","type":1,"pageTitle":"SSH 端口转发","url":"blog/ssh-port-forwarding#参考资料","content":"SSH 端口转发 - SSH 教程 - 网道 "},{"title":"Tailscale 异地组网","type":0,"sectionRef":"#","url":"blog/tailscale","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Tailscale 异地组网","url":"blog/tailscale#前言","content":"Zerotier 使用体验并不好，配置复杂，P2P 打洞耗时长，成功率低。最近体验了一下 Tailscale，感觉不错。 Tailscale 客户端配置简单；子网路由更简单，不需要配置客户端防火墙；打洞速度快，成功率高。 但 Tailscale 也有缺点： 免费版限制 20 台设备，1 个子网路由；不能自定义虚拟网络网段。 "},{"title":"官网注册​","type":1,"pageTitle":"Tailscale 异地组网","url":"blog/tailscale#官网注册","content":"在 Tailscale 1 官方网站可以注册并登录。登录之后可以看到网页控制台。 "},{"title":"接入客户端​","type":1,"pageTitle":"Tailscale 异地组网","url":"blog/tailscale#接入客户端","content":"在 Tailscale 下载页面 2 可以下载各个平台的客户端。支持 macOS、iOS、Windows、Linux 和 Android。 使用客户端登录同一账号之后即可加入网络。 或者是在网页控制台中的设置里，找到「Keys」-&gt;「Auth keys」，创建一个有时限的秘钥，客户端可以凭此秘钥登录，而不用使用账号登录。 此方法适用于命令行界面，用法如下。 sudo tailscale up --authkey tskey-abcdef1432341818  "},{"title":"子网路由​","type":1,"pageTitle":"Tailscale 异地组网","url":"blog/tailscale#子网路由","content":"客户端可以将自己所在局域网暴露给其他客户端。 sudo tailscale up --advertise-routes=192.168.123.0/24  之后在网页控制台中开启该客户端建议的子网路由即可。其它客户端就能直接访问该局域网的资源，就跟物理连接在该局域网一样。 "},{"title":"开源替代品​","type":1,"pageTitle":"Tailscale 异地组网","url":"blog/tailscale#开源替代品","content":"headscale 3 是 Tailscale 服务端的开源实现。 headscale 兼容 Tailscale 的客户端，除了 iOS 设备之外，你可以使用 Tailscale 的客户端连接上 headscale 控制器。 "},{"title":"参考资料​","type":1,"pageTitle":"Tailscale 异地组网","url":"blog/tailscale#参考资料","content":"Docs · TailscaleTailscale 基础教程：Headscale 的部署方法和使用教程 – 云原生实验室 - Kubernetes|Docker|Istio|Envoy|Hugo|Golang|云原生 Tailscale · Best VPN Service for Secure Networks↩Download · Tailscale↩juanfont/headscale: An open source, self-hosted implementation of the Tailscale control server↩ "},{"title":"tmux 终端复用","type":0,"sectionRef":"#","url":"blog/tmux","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#前言","content":"tmux 是一个终端复用器，能让你在一个终端里分屏出多个窗格，还能保存你的终端会话。尤其是在 SSH 连接到远程服务器工作的时候，网络情况不好的情况下 SSH 连接可能会意外断开，此时在该 SSH 会话中运行的命令也会被中断；在使用了 tmux 之后，只要 tmux 进程不结束，任务就不会中断，待恢复 SSH 连接后，tmux 可以让你快速恢复到之前的工作现场。 "},{"title":"快捷键说明​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#快捷键说明","content":"tmux 的快捷键操作都需要先按下前缀快捷键，默认的前缀快捷键是Ctrl+b，需要先按下此快捷键后松开，然后再按下后续指令。所有的快捷键操作均需要在 tmux 会话中按下才能生效。 如分离会话的快捷键是Ctrl+bd，你需要先按下Ctrl+b，松开键盘，再按下d。其它快捷键同理。 在会话中，使用Ctrl+b?快捷键来展示所有的快捷键，按q退出帮助页面。 "},{"title":"多会话​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#多会话","content":""},{"title":"启动​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#启动","content":"tmux，新建一个会话，默认名称是以数字序号，从 0 开始tmux new -s session_name，新建一个会话并命名为「session_name」 "},{"title":"退出​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#退出","content":"会话中不存在进程时会话会自动关闭，使用exit命令或者Ctrl+d关闭当前 shelltmux kill-session -t &lt;会话编号/会话名称&gt;，杀死会话 "},{"title":"分离​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#分离","content":"可以手动分离会话，在 SSH 断开的时候也会分离会话，只要会话中有进程该会话就不会自动关闭。 在会话中，使用Ctrl+bd分离当前会话 "},{"title":"返回​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#返回","content":"tmux ls，列出所有会话Ctrl+bs，列出所有会话tmux attach -t &lt;会话编号/会话名称&gt;，返回会话tmux switch -t &lt;会话编号/会话名称&gt;，切换会话 "},{"title":"重命名​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#重命名","content":"tmux rename-session -t &lt;会话编号/会话名称&gt; &lt;新的会话名称&gt;Ctrl+b$，重命名当前会话 "},{"title":"多窗格（pane）​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#多窗格pane","content":""},{"title":"划分窗格​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#划分窗格","content":"tmux split-window，向下划分窗格（垂直）Ctrl+b% ，向下划分窗格tmux split-window -h，向右划分窗格（水平）Ctrl+b&quot; ，向右划分窗格 "},{"title":"切换光标​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#切换光标","content":"tmux select-pane -U ，光标切换到上一窗格Ctrl+b↑tmux select-pane -D ，光标切换到下一窗格Ctrl+b↓tmux select-pane -L ，光标切换到左一窗格Ctrl+b←tmux select-pane -R ，光标切换到右一窗格Ctrl+b→ "},{"title":"移动窗格​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#移动窗格","content":"Ctrl+bq ，显示窗格编号tmux swap-pane -U，把当前窗格与上一个窗格交换位置Ctrl+b{ ，把当前窗格与上一个窗格交换位置tmux swap-pane -D，把当前窗格与下一个窗格交换位置Ctrl+b} ，把当前窗格与下一个窗格交换位置 "},{"title":"其它操作​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#其它操作","content":"Ctrl+bz ，当前窗格全屏显示，再按一次还原。在全屏模式下Ctrl+bx ，关闭当前窗格Ctrl+b! ，把当前窗格拆分为一个独立窗口Ctrl+b[ ，开启复制模式，可以用用方向键或滚轮上下滚动，q退出。 "},{"title":"多窗口（window）​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#多窗口window","content":"一个会话中可以存在多个窗口，每个窗口中可以有多个窗格。 tmux new-window，新建窗口tmux new-window -n &lt;窗口名称&gt;，新建窗口Ctrl+bc ，新建窗口tmux select-window -t &lt;窗口名称&gt;，切换到指定名称的窗口Ctrl+bp ，切换到上一个窗口Ctrl+bn ，缺环到下一个窗口Ctrl+bnumber ，切换到指定序号的窗口 "},{"title":"参考资料​","type":1,"pageTitle":"tmux 终端复用","url":"blog/tmux#参考资料","content":"Tmux 使用教程 - 阮一峰的网络日志Gentle Guide to Get Started With tmux | Pragmatic Pineapple 🍍 "},{"title":"iterm2 对 tmux 的特殊支持","type":0,"sectionRef":"#","url":"blog/tmux-integration-in-iterm2","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"iterm2 对 tmux 的特殊支持","url":"blog/tmux-integration-in-iterm2#前言","content":"tmux1 是一款非常好用的终端复用工具，它可以帮助你快速地保存和恢复工作现场。 使用 tmux 的时候有许多快捷键需要记忆，并且窗格切换和窗格的上下滚动并不方便；tmux 的快捷键还可能和其它软件的快捷键有冲突。 iterm22 是 macOS 中的一个终端模拟器软件，它对 tmux 有独家支持，可以在控制模式下运行 tmux。在这个模式中，tmux 会话表现和本地终端一样，可以使用 iterm2 的快捷键来进行多窗口和多窗格分隔，用鼠标切换窗口和窗格，并且用鼠标滚轮上下滚动窗格也能正常工作，不需要进 tmux 的复制模式来滚动窗格。 "},{"title":"使用​","type":1,"pageTitle":"iterm2 对 tmux 的特殊支持","url":"blog/tmux-integration-in-iterm2#使用","content":"不论是在本地使用 tmux，还是通过 ssh 使用远端的 tmux，iterm2 都支持使用 tmux 的控制模式。 tmux 的控制模式通过附加-CC参数来开启。 如tmux -CC命令会开启一个新的 tmux 会话，并启用控制模式，之后你的 iterm 会打开一个新的窗口，用于展示 tmux 会话；该窗口的表现和没使用 tmux 时一样，你不需要通过快捷键或 tmux 命令来新建多窗口和多窗格。使用 iterm2 的快捷键Command+D和Command+Shift+D来分隔窗格，使用Command+N来新建 Tab，使用Command+N来新建窗口。 使用如下命令来附加到一个已存在的 tmux 会话。 tmux ls tmux -CC attach -t 0  下面的命令用于创建一个名为main的会话，如果该会话存在的话则直接恢复该会话。 tmux -CC new -A -s main  或者在通过 SSH 连接到服务器的时候直接执行此命令，直接打开一个 tmux 会话。 ssh -t root@1.1.1.1 'tmux -CC new -A -s main'  "},{"title":"参考资料​","type":1,"pageTitle":"iterm2 对 tmux 的特殊支持","url":"blog/tmux-integration-in-iterm2#参考资料","content":"tmux Integration Best Practices · Wiki · George Nachman / iterm2 · GitLab tmux | 我的学习笔记↩tmux Integration - Documentation - iTerm2 - macOS Terminal Replacement↩ "},{"title":"UFW：简单易上手的防火墙规则管理工具","type":0,"sectionRef":"#","url":"blog/ufw","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#前言","content":"UFW 是一款在 Debian 系系统中可用的防火墙规则管理工具，可以帮助你快速配置各种服务的端口访问权限，而不用书写冗长的 iptables 规则命令。 "},{"title":"安装​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#安装","content":"可以使用apt快速安装。 apt install ufw  "},{"title":"启用/禁用​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#启用禁用","content":"使用以下命令来启用 UFW，并且会随着系统开启而启动。 ufw enable  使用以下命令来停止 UFW。 ufw disable  "},{"title":"默认行为​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#默认行为","content":"使用ufw default命令来配置默认行为，以下两条是 UFW 初始化的默认行为；默认拒绝所有入流量，允许所有出流量。 ufw default deny incoming ufw default allow outgoing  你可以使用ufw default命令来覆盖默认行为，使用allow/deny和incoming/outgoing/routed组合。 使用下面的命令来查看当前的默认行为。 ufw status verbose   "},{"title":"添加规则​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#添加规则","content":""},{"title":"放行/禁止端口​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#放行禁止端口","content":"以下命令用于放行 53 端口的 TCP 和 UDP 流量。 ufw allow 53  以下命令用于仅放行 53 端口的 TCP 流量。 ufw allow 53/tcp  以下命令用于仅放行 53 端口的 UDP 流量。 ufw allow 53/udp  还可以一次放行一个范围内的端口。 ufw allow 1000:2000/tcp  禁止命令就是用deny替代allow。 ufw deny 53 ufw deny 53/tcp ufw deny 53/udp ufw deny 1000:2000/tcp  "},{"title":"放行/禁止 IP​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#放行禁止-ip","content":"ufw allow from 1.2.3.4 ufw deny from 1.2.3.4  "},{"title":"删除规则​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#删除规则","content":"使用ufw delete命令来删除一条之前添加的规则。 ufw delete allow 53 ufw delete deny from 1.2.3.4  或者使用下面的命令列出添加的规则并编号，通过编号删除规则。 ufw status numbered ufw delete 2   "},{"title":"常用服务端口​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#常用服务端口","content":"在添加或删除关于端口的规则时，除了手动指出端口号之外，还可以通过服务名称来放行/禁止端口。 ufw allow ssh ufw deny ssh ufw delete allow ssh ufw delete deny ssh  服务名和端口号定义在/etc/services文件中。在其中有关ssh服务的部分是这样写的。 ssh 22/tcp # SSH Remote Login Protocol  UFW 会根据此文件内容管理端口。 常用的服务名称有ssh、http和https等。 "},{"title":"参考资料​","type":1,"pageTitle":"UFW：简单易上手的防火墙规则管理工具","url":"blog/ufw#参考资料","content":"Uncomplicated Firewall (ufw) - Debian WikiUFW - Community Help WikiUncomplicated Firewall - WikipediaAn Introduction to Uncomplicated Firewall (UFW) - Linux.comUFW Tutorial: How To Set Up a Firewall with UFW on Ubuntu 20.04 | ArubaCloud.comHow To Set Up a Firewall with UFW on Ubuntu 20.04 | DigitalOcean "},{"title":"在 HTML 中使用 Unicode 代码","type":0,"sectionRef":"#","url":"blog/use-unicode-in-html","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#前言","content":"在某些情况下需要在 HTML 中嵌入特殊符号，但是 HTML 实体中并不包含这些符号，或是该实体符号不能被浏览器正确渲染，可以通过 Unicode 代码代替这些字符，以达到在网页中正确渲染该字符的目的。HTML 实体代码和字符对应的 Unicode 代码可以参考 HTML Standard1。 "},{"title":"声明网页编码​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#声明网页编码","content":"为了能在网页中正常显示 Unicode 字符，该网页必须使用 Unicode 编码，如 UTF-8。可在meta标签里声明网页编码，并确保 HTTP 头也使用此编码。 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;  "},{"title":"使用 HTML 实体​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#使用-html-实体","content":"在 HTML Standard1 中可以看到该符号的名字是Aacute;，可以在其前方加上&amp;来表示 HTML 命名字符。 Á &lt;p&gt;&amp;Aacute;&lt;/p&gt;  但是并不是所有的命名字符都能被渲染出来，比如字符{。 &amp;lbrace; &lt;p&gt;&amp;lbrace;&lt;/p&gt;  "},{"title":"使用 Unicode 代码​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#使用-unicode-代码","content":"可以使用十六进制编码。 { &lt;p&gt;&amp;#x0007B;&lt;/p&gt;  也可以使用十进制编码。 { &lt;p&gt;&amp;#123;&lt;/p&gt;  "},{"title":"参考资料​","type":1,"pageTitle":"在 HTML 中使用 Unicode 代码","url":"blog/use-unicode-in-html#参考资料","content":"HTML、CSS、JS 对 unicode 字符的不同处理 - 我是小茗同学 - 博客园HTML Unicode UTF-8 HTML Standard↩ "},{"title":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","type":0,"sectionRef":"#","url":"blog/use-pwsh-and-oh-my-posh3-on-windows","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#前言","content":"在 macOS 中用 zsh 配合 oh-my-zsh 可以打造出一个用的很舒服的终端，其实在 Windows 中也可以。 在 Windows 中可以用 pwsh1 和 oh-my-posh2 打造出一个好用的终端。 Windows 自带的 PowerShell 版本低，所以需要额外安装一个新版本的 pwsh，而不是用系统提供的。 oh-my-posh3 现在已基于 Go 语言重构，是一个跨平台的命令行工具，安装和配置方式和 oh-my-posh2 相比有些变化。 终端软件用的是 Windows Terminal3，这是一个现代化的、可自定义的好看的终端模拟器。 历史命令提示是通过 PowerShell 的 PSReadLine4 模组实现的。 "},{"title":"前置条件​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#前置条件","content":"Scoop5 是 Windows 上的一款基于 PowerShell 的包管理器，接下来的软件都是用 Scoop 安装的，因为它能很方便地管理软件和配置环境变量。Scoop 的安装及使用不在本文的讨论范围内。 由于多数软件来源于 Github，在网络不好的情况下可能会安装失败，请自行配置网络代理。 以下命令用于在 PowerShell 中配置代理，请自行替换地址和端口号。 $Env:http_proxy=&quot;http://127.0.0.1:11223&quot;; $Env:https_proxy=&quot;http://127.0.0.1:11223&quot;  Scoop 基于 Git，为了让 Scoop 能正常工作，请参考以下命令用于配置 Git 的代理。 git config --global http.proxy http://127.0.0.1:11223 git config --global https.proxy https://127.0.0.1:11223  "},{"title":"安装 pwsh​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-pwsh","content":"scoop install pwsh  "},{"title":"安装 Windows Terminal​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-windows-terminal","content":"scoop install windows-terminal  "},{"title":"安装 Cascadia Code 字体​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-cascadia-code-字体","content":"部分命令行字符需要正确配置字体才能正常显示，安装字体需要管理员权限，注意授权提示。 更多命令行字符字体可参考 nerd-fonts6 项目。 scoop install sudo scoop bucket add nerd-fonts sudo scoop install CascadiaCode-NF-Mono  "},{"title":"在 Windows Terminal 中集成 pwsh​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#在-windows-terminal-中集成-pwsh","content":"在 Window Terminal 中添加一个新的终端配置。命名为「PWSH」，命令为pwsh。设置字体为「CaskaydiaCove NF」。     保存此配置，在「启动」选项卡中把刚刚新增的「PWSH」配置文件设置为默认配置文件。  打开 PWSH，配置完成。  "},{"title":"安装 oh-my-posh3​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#安装-oh-my-posh3","content":"目前，在 oh-my-posh 的官方文档中使用的安装命令为scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json，请不要使用该命令。 oh-my-posh3 已存在于 Scoop 的 main 仓库中，请安装此软件包，后面的配置命令跟包名有关。 scoop install oh-my-posh3  接下来编写 PWSH 的用户配置，以下命令用于创建一个配置文件并用记事本打开。该配置文件的作用是在每次 pwsh 初始化的时候自动执行其中的命令。 if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE  在弹出的记事本里写入 oh-my-posh 的初始化命令，该命令会在每次 pwsh 初始化的时候执行。 $env:POSH_GIT_ENABLED = $true oh-my-posh --init --shell pwsh --config &quot;$(scoop prefix oh-my-posh3)\\themes\\wopian.omp.json&quot; | Invoke-Expression  重新打开终端就能看到一个带主题的 PowerShell，如果有些字符显示不出来就是字体没有配置好。  "},{"title":"配置历史命令提示​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#配置历史命令提示","content":"在 PWSH 中执行命令，安装 PSReadLine 模组。在安装时请输入「Y」来确认安装。以下命令用于安装 PSReadLine，请在 PWSH 中执行而不是在 PowerShell 中。 Install-Module PSReadLine   然后编辑$PROFILE文件，在每次终端打开的时候对PSReadLine进行初始化。 notepad $PROFILE  在配置文件中附加上以下内容。 Set-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录 Set-PSReadlineKeyHandler -Key Tab -Function Complete # 设置 Tab 键补全 Set-PSReadLineKeyHandler -Key &quot;Ctrl+d&quot; -Function MenuComplete # 设置 Ctrl+d 为菜单补全和 Intellisense Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo # 设置 Ctrl+z 为撤销 Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向上键为后向搜索历史记录 Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward # 设置向下键为前向搜索历史纪录  保存配置文件，重启终端，就能看到一个带历史命令提示的终端了。  "},{"title":"更改 oh-my-posh 的主题​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#更改-oh-my-posh-的主题","content":"oh-my-posh 提供了多套主题可供选择，在 PWSH 中执行以下命令对所有主题进行预览。 Get-ChildItem -Path &quot;$(scoop prefix oh-my-posh3)\\themes\\*&quot; -Include '*.omp.json' | Sort-Object Name | ForEach-Object -Process { $esc = [char]27 Write-Host &quot;&quot; Write-Host &quot;$esc[1m$($_.BaseName)$esc[0m&quot; Write-Host &quot;&quot; oh-my-posh --config $($_.FullName) --pwd $PWD Write-Host &quot;&quot; }   其中以.omp结尾的是主题文件的名称，如果需要使用某个主题就替换掉$PROFILE文件中初始化命令中的配置文件名就可以了。 以下命令用于用记事本打开$PROFILE文件。 notepad $PROFILE  在打开的记事本中你会看到 oh-my-posh 的初始化命令。 oh-my-posh --init --shell pwsh --config &quot;$(scoop prefix oh-my-posh3)\\themes\\wopian.omp.json&quot; | Invoke-Expression  将你中意的主题名称替换命令中的wopian.omp，保存该配置文件然后重启终端就可以看到新主题的效果了。 "},{"title":"更改 Windows Terminal 的配色​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#更改-windows-terminal-的配色","content":"在 Windows Terminal 中默认有多套配色方案可选，这里推荐一套自定义的配色方案，来自于 Dracula7。 在 Windows Terminal 的设置页面中，点击「打开 JSON 文件」，在该文件的schemes数组中添加一个配色方案对象。 &quot;schemes&quot;: [ { &quot;name&quot;: &quot;Dracula&quot;, &quot;cursorColor&quot;: &quot;#F8F8F2&quot;, &quot;selectionBackground&quot;: &quot;#44475A&quot;, &quot;background&quot;: &quot;#282A36&quot;, &quot;foreground&quot;: &quot;#F8F8F2&quot;, &quot;black&quot;: &quot;#21222C&quot;, &quot;blue&quot;: &quot;#BD93F9&quot;, &quot;cyan&quot;: &quot;#8BE9FD&quot;, &quot;green&quot;: &quot;#50FA7B&quot;, &quot;purple&quot;: &quot;#FF79C6&quot;, &quot;red&quot;: &quot;#FF5555&quot;, &quot;white&quot;: &quot;#F8F8F2&quot;, &quot;yellow&quot;: &quot;#F1FA8C&quot;, &quot;brightBlack&quot;: &quot;#6272A4&quot;, &quot;brightBlue&quot;: &quot;#D6ACFF&quot;, &quot;brightCyan&quot;: &quot;#A4FFFF&quot;, &quot;brightGreen&quot;: &quot;#69FF94&quot;, &quot;brightPurple&quot;: &quot;#FF92DF&quot;, &quot;brightRed&quot;: &quot;#FF6E6E&quot;, &quot;brightWhite&quot;: &quot;#FFFFFF&quot;, &quot;brightYellow&quot;: &quot;#FFFFA5&quot; } ]  保存该 JSON 文件，重启 Windows Terminal，在 PWSH 的外观配置中选择新添加的 Dracula 配色方案。前文中我用的配色方案就是 Dracula。  "},{"title":"在 VS Code 里使用​","type":1,"pageTitle":"Windows Terminal + pwsh + oh my posh3 + PSReadLine 打造一个好用的终端","url":"blog/use-pwsh-and-oh-my-posh3-on-windows#在-vs-code-里使用","content":"在 VS Code 的配置文件settings.json中加入以下配置。 &quot;terminal.integrated.profiles.windows&quot;: { &quot;Windows PowerShell&quot;: { &quot;path&quot;: &quot;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe&quot; }, &quot;PWSH&quot;: { &quot;path&quot;: &quot;pwsh&quot; } }, &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;PWSH&quot;, &quot;terminal.integrated.fontFamily&quot;: &quot;'CaskaydiaCove NF'&quot;  PowerShell/PowerShell: PowerShell for every system!↩Home | Oh My Posh↩microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place!↩PowerShell/PSReadLine: A bash inspired readline implementation for PowerShell↩Scoop↩Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher↩Dark theme for Windows Terminal and 218+ apps — Dracula↩ "},{"title":"使用 SDKMAN 在 M1 Mac 上安装 JDK","type":0,"sectionRef":"#","url":"blog/using-sdkman-to-install-jdk-on-m1-mac","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"使用 SDKMAN 在 M1 Mac 上安装 JDK","url":"blog/using-sdkman-to-install-jdk-on-m1-mac#前言","content":"SDKMAN 是一系列 Bash 脚本，可以用来管理各个版本的 JDK。在 M1 芯片的 Mac 中可以很方便地安装 ARM 版本的 JDK，并在各个版本之间切换。 SDKMAN 也可以用来安装其他工具，如 Maven、Gradle 等，但是目前我用不上，我只用它来管理 JDK。 "},{"title":"安装​","type":1,"pageTitle":"使用 SDKMAN 在 M1 Mac 上安装 JDK","url":"blog/using-sdkman-to-install-jdk-on-m1-mac#安装","content":"SDKMAN 1 是一系列 Bash 脚本，所以有 Bash 环境的系统就能运行 SDKMAN，比如 Linux、macOS。 执行下面的安装脚本来安装 SDKMAN。改脚本会把 SDKMAN 的相关脚本下载至~/.sdkman文件夹中。之后它会修改你的 Shell 启动文件，将 SDKMAN 的初始化命令放入其中。 curl -s &quot;https://get.sdkman.io&quot; | bash  如果你的 Shell 启动文件（.zshrc/.bashrc/...）没有被附加 SDKMAN 的初始化命令，你可以手动放入以下命令。 source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;  "},{"title":"使用​","type":1,"pageTitle":"使用 SDKMAN 在 M1 Mac 上安装 JDK","url":"blog/using-sdkman-to-install-jdk-on-m1-mac#使用","content":"重新打开一个新的 Shell 会话，如果你正确完成了安装过程，此时你可以执行命令sdk。 # 列出可以安装的 JDK 发行版 sdk ls java  ================================================================================ Available Java Versions for macOS ARM 64bit ================================================================================ Vendor | Use | Version | Dist | Status | Identifier -------------------------------------------------------------------------------- Corretto | | 18.0.1 | amzn | | 18.0.1-amzn | | 17.0.3.6.1 | amzn | | 17.0.3.6.1-amzn | | 11.0.15.9.1 | amzn | | 11.0.15.9.1-amzn | | 8.332.08.1 | amzn | | 8.332.08.1-amzn Gluon | | 22.1.0.1.r17 | gln | | 22.1.0.1.r17-gln | | 22.1.0.1.r11 | gln | | 22.1.0.1.r11-gln GraalVM | | 22.1.0.r17 | grl | installed | 22.1.0.r17-grl | | 22.1.0.r11 | grl | | 22.1.0.r11-grl Java.net | | 20.ea.4 | open | | 20.ea.4-open | | 20.ea.3 | open | | 20.ea.3-open | | 19.ea.29 | open | | 19.ea.29-open | | 19.ea.28 | open | | 19.ea.28-open | | 18.0.1.1 | open | | 18.0.1.1-open Liberica | | 18.0.1.1.fx | librca | | 18.0.1.1.fx-librca | | 18.0.1.1 | librca | | 18.0.1.1-librca | | 17.0.3.1.fx | librca | | 17.0.3.1.fx-librca | | 17.0.3.1 | librca | | 17.0.3.1-librca | | 11.0.15.1.fx | librca | | 11.0.15.1.fx-librca | | 11.0.15.1 | librca | | 11.0.15.1-librca | | 8.0.333.fx | librca | | 8.0.333.fx-librca | | 8.0.333 | librca | | 8.0.333-librca Microsoft | | 17.0.3 | ms | | 17.0.3-ms | | 11.0.15 | ms | | 11.0.15-ms Oracle | | 18.0.1 | oracle | | 18.0.1-oracle | | 17.0.3 | oracle | | 17.0.3-oracle SapMachine | | 18.0.1.1 | sapmchn | | 18.0.1.1-sapmchn | | 17.0.3 | sapmchn | | 17.0.3-sapmchn | | 17.0.3.0.1 | sapmchn | | 17.0.3.0.1-sapmchn | | 17.0.2 | sapmchn | | 17.0.2-sapmchn Semeru | | 18.0.1.1 | sem | | 18.0.1.1-sem | | 17.0.3 | sem | | 17.0.3-sem | | 11.0.15 | sem | | 11.0.15-sem Temurin | | 18.0.1 | tem | | 18.0.1-tem | | 17.0.3 | tem | | 17.0.3-tem | | 11.0.15 | tem | | 11.0.15-tem Zulu | | 18.0.1 | zulu | | 18.0.1-zulu | | 18.0.1.fx | zulu | | 18.0.1.fx-zulu | | 17.0.3 | zulu | installed | 17.0.3-zulu | | 17.0.3.fx | zulu | | 17.0.3.fx-zulu | | 11.0.15 | zulu | installed | 11.0.15-zulu | | 11.0.15.fx | zulu | | 11.0.15.fx-zulu | &gt;&gt;&gt; | 8.0.332 | zulu | installed | 8.0.332-zulu | | 8.0.332.fx | zulu | | 8.0.332.fx-zulu ================================================================================ Omit Identifier to install default version 17.0.3-tem: $ sdk install java Use TAB completion to discover available versions $ sdk install java [TAB] Or install a specific version by Identifier: $ sdk install java 17.0.3-tem Hit Q to exit this list view ================================================================================ (END)  # 安装 zulu jdk 8.0.332 sdk install java 8.0.332-zulu  # 把 8.0.332-zulu 加入环境变量 sdk use java 8.0.332-zulu  # 查看现在使用的哪个 JDK sdk current java  # 卸载 8.0.332-zulu sdk uninstall java 8.0.332-zulu  Home - SDKMAN! the Software Development Kit Manager↩ "},{"title":"Zerotier 异地组网","type":0,"sectionRef":"#","url":"blog/zerotier","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#前言","content":"Zerotier1 是一个优秀的异地组网解决方案。其优点是组网灵活、不需要更改现有网络结构，支持 P2P 和转发。 Zerotier 使用也不是没有限制，免费版本的最多加入 50 个客户端，不过对于个人来说肯定够用了。 "},{"title":"控制台​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#控制台","content":"在控制台 2 注册并登陆。 在创建网络后会得到一个 Network ID，此 ID 是唯一的，是客户端加入此网络所需的唯一参数。  在网络管理页面中，Access Control 控制客户端认证方式，如果选择PRIVATE则每个客户端的加入都需要在此页面经由你允许。  在 IPv4 Auto-Assign 中，可以对客户端的 IP 段进行配置，不和你原来的网络地址冲突即可。  在 Members 中你可以管理该网络下的所有客户端，勾选客户端对应的Auth?选框即可让客户端加入此网络。每个客户端在加入的时候会自动分配一个 IP 地址，你还可以手动分配客户端的 IP 地址。  在多个客户端加入网络后，即使处于不同的网络环境下，客户端都可以通过分配到的 IP 互相访问。 "},{"title":"客户端​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#客户端","content":"Zerotier 在常用平台上都有客户端，有图形化的有命令行的。  "},{"title":"自动 NAT​","type":1,"pageTitle":"Zerotier 异地组网","url":"blog/zerotier#自动-nat","content":"在前面的方案中，如果多个机器互相访问就需要每个机器都安装 Zerotier 客户端并加入同一个网络。 借助 OpenWrt 和 Zerotier 可以暴露整个局域网到 Zerotier 网络中，只需要 OpenWrt 中的 Zerotier 加入网络即可。 勾选「自动允许客户端 NAT」即可。  许多 OpenWrt 的发行版都集成了此软件包。可以参考如下 Telegram 频道： Telegram: Contact @OpenWRTcnTelegram: Contact @aixiaoshaoTelegram: Contact @passwallOpenWRT233 OpenWrt 不需要作为你的主路由，它可以通过 LAN 口接入你现有的局域网，关闭 LAN 口的 DHCP 服务，作为旁路由使用。 你还需要在 Zerotier 控制台中配置静态路由。  在添加静态路由的时候Destination填局域网的网络地址，(Via)为下一跳地址，即 OpenWrt 路由器的 Zerotier 地址。 上面的静态路由配置将192.168.10.0/24局域网和192.168.11.0/24局域网暴露在 Zerotier 网络中。172.22.39.15和172.22.105.60分别是两个 OpenWrt 路由器在 Zerotier 网络中的地址，这两个路由器均配置了自动允许客户端 NAT。 这样做的优点是管理方便，不需要在每个机器上安装客户端并且加入网络。并且即使你在使用移动网络的时候可以直接访问到家里局域网的 IP，并且还是通过局域网 IP 访问，并不需要修改软件配置。 大致的网络拓扑图如下。在外使用移动网络的情况下，你可以使用192.168.10.0/24或192.168.11.0/24网段的内网地址访问局域网 A 或局域网 B 内的资源。 如果局域网 A 中的某台设备需要访问局域网 B 中的资源，还是需要在该设备上安装 Zerotier 客户端，并且加入统一 Zerotier 网络，然后就可以通过192.168.11.0/24的内网 IP 地址来访问局域网 B 中的资源了。  ZeroTier – Global Area Networking↩ZeroTier Central↩ "},{"title":"使用 Caddy 自动申请泛域名证书","type":0,"sectionRef":"#","url":"blog/wildcard-certificates-with-caddy","content":"","keywords":""},{"title":"泛域名证书​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#泛域名证书","content":"在 Caddy 中书写 Matcher 时可以使用通配符，如*.example.com，Caddy 会自动为你申请泛域名证书，但是需要合适的配置。 *.example.com包括foo.example.com、bar.example.com等其它二级域名，但是不包括顶级域名example.com；同时不包括其它等级的域名，只包括同等级域名。 通配符*只能放在最左边，如*.example.com、*.foo.example.com和*.bar.example.com等；不能写为foo.*.example.com。 "},{"title":"需要做的事情​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#需要做的事情","content":"不像单域名证书可以使用文件验证的方式来完成申请，泛域名证书要求 DNS 验证，这要求你得有权限修改该域名的 DNS 记录，并且你的 DNS 服务商要被 Caddy 支持才可以。 Caddy 对 DNS 的修改功能是由 Caddy 的 DNS 模组实现的，使用模组可以很方便地扩展 Caddy。你可以在 caddy-dns 的仓库列表 1 中查看你的 DNS 服务商是否受支持。 Caddy 的官方 Docker 镜像 2 并不包括任何模组，只有原版的 Caddy，如果需要使用带模组的镜像话需要自己构建。Caddy 提供了 xcaddy3 工具来帮助你编译带模组的 Caddy，并且也提供了使用示例 2，参考这些说明可以很方便地构建自己的 Caddy 镜像。 下文中记录了我用过的两个 DNS 服务商模组，分别是 Cloudflare 和 DNSPod。 "},{"title":"Cloudflare 例子​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#cloudflare-例子","content":""},{"title":"编写 Dockerfile​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#编写-dockerfile","content":"Dockerfile文件内容如下，用于构建 Docker 镜像。 FROM caddy:builder AS builder RUN xcaddy build --with github.com/caddy-dns/cloudflare FROM caddy COPY --from=builder /usr/bin/caddy /usr/bin/caddy  每行命令的解释如下。 使用caddy:builder镜像，起别名为builder，该镜像中包含了go环境和xcaddy工具；使用xcaddy来编译caddy，并使用--with参数指定附加的模组，该参数可以重复使用，意味着你可以附加多个模组，这里使用了github.com/caddy-dns/cloudflare4；使用原版的caddy镜像；复制在builder镜像中你自己编译的caddy覆盖掉原版caddy，并使用此镜像作为最终镜像。 "},{"title":"获取 Cloudflare Token​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#获取-cloudflare-token","content":"在 Cloudflare 的 API Tokens5 页面中创建一个 API Token。  选择使用编辑 DNS 模板来创建 API Token。  在 Zone Resources 中选择目标域名。  确认之后会给你生成一个 Token，你需要保存它。 "},{"title":"编写 Caddyfile​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#编写-caddyfile","content":"Caddyfile文件内容如下，作为 Caddy 的配置文件。 { email example@gmail.com } *.example.com { tls { dns cloudflare &lt;CF_API_TOKEN&gt; } @foo host foo.example.com handle @foo { reverse_proxy localhost:1000 } @bar host bar.example.com handle @bar { reverse_proxy localhost:2000 } handle { abort } } example.com { reverse_proxy localhost:3000 } foo.bar.example.com { reverse_proxy localhost:4000 }  1-3：全局配置区块，其中email指定申请证书时用的邮箱，写你自己的邮箱；5-23：*.example.com泛域名配置； 7：指定 DNS 服务商为 Cloudflare 并且配置 Cloudflare 的 API Token，替换&lt;CF_API_TOKEN&gt;为你自己的；10-18：使用具名 Matcher 和handle指令来配置每个使用泛域名证书的站点；20-22：其它未定义的域名直接丢弃连接，这需要写在所有站点后面。 25-31：其它不匹配泛域名的域名配置，还和正常使用一样。 "},{"title":"使用 Docker Compose 运行​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#使用-docker-compose-运行","content":"docker-compose.yml文件内容如下，用于快速运行容器。 version: &quot;3&quot; services: caddy: build: . restart: unless-stopped network_mode: host volumes: - data:/data - ./Caddyfile:/etc/caddy/Caddyfile volumes: data:  当前的目录结构如下。 caddy ├── Dockerfile ├── Caddyfile └── docker-compose.yml  在 caddy 目录下运行命令。Docker Compose 会根据 Dockerfile 构建镜像并运行。 docker-compose up --build -d  "},{"title":"DNSPod 例子​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#dnspod-例子","content":"和使用 Cloudflare 差不多。 "},{"title":"编写 Dockerfile​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#编写-dockerfile-1","content":"FROM caddy:builder AS builder RUN go env -w GOPROXY=https://goproxy.cn,direct RUN xcaddy build --with github.com/caddy-dns/dnspod FROM caddy COPY --from=builder /usr/bin/caddy /usr/bin/caddy  这个 Dockerfile 文件的内容和使用 Cloudfalre 时 Dockerfile 的内容有些许不同。 第 2 行指定了go get使用国内代理，因为我的这台服务器在国内，在下载依赖的时候遇到了一些网络问题，如果你在使用go get的时候也遇到了网络问题可以试试添加这行命令，在xcaddy build命令之前；第 3 行使用xcaddy来编译caddy，并使用--with参数指定附加的模组，该参数可以重复使用，意味着你可以附加多个模组，这里使用了github.com/caddy-dns/dnspod6； "},{"title":"获取 DNSPod Token​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#获取-dnspod-token","content":"在 DNSPod API 密钥页面 7 中生成一个 Token，在生成 Token 之后你需要保存下来，它只会完整地显示一次，以后都不能完整地查看了。  需要注意的是 DNSPod Token 使用时有些不一样，你申请的密钥有 ID 和 Token，在使用时需要把两者组合起来，中间用英文逗号分隔，如&lt;id&gt;,&lt;token&gt;，在使用时你需要将内容替换为自己的 ID 和 Token，更多说明请参考 DNSPod 的 API 使用文档 8。 "},{"title":"编写 Caddyfile​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#编写-caddyfile-1","content":"{ email example@gmail.com } *.example.com { tls { dns dnspod &lt;DNSPOD_TOKEN&gt; } @foo host foo.example.com handle @foo { reverse_proxy localhost:1000 } @bar host bar.example.com handle @bar { reverse_proxy localhost:2000 } handle { abort } } example.com { reverse_proxy localhost:3000 } foo.bar.example.com { reverse_proxy localhost:4000 }  第 7 行不一样，指定了 DNS 服务商为dnspod，并且你需要替换掉&lt;DNSPOD_TOKEN&gt;为你自己的。需要注意 DNSPod 的 API Token 格式特殊，是由 ID 和 Token 组合在一起，并用英文逗号分隔。 其它内容和使用 Cloudflare 时一样，请参考上文。 "},{"title":"使用 Docker Compose 运行​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#使用-docker-compose-运行-1","content":"和使用 Cloudflare 时一样，请参考上文。 "},{"title":"后记​","type":1,"pageTitle":"使用 Caddy 自动申请泛域名证书","url":"blog/wildcard-certificates-with-caddy#后记","content":"更多使用帮助请参考其官方文档 9，镜像构建出错请查看构建日志，Caddy 运行时出错请查看 Caddy 镜像的日志。 caddy-dns↩Caddy - Official Image | Docker Hub↩caddyserver/xcaddy: Build Caddy with plugins↩caddy-dns/cloudflare: Caddy module: dns.providers.cloudflare↩API Tokens | Cloudflare↩caddy-dns/dnspod↩API 密钥 - DNSPod-免费智能 DNS 解析服务商 - 电信网通教育网，智能 DNS↩密钥管理 - DNSPod 服务与支持↩Common Caddyfile Patterns — Caddy Documentation↩ "},{"title":"有意思的项目","type":0,"sectionRef":"#","url":"docs/bookmarks/interesting-projects","content":"有意思的项目 名称\t备注\t标签\t链接restic\tGo 语言实现的、跨平台的、支持多种备份目的地类型的备份工具。\t备份\trestic/restic: Fast, secure, efficient backup program autorestic\t在 Docker 容器中定时运行 restic 备份任务。\t备份\tcupcakearmy/autorestic: Config driven, easy backup cli for restic. duplicati\tC# 语言实现的、跨平台的、支持多种备份目的地类型和备份策略的备份工具，有一个基于 Web 的 GUI。\t备份\tduplicati/duplicati: Store securely encrypted backups in the cloud! MinIO\t自建对象存储服务，兼容 Amazon S3 协议。\t存储\tminio/minio: High Performance, Kubernetes Native Object Storage ZFile\t基于 Java 的在线网盘程序，支持的后端较多，特别有 OneDrive。\t存储\tzhaojun1998/zfile: 在线云盘、网盘、OneDrive、云存储、私有云、对象存储、h5ai vaultwarden\tBitwarden server API 的非官方实现，兼容官方客户端。和官方的服务端相比自建很方便，只需要运行一个容器即可。\t存储\tdani-garcia/vaultwarden: Unofficial Bitwarden compatible server written in Rust, formerly known as bitwarden_rs Rclone\t支持各种网络存储的 rsync。\t传输\trclone/rclone: &quot;rsync for cloud storage&quot; - Google Drive, S3, Dropbox, Backblaze B2, One Drive, Swift, Hubic, Wasabi, Google Cloud Storage, Yandex Files transfer.sh\t通过 HTTP 请求快速上传/分享临时文件，可以自建。\t传输\tdutchcoders/transfer.sh: Easy and fast file sharing from the command-line. croc\t命令行文件传输工具，跨平台，不需要公网 IP。\t传输\tGitHub - schollz/croc: Easily and securely send things from one computer to another Bark\t可以自建的消息推送服务，可以直接向你的 iOS 设备发送系统通知。\t传输\tFinb/bark-server: Backend of Bark NGINX Config\t在线生成 Nginx 配置文件。\tWeb\tdigitalocean/nginxconfig.io: ⚙️ NGINX config generator on steroids 💉 Certbot\t基于 ACME 协议的 TLS 证书自动签发工具，证书来自 Let’s Encrypt。\tWeb\tcertbot/certbot: Certbot is EFF's tool to obtain certs from Let's Encrypt and (optionally) auto-enable HTTPS on your server. It can also act as a client for any other CA that uses the ACME protocol. Caddy\t以自动 HTTP、简易配置而出名的跨平台 Web 服务器，用 Go 语言实现。\tWeb\tcaddyserver/caddy: Fast, multi-platform web server with automatic HTTPS Adminer\t基于 PHP 的单文件数据库管理工具。\t数据库\tvrana/adminer: Database management in a single PHP file test_db\t数据库测试数据。\t数据库\tdatacharmer/test_db: A sample MySQL database with an integrated test suite, used to test your applications and database servers vxe-table\tVue 表格和表单组件，非常丰富。\tVue\tx-extends/vxe-table: vxe-table vue 表格解决方案 Vue.Draggable\tVue 可拖拽控件。\tVue\tSortableJS/Vue.Draggable: Vue drag-and-drop component based on Sortable.js Portainer\t轻量级 Docker GUI，基于 Web。以 Docker 容器的方式运行。\tDocker\tportainer/portainer: Making Docker and Kubernetes management easy. Watchtower\t自动更新 Docker 镜像，并用相同的创建命令重新用新版本镜像创建容器。\tDocker\tcontainrrr/watchtower: A process for automating Docker container base image updates. composerize\t把docker run命令转换为 docker-compose.yml。\tDocker\tmagicmark/composerize: 🏃→🎼 docker run asdlksjfksdf &gt; docker-composerize up Dozzle\t在网页中查看 Docker 容器的日志。\tDocker\tamir20/dozzle: Realtime log viewer for docker containers. lazydocker\t在命令行中带 UI 界面管理 Docker 容器和其它 Docker 资源。\tDocker\tjesseduffield/lazydocker: The lazier way to manage everything docker PlantUML\t声明式绘图工具，Java 实现。\t绘图\tplantuml/plantuml: Generate UML diagram from textual description Mermaid\t声明式绘图工具，JavaScript 实现，可以在浏览器中直接渲染，支持的图种类较少。\t绘图\tmermaid-js/mermaid: Generation of diagram and flowchart from text in a similar manner as markdown Foam\t个人知识库/笔记整理软件，基于 VS Code 插件。\t笔记\tfoambubble/foam: A personal knowledge management and sharing system for VSCode 思源笔记\t国产的个人知识库/笔记整理软件。类似于 Notion，以块为基础结构。可以做到完全离线工作，数据文件都在本地，是 JSON 格式而不是 Markdown。基于 Electron。\t笔记\tsiyuan-note/siyuan: 📕 SiYuan is a local-first personal knowledge management system, supports fine-grained block-level reference, and Markdown WYSIWYG. Flame\t自建的个人书签网页。是一个 JavaScript 应用，数据用 SQLit 储存。\t笔记\tpawelmalak/flame: Flame is self-hosted startpage for your server. Easily manage your apps and bookmarks with built-in editors. Rubick\t基于 Electron 的开源桌面工具箱，和 uTools 的设计很像，目前正在火热开发阶段，优势是开源。\t工具\tclouDr-f2e/rubick: 🔧 基于 electron 的开源工具箱，自由集成丰富插件。 Ventoy\tU 盘启动工具，特点是多启动，不用为每个启动镜像制作一个 U 盘启动了，所有镜像都塞在 U 盘里，启动的时候可以选择。\t工具\tventoy/Ventoy: A new bootable USB solution. mitmproxy\t网络抓包工具，有命令行版本和基于 Web 的 GUI 版本。\t抓包\tmitmproxy/mitmproxy: An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers. ja-netfilter\t基于 Java Agent 的网络工具，可以拦截 Java 程序的网络通讯，并且对其修改。\t抓包\tja-netfilter/ja-netfilter: A javaagent framework Flameshot\t功能强大的、易用的截图工具。\t图像\tflameshot-org/flameshot: Powerful yet simple to use screenshot software Terminalizer\t记录命令行历史，以 GIF 图片或网页播放器分享。\t图像\tGitHub - faressoft/terminalizer: 🦄 Record your terminal and generate animated gif images or share a web player asciinema\t记录命令行历史，可以回放。\t图像\tasciinema/asciinema: Terminal session recorder 📹 neofetch\t在终端显示系统信息。\t图像\tdylanaraps/neofetch: 🖼️ A command-line system information tool written in bash 3.2+ Macast\t运行在电脑上的 DLNA 客户端。\t图像\txfangfang/Macast: Macast is a cross-platform application which using mpv as DLNA Media Renderer. 程序员做饭指南\t程序员做饭指南，步骤详细，食材及调味料的用量描述精确，可以一试。要是做饭有 Docker 就好了。\t生活\tAnduin2017/HowToCook: 程序员在家做饭方法指南。Programmer's guide about how to cook at home (Chinese). lazygit\t懒人用 Git，在命令行中以图形化的方式使用 Git。\tGit\tjesseduffield/lazygit: simple terminal UI for git commands Tabby\t终端模拟器，SSH 客户端，SFTP 客户端。\tSSH\tEugeny/tabby: A terminal for a more modern age 中文文案排版指北\t中文文案排版建议。\t排版\tsparanoid/chinese-copywriting-guidelines: Chinese copywriting guidelines for better written communication／中文文案排版指北 typo.css\t适合中文阅读的网页排版样式。\t排版\tsofish/typo.css: 中文网页重设与排版：一致化浏览器排版效果，构建最适合中文阅读的网页排版 pangu.js\t在中英文之间自动插入空格。\t排版\tvinta/pangu.js: Paranoid text spacing in JavaScript Xbox 下载助手\t帮助解决 Xbox 下载问题，如下载域名测速、电脑下载回传至 Xbox。\t游戏\tskydevil88/XboxDownload: Xbox 下载助手，支持 Xbox、微软商店、PSN、NS、EA Desktop &amp; Origin、战网国际服、Epic 下载加速。 SGS\t三国杀。\t游戏\tdonle/sgs noname\t三国杀。\t游戏\tlibccy/noname RSSHub\t通过编写规则将不支持 RSS 的网站转为 RSS 订阅。\tRSS\tDIYgod/RSSHub: 🍰 Everything is RSSible FreshRSS\tRSS 下载器、网页 RSS 阅读器，支持 Fever API 和 Google Reader API，所以可以使用兼容这些 API 的客户端。\tRSS\tFreshRSS/FreshRSS: A free, self-hostable aggregator… dracula-theme\t提供很多软件的统一风格的黑暗模式主题。 dracula/dracula-theme: 🧛🏻‍♂️ One theme. All platforms. (github.com) WiFi Card\t生成含有 WIFI 信息的二维码，可以扫描以快速连接 WIFI。 bndw/wifi-card: 📶 Print a QR code for connecting to your WiFi (wificard.io) Modern Unix\t收集了一些能代替 Unix 中的部分命令工作的现代化软件。 ibraheemdev/modern-unix: A collection of modern/faster/saner alternatives to common unix commands. zx\t用 JavaScript 编写服务器脚本，适合对 Bash 编程不太精通的前端开发者。 google/zx: A tool for writing better scripts 中国程序员容易发音错误的单词 shimohq/chinese-programmer-wrong-pronunciation: 中国程序员容易发音错误的单词 Administrative-divisions-of-China\t行政区划代码。 modood/Administrative-divisions-of-China: 中华人民共和国行政区划：省级（省份）、地级（城市）、县级（区县）、乡级（乡镇街道）、村级（村委会居委会），中国省市区镇村二级三级四级五级联动地址数据。 Glances\tPython 语言实现的系统信息以及资源占用查看工具，还可以兼容 Docker 容器的资源占用。可以在本机运行，可以以 C/S 方式运行，可以以 Web 服务器方式运行。 nicolargo/glances: Glances an Eye on your system. A top/htop alternative for GNU/Linux, BSD, Mac OS and Windows operating systems.","keywords":""},{"title":"VPS 相关书签","type":0,"sectionRef":"#","url":"docs/bookmarks/vps","content":"","keywords":""},{"title":"监控​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#监控","content":"欢迎来到古博 PING - 古博 PING "},{"title":"脚本​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#脚本","content":""},{"title":"aff​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#aff","content":"VPS 百科Telegram: Contact @vpscangVPS 大全 - 你的 VPS 仓库，提供 VPS 列表，库存，机房，价格等信息美国 vps 低至月付 1 刀，低价之王，超高性价比，VirMach 官方测速地址，各机房测试 IP – V2RaySSR 综合网TCM VPS 测评--云主机 VPS 交流推荐 "},{"title":"工具​","type":1,"pageTitle":"VPS 相关书签","url":"docs/bookmarks/vps#工具","content":"Fake Person: male| Fake Person Generator/Fake Name GeneratorReggy - Chrome Web Store "},{"title":"使用 zinit 作为 zsh 的插件管理器","type":0,"sectionRef":"#","url":"blog/zsh-with-zinit","content":"","keywords":""},{"title":"前言​","type":1,"pageTitle":"使用 zinit 作为 zsh 的插件管理器","url":"blog/zsh-with-zinit#前言","content":"之前使用 ohmyzsh 作为 zsh 的插件管理器，但是在使用过程中发现启动速度太慢了。在终端启动后仍需花费 1 至 2 秒才能看见命令提示符，并且我开启的插件数量也不多，没有什么优化思路。 近期我寻找到 ohmyzsh 的替代品 zinit，在经过一番体验之后感觉良好，启动速度非常快，并且我之前在 ohmyzsh 中需要的功能都能实现。 "},{"title":"备份 Shell 启动文件​","type":1,"pageTitle":"使用 zinit 作为 zsh 的插件管理器","url":"blog/zsh-with-zinit#备份-shell-启动文件","content":"折腾之前先备份一下目前的 Shell 启动文件，如.zshrc和.zprofile文件，在折腾坏了之后能快速恢复。 在这两个文件备份完毕之后，清空这两个文件的内容。 "},{"title":"安装 zinit​","type":1,"pageTitle":"使用 zinit 作为 zsh 的插件管理器","url":"blog/zsh-with-zinit#安装-zinit","content":"在 zsh 中执行下面的命令来下载 zinit 1 的安装脚本并执行。 bash -c &quot;$(curl --fail --show-error --silent --location https://raw.githubusercontent.com/zdharma-continuum/zinit/HEAD/scripts/install.sh)&quot;  这个安装脚本会克隆 zinit 的仓库至~/.local/share/zinit/zinit.git；并且更新你的.zshrc文件，在其中附加上 zinit 的启动命令，以下内容是安装脚本放入.zshrc文件的内容。 # ~/.zshrc ### Added by Zinit's installer source &quot;$HOME/.local/share/zinit/zinit.git/zinit.zsh&quot; autoload -Uz _zinit (( ${+_comps} )) &amp;&amp; _comps[zinit]=_zinit ### End of Zinit's installer chunk  之后打开一个新的 zsh 会话，zinit 就生效了。 在以后的使用过程中可以使用下面的命令来更新 zinit。 zinit self-update  "},{"title":"安装插件​","type":1,"pageTitle":"使用 zinit 作为 zsh 的插件管理器","url":"blog/zsh-with-zinit#安装插件","content":"zinit 引入插件的语法和 ohmyzsh 的语法不一样。 ohmyzsh 在引入自带插件的时候只需直接声明在plugins变量中即可；在引入第三方插件的时候首先需要自己下载插件到~/.oh-my-zsh/custom/plugins目录中，然后再在plugins中声明。 zinit 在引入插件的时候不需要自己手动下载，通过zinit命令声明之后在下次 zinit 加载之后自动下载插件。 zinit 引入插件的语法有两种。确保这些命令处于 zinit 初始化命令之后即可。 通过load加载的插件会启用分析功能，你可以通过zinit report [plugin]命令来查看插件的加载过程；通过light加载的插件不启用分析功能，性能比load好。 其中repo/plugin代表了 Github 仓库的用户名和仓库名。 zinit load &lt;repo/plugin&gt; # Load with reporting/investigating. zinit light &lt;repo/plugin&gt; # Load without reporting/investigating.  这是我加载的一些插件。 其中，zdharma-continuum/fast-syntax-highlighting确实比 oh-my-posh 中的zsh-syntax-highlighting流畅不少。 # ~/.zshrc zinit light zdharma-continuum/fast-syntax-highlighting zinit light zsh-users/zsh-completions zinit light zsh-users/zsh-autosuggestions zinit light sunlei/zsh-ssh zinit light ael-code/zsh-colored-man-pages zinit light MichaelAquilina/zsh-you-should-use  你还可以通过snippet命令来加载一个或多个脚本文件。使用这个命令可以加载 ohmyzsh 仓库中的插件，因为这些插件处于仓库的子目录中。 在 snippet 命令之后你可以加载本地或远程的脚本，直接写本地文件地址或 URL 即可。 对于常用的仓库你还可以使用别名，可以使用的别名有： PZT::，PreztoPZTM::，Prezto moduleOMZ::，Oh My ZshOMZP::，OMZ pluginOMZL::，OMZ libraryOMZT::，OMZ theme 下面是我从 ohmyzsh 中加载的插件。 # ~/.zshrc zinit snippet OMZP::safe-paste zinit snippet OMZP::sudo  某些插件不是单文件的，在使用过程中还需要加载其它文件，此时你就需要加载多个文件。 你可以在zinit snippet命令之前使用zinit ice命令。zinit ice命令是对下一句zinit命令的描述，只对下一句命令生效。zinit ice不仅仅可以用来描述zinit snippet命令。 比如在加载插件z的时候，除了加载z.plugin.zsh之外，该文件还加载了z.sh，此时就需要把整个子目录下载到本地。 使用zinit ice svn表示下一句zinit命令使用 svn 下载整个子文件夹到本地，Github 兼容 svn 协议。这样在使用 z 插件的时候就不会出错了。 # ~/.zshrc zinit ice svn zinit snippet OMZP::z  使用下面的命令来更新插件。 zinit update --parallel  "},{"title":"安装主题​","type":1,"pageTitle":"使用 zinit 作为 zsh 的插件管理器","url":"blog/zsh-with-zinit#安装主题","content":"这里我使用了 powerlevel10k2 主题，原因就是它启动非常快。直接使用 zinit 加载主题。 其中zinit ice depth&quot;1&quot;中的depth是传递给git clone的参数。 # ~/.zshrc zinit ice depth&quot;1&quot; zinit light romkatv/powerlevel10k  重新开启一个 zsh 会话你就可以看到 powerlevel10k 的初始化向导。根据向导选择你喜欢的样式即可，该向导会自动修改你的.zshrc文件，加入相关的启动命令。 如果 powerlevel10k 的初始化向导没有出现或者你想重新配置 powerlevel10k，运行以下命令即可。 p10k configure  "},{"title":"其他优化思路​","type":1,"pageTitle":"使用 zinit 作为 zsh 的插件管理器","url":"blog/zsh-with-zinit#其他优化思路","content":"除了替换掉 ohmyzsh 之外，还有很多优化 zsh 启动时间的思路。 如果你正在使用 nvm 作为你的 Node.js 版本管理工具，你可以考虑停止使用 nvm，寻找其他替代品代替它，因为它实在是太影响启动速度了，你可以使用 fnm，兼容.nvmrc配置文件； 在 Shell 启动文件中尽量不要执行外部命令，如brew --prefix命令，因为你不会经常更改 Homebrew 的安装位置，所以直接使用brew --prefix的结果替换掉该命令。 尽量少使用eval命令，比如在引入 Homebrew 的时候会使用eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;，你可以直接将/opt/homebrew/bin/brew shellenv命令的结果写入启动文件而不是使用eval命令。比如使用下面的命令替代eval命令。 export HOMEBREW_PREFIX=&quot;/opt/homebrew&quot;; export HOMEBREW_CELLAR=&quot;/opt/homebrew/Cellar&quot;; export HOMEBREW_REPOSITORY=&quot;/opt/homebrew&quot;; export PATH=&quot;/opt/homebrew/bin:/opt/homebrew/sbin${PATH+:$PATH}&quot;; export MANPATH=&quot;/opt/homebrew/share/man${MANPATH+:$MANPATH}:&quot;; export INFOPATH=&quot;/opt/homebrew/share/info:${INFOPATH:-}&quot;; FPATH=&quot;/opt/homebrew/share/zsh/site-functions:${FPATH}&quot;  "},{"title":"前后对比​","type":1,"pageTitle":"使用 zinit 作为 zsh 的插件管理器","url":"blog/zsh-with-zinit#前后对比","content":"使用time命令对比一下分别使用 ohmyzsh 和使用 zinit 的 zsh 加载速度。 # ohmyzsh /usr/bin/time zsh -i -c exit 0.37 real 0.18 user 0.12 sys # zinit /usr/bin/time zsh -i -c exit 0.12 real 0.07 user 0.03 sys  最终发现两者实际差距并不大，提升体验大部分是 powerlevel10k 主题的功劳，你在启动 zsh 之后的瞬间就能看见命令提示符。 zinit 还可以配置 Turbo Mode，可以让插件懒加载，对于加载时间长的插件非常有用。不过我在使用中并没有配置懒加载，即使这样，zinit 的加载速度还是比 ohmyzsh 快的。 暂时就先用 zinit 和 powerlevel10k 主题的组合吧，感觉不错。 "},{"title":"参考资料​","type":1,"pageTitle":"使用 zinit 作为 zsh 的插件管理器","url":"blog/zsh-with-zinit#参考资料","content":"加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程 - Aloxaf's Blogunixorn/awesome-zsh-plugins: A collection of ZSH frameworks, plugins, themes and tutorials.gustavohellwig/gh-zsh zdharma-continuum/zinit: 🌻 Flexible and fast ZSH plugin manager↩romkatv/powerlevel10k: A Zsh theme↩ "},{"title":"C","type":0,"sectionRef":"#","url":"docs/notes/c/","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"C","url":"docs/notes/c/#参考资料","content":"C 语言教程 - 网道C 语言教程 | 菜鸟教程C reference - cppreference.com "},{"title":"C 简介​","type":1,"pageTitle":"C","url":"docs/notes/c/#c-简介","content":""},{"title":"程序​","type":1,"pageTitle":"C","url":"docs/notes/c/#程序","content":"一系列有序指令的集合，目的是执行某些操作或解决某个特定问题。 "},{"title":"C 语言发展历程​","type":1,"pageTitle":"C","url":"docs/notes/c/#c-语言发展历程","content":" 需要注意的几个版本： ANSI C（标准 C）C89C99 "},{"title":"C 语言的特点​","type":1,"pageTitle":"C","url":"docs/notes/c/#c-语言的特点","content":"代码级别的跨平台允许直接访问物理地址，对硬件进行操作结构化程序设计，具有变量作用域以及递归功能的过程式语言参数可以是指传递，也可以是指针传递没有对象，可以用结构体预编译处理 "},{"title":"程序结构​","type":1,"pageTitle":"C","url":"docs/notes/c/#程序结构","content":""},{"title":"基本结构​","type":1,"pageTitle":"C","url":"docs/notes/c/#基本结构","content":"C 程序主要包括以下部分： 预处理器指令函数变量语句 &amp; 表达式注释 "},{"title":"程序入口​","type":1,"pageTitle":"C","url":"docs/notes/c/#程序入口","content":"程序的入口是main函数。 int main(){ // 方法体 }  "},{"title":"开发过程​","type":1,"pageTitle":"C","url":"docs/notes/c/#开发过程","content":"编辑（.c/.h）编译（.obj）链接（.exe）运行 "},{"title":"编译&执行命令​","type":1,"pageTitle":"C","url":"docs/notes/c/#编译执行命令","content":"gcc test1.c -o main.out ./main.out  "},{"title":"基本语法​","type":1,"pageTitle":"C","url":"docs/notes/c/#基本语法","content":"C 程序的入口是main函数C 程序源代码文件的扩展名为.c头文件的扩展名为.h语法区分大小写每条执行语句以;结束 "},{"title":"数据类型​","type":1,"pageTitle":"C","url":"docs/notes/c/#数据类型","content":"C Tutorials - data types in C Programming Language  每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间。 基本类型，它们是算术类型，包括两种类型：整数类型和浮点类型。枚举类型，它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。void，表明没有可用的值。派生类型，包括指针类型、数组类型、结构类型、共用体类型和函数类型。 "},{"title":"字符类型​","type":1,"pageTitle":"C","url":"docs/notes/c/#字符类型","content":"在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义。 \\t，制表位\\n，换行符\\\\，\\\\&quot;，&quot;\\'，'\\r，回车 "},{"title":"整数类型​","type":1,"pageTitle":"C","url":"docs/notes/c/#整数类型","content":"前缀： 0x，16 进制0，8 进制无前缀，10 进制 后缀： U，unsigned，无符号整数L，long，长整数 "},{"title":"枚举​","type":1,"pageTitle":"C","url":"docs/notes/c/#枚举","content":"enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN };  枚举本质上就是整形。默认情况下编号从 0 开始。 "},{"title":"浮点类型​","type":1,"pageTitle":"C","url":"docs/notes/c/#浮点类型","content":"float是单精度浮点类型，1 位符号，8 位指数，23 位小数。  double是双精度浮点值。双精度是 1 位符号，11 位指数，52 位小数。  可以使用科学计数法表示，如3.14e-11，表示3.14×(10)−113.14\\times(10)^{-11}3.14×(10)−11。 "},{"title":"void类型​","type":1,"pageTitle":"C","url":"docs/notes/c/#void类型","content":""},{"title":"变量​","type":1,"pageTitle":"C","url":"docs/notes/c/#变量","content":""},{"title":"初始值​","type":1,"pageTitle":"C","url":"docs/notes/c/#初始值","content":"局部变量不会被自动初始化；全局变量会被自动初始化。 数据类型\t初始化默认值int\t0 char\t'\\0' float\t0 double\t0 pointer\tNULL "},{"title":"常量​","type":1,"pageTitle":"C","url":"docs/notes/c/#常量","content":""},{"title":"字面量​","type":1,"pageTitle":"C","url":"docs/notes/c/#字面量","content":"写出来的数字、字符、字符串都是字面量，是不变的。 "},{"title":"定义常量​","type":1,"pageTitle":"C","url":"docs/notes/c/#定义常量","content":"#define​ #define identifier value  这是一个预处理命令，实现原理是在编译时进行字符串替换。注意 value 使用括号包围起来，不然在某些地方会产生意料之外的结果。 const​ const type variable = value;  这是一个关键字，用于把变量所在的内存区域设置为只读。可以用在参数列表中，在该方法中，该参数不能被修改。 "},{"title":"判断​","type":1,"pageTitle":"C","url":"docs/notes/c/#判断","content":""},{"title":"switch​","type":1,"pageTitle":"C","url":"docs/notes/c/#switch","content":"switch(expression){ case constant-expression : statement(s); break; /* 可选的 */ case constant-expression : statement(s); break; /* 可选的 */ /* 您可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s); }  switch 语句中的 expression 是一个常量表达式，必须是一个整型或枚举类型。 "},{"title":"循环​","type":1,"pageTitle":"C","url":"docs/notes/c/#循环","content":""},{"title":"goto​","type":1,"pageTitle":"C","url":"docs/notes/c/#goto","content":"goto label; // .. // . label: statement;  label 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 goto 语句的前面或者后面。 "},{"title":"函数​","type":1,"pageTitle":"C","url":"docs/notes/c/#函数","content":"函数的参数传递都是值传递，没有引用传递。即使是指针，传递的也是指针值的复制。所以直接修改局部变量的指针地址是不会影响到外部的变量的。 传递结构体的时候也是传递了一个复制，而不是引用；包括结构体中的指针，也是传递了一个指针的复制。 "},{"title":"数组​","type":1,"pageTitle":"C","url":"docs/notes/c/#数组","content":"// 逐个初始化 double balance[5]; balance[4] = 50.0; // 使用初始化语句 double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0}; // 可以省略掉长度 double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};  数组名就是一个指针，指向数组的首地址。 "},{"title":"指针​","type":1,"pageTitle":"C","url":"docs/notes/c/#指针","content":""},{"title":"操作符​","type":1,"pageTitle":"C","url":"docs/notes/c/#操作符","content":"&amp;，取地址操作符*，取实例操作符 "},{"title":"变量指针​","type":1,"pageTitle":"C","url":"docs/notes/c/#变量指针","content":"指针变量中保存着一个内存地址。 "},{"title":"指向数组的指针​","type":1,"pageTitle":"C","url":"docs/notes/c/#指向数组的指针","content":"数组名就是一个指针，指向数组的首地址。 "},{"title":"多重指针​","type":1,"pageTitle":"C","url":"docs/notes/c/#多重指针","content":"指针中的内存地址指向的还是指针。多维数组就是多重指针。 "},{"title":"函数指针​","type":1,"pageTitle":"C","url":"docs/notes/c/#函数指针","content":"int max(int a, int b); int (*fun_ptr)(int,int) = max; // 声明一个指向同样参数、返回值的函数指针类型 fun_ptr(1, 2); // 通过 fun_ptr 调用 max 函数  声明一个函数指针与声明一个变量类似；其中fun_ptr是变量名，前面的int是返回值类型，后面的是参数列表，参数列表可以不用写参数名称，只与参数类型和顺序有关。 通过函数指针可以实现回调函数。即将其声明在函数参数中，在函数内部可以调用传递进来的方法。 #include &lt;stdio.h&gt; int max(int a, int b) { return a &gt; b ? a : b; } void callback(int (*p_max)(int, int)) { printf(&quot;%d\\n&quot;, p_max(1, 2)); } int main() { callback(max); }  "},{"title":"指针与算术运算符​","type":1,"pageTitle":"C","url":"docs/notes/c/#指针与算术运算符","content":"可以对指针使用算数运算，如+、-、*、/；单位偏移量和指针类型有关，如int指针的单位偏移量为 4。可以使用这个特性来计算出每个数组元素的地址，可以通过指针访问该地址。 指针也可以用比较运算符进行比较。 "},{"title":"字符串​","type":1,"pageTitle":"C","url":"docs/notes/c/#字符串","content":"字符串实际上是字符数组，字符串以'\\0'结尾，无论该元素后是否还有字符。  在使用字符串常量时不需要手动在末尾放一个'\\0'，编译器会自动给你加。 "},{"title":"struct结构体​","type":1,"pageTitle":"C","url":"docs/notes/c/#struct结构体","content":"把多种类型的数据声明在一起，结构体所占内存长度是其中最大字段大小的整数倍。 使用.来访问结构体成员；在通过结构体指针访问结构体成员时可以使用-&gt;。不用通过*符号取到结构体实力再操作成员，是一种简便写法。 struct Books book1; struct Books *struct_pointer; struct_pointer = &amp;book1; // -&gt; struct_pointer-&gt;title; // . (*struct_pointer).title;  "},{"title":"union共用体​","type":1,"pageTitle":"C","url":"docs/notes/c/#union共用体","content":"共用体的声明和使用与结构体类似。区别是共用体的长度是其内最大成员的长度；其内所有成员共用同一个内存区域来存储数据，修改一个成员的内容可能会对其它数据造成影响；在读取成员值的时候会按照该成员类型的长度来读取对应长度的内存值来解析为对应类型。 "},{"title":"typedef​","type":1,"pageTitle":"C","url":"docs/notes/c/#typedef","content":"给类型取新名字。 "},{"title":"I/O​","type":1,"pageTitle":"C","url":"docs/notes/c/#io","content":"在&lt;stdio.h&gt;中声明有三个FILE *，把输入/输出当作文件处理。 stdin，标准输入stdout，标准输出stderr，错误输出 "},{"title":"预处理命令​","type":1,"pageTitle":"C","url":"docs/notes/c/#预处理命令","content":"C 预处理器 | 菜鸟教程 "},{"title":"include​","type":1,"pageTitle":"C","url":"docs/notes/c/#include","content":"#include &lt; &gt;引用的是编译器的类库路径里面的头文件；#include &quot; &quot;引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件。 "},{"title":"错误处理​","type":1,"pageTitle":"C","url":"docs/notes/c/#错误处理","content":"int atexit(void (*func)(void))，&lt;stdlib.h&gt;，注册程序退出时的回调函数extern int errno，&lt;errno.h&gt;，存储最后一个错误号char *strerror(int errnum)，&lt;string.h&gt;，把错误号转为字符串 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; void ae() { if (errno) { fprintf(stderr, &quot;%s\\n&quot;, strerror(errno)); } } int main() { atexit(ae); // ... }  "},{"title":"可变参数​","type":1,"pageTitle":"C","url":"docs/notes/c/#可变参数","content":"在&lt;stdarg.h&gt;中。 "},{"title":"内存管理​","type":1,"pageTitle":"C","url":"docs/notes/c/#内存管理","content":"这些函数在&lt;stdlib.h&gt;中。 void *malloc(int num);void *calloc(int num, int size);void free(void *address); "},{"title":"标准库​","type":1,"pageTitle":"C","url":"docs/notes/c/#标准库","content":""},{"title":"stdio.h​","type":1,"pageTitle":"C","url":"docs/notes/c/#stdioh","content":"结构​ FILE 成员​ 声明有三个FILE *，把输入/输出当作文件处理。 stdin，标准输入stdout，标准输出stderr，错误输出 函数​ int printf(const char *format, ...);，格式化字符串并向stdout输出int fprintf(FILE *stream, const char *format, ...);格式化字符串，可以向指定的流输出int sprintf(char *buffer, const char *format, ...);，格式化字符串，写入另一个字符串int scanf( const char *format, ... );int fscanf( FILE *stream, const char *format, ... );int sscanf( const char *buffer, const char *format, ... ); 格式化参数\t备注\tPrecision%\t%本身 %c\tchar %s\t字符串\t指定最大输出长度 %d/%i\tint %u\tunsigned int\t指定小数位数，默认是 6 %f/%F\tfloat %e/%E\t十进制科学计数法 %x/%X\t十六进制 %p\t输出指针内的内存地址\t int getchar(void);，从标准输入读一个字符int getc( FILE *stream );，从指定流读一个字符int putchar(int ch);，写出一个字符到标准输出int putc( int ch, FILE *stream );，写出一个字符到指定流char *gets( char *str );，字符串char *fgets( char *str, int count, FILE *stream );int puts( const char *str );int fputs( const char *str, FILE *stream ); 文件读写： FILE *fopen( const char *filename, const char *mode );int fclose( FILE *stream );size_t fread( void *buffer, size_t size, size_t count, FILE *stream );，二进制读size_t fwrite( const void *restrict buffer, size_t size, size_t count, FILE *restrict stream );，二进制写int fseek( FILE *stream, long offset, int origin );，移动文件指针 fopen访问模式mode的值可以是下列值中的一个。 文本模式\t二进制模式\t备注r\trb\t打开已有文件，只读 w\twb\t读写，如果文件存在则清空文件覆盖写入 a\tab\t读写，追加写入 r+\tr+b/rb+\t读写 w+\tw+b/wb+\t读写，存在则清空，不存在则创建 a+\ta+b/ab+\t读写，从头读，追加写 fseek中origin有以下 3 个可选值。 SEEK_SET，以文件开头为基准SEEK_CUR，以当前指针位置为基准SEEK_END，以文件结束为基准 "},{"title":"stdlib.h​","type":1,"pageTitle":"C","url":"docs/notes/c/#stdlibh","content":"系统： int system( const char *command );，执行系统命令void exit( int exit_code ); 随机数： void srand( unsigned seed );，重置随机数种子int rand();，生成0到`RAND_MAX 的一个随机数 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main(void) { srand(time(NULL)); // use current time as seed for random generator int random_variable = rand(); printf(&quot;Random value on [0,%d]: %d\\n&quot;, RAND_MAX, random_variable); // roll a 6-sided die 20 times for (int n=0; n != 20; ++n) { int x = 7; while(x &gt; 6) x = 1 + rand()/((RAND_MAX + 1u)/6); // Note: 1+rand()%6 is biased printf(&quot;%d &quot;, x); } }  // Possible output Random value on [0,2147483647]: 448749574 3 1 3 1 4 2 2 1 3 6 4 4 3 1 6 2 3 2 6 1  "},{"title":"stdbool.h​","type":1,"pageTitle":"C","url":"docs/notes/c/#stdboolh","content":"定义了bool类型和true/false。 true=1false=0 "},{"title":"string.h​","type":1,"pageTitle":"C","url":"docs/notes/c/#stringh","content":"类型转换函数： int atoi( const char *str );，字符串转intlong atol( const char *str );long long atoll( const char *str );double atof( const char* str ); 字符串操作： void *memchr(const void *str, int c, size_t n)，字符串中搜索某个字符char *strchr(const char *str, int c)int memcmp(const void *str1, const void *str2, size_t n)，字符串比较int strcmp(const char *str1, const char *str2)void *memcpy(void *str1, const void *str2, size_t n)，复制字符串char *strcpy(char *dest, const char *src)void *memmove(void *str1, const void *str2, size_t n)，移动字符串char *strcat(char *dest, const char *src)，连接两个字符串char *strerror(int errnum)，把错误号转为对应的错误消息size_t strlen(const char *str)，字符串长度，以\\0为字符串结束char *strtok(char *str, const char *delim)，分隔字符串char *strstr(const char *haystack, const char *needle)，字符串中查找子串 "},{"title":"time.h​","type":1,"pageTitle":"C","url":"docs/notes/c/#timeh","content":"结构​ struct tm { int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月，范围从 0 到 11 */ int tm_year; /* 自 1900 年起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ };  成员​ CLOCKS_PER_SEC，表示每秒的处理器时钟个数 函数​ clock_t clock(void)，返回自从程序启动起，所经过的处理器时钟char *asctime(const struct tm *timeptr)，将tm结构解析为字符串char *ctime(const time_t *timer)，把时间戳转换为字符串double difftime(time_t time1, time_t time2)，计算两个时间戳之间的差值struct tm *gmtime(const time_t *timer)，时间戳转tm结构，用 UTC 时间，时区为+0struct tm *localtime(const time_t *timer)，时间戳转tm，用本地时区time_t mktime(struct tm *timeptr)，tm转时间戳，用本地时区time_t time(time_t *seconds)，得到当前时间戳size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)，tm转时间戳，可以自定义格式 "},{"title":"ctype.h​","type":1,"pageTitle":"C","url":"docs/notes/c/#ctypeh","content":"类型判断函数。 "},{"title":"math.h​","type":1,"pageTitle":"C","url":"docs/notes/c/#mathh","content":"double modf(double x, double *integer)，分解整数和小数部分double fabs(double x)，求绝对值double fmod(double x, double y)，求余数double sqrt(double x)，求平方根，x\\sqrt{x}x​double pow(double x, double y)，幂运算，x12=xx^{\\frac{1}{2}}=\\sqrt{x}x21​=x​double floor(double x)，返回数轴上在x左边的最近一个整数值，包括xdouble ceil(double x) "},{"title":"MySQL 进阶","type":0,"sectionRef":"#","url":"docs/notes/database/mysql-advanced","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#参考资料","content":"MySQL 数据库教程天花板，mysql 安装到 mysql 高级，强！硬！_哔哩哔哩_bilibili "},{"title":"用户与权限管理​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#用户与权限管理","content":""},{"title":"用户管理​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#用户管理","content":"登录服务器​ mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;  创建用户​ CREATE USER 用户名 [IDENTIFIED BY '密码'][,用户名 [IDENTIFIED BY '密码']]; CREATE USER zhang3 IDENTIFIED BY '123123'; # 默认host是 % CREATE USER 'kangshifu'@'localhost' IDENTIFIED BY '123456';  修改用户​ # 改名 UPDATE mysql.user SET USER='li4' WHERE USER='wang5'; FLUSH PRIVILEGES;  删除用户​ DROP USER user[,user]...; DROP USER li4 ; # 默认删除host为%的用户 DROP USER 'kangshifu'@'localhost';  修改密码​ # 1 只要有权限就可以改 ALTER USER USER() IDENTIFIED BY 'new_password'; alter user 'root'@'localhost' identified by 'abc123'; # 2，只能使用 root 用户改 SET PASSWORD='new_password'; SET PASSWORD FOR 'username'@'hostname'='new_password';  "},{"title":"权限管理​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#权限管理","content":"show privileges;  GRANT 权限1,权限2,...权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’]; GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost ; # 赋予所有权限，但是不包括 grant 权限 GRANT ALL PRIVILEGES ON *.* TO joe@'%' IDENTIFIED BY '123'; # WITH GRANT OPTION 这个选项表示该用户可以将自己拥有的权限授权给别人 GRANT ALL PRIVILEGES ON *.* TO joe@'%' IDENTIFIED BY '123' with grant option;  SHOW GRANTS; SHOW GRANTS FOR CURRENT_USER; SHOW GRANTS FOR CURRENT_USER(); SHOW GRANTS FOR 'user'@'主机地址' ;  REVOKE 权限1,权限2,...权限n ON 数据库名称.表名称 FROM 用户名@用户地址; REVOKE ALL PRIVILEGES ON *.* FROM joe@'%'; REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;  "},{"title":"角色管理​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#角色管理","content":"CREATE ROLE 'role_name'[@'host_name'] [,'role_name'[@'host_name']]... CREATE ROLE 'manager'@'localhost';  GRANT privileges ON table_name TO 'role_name'[@'host_name']; GRANT SELECT ON demo.settlement TO 'manager';  SHOW GRANTS FOR 'manager';  REVOKE privileges ON tablename FROM 'rolename';  DROP ROLE 'school_read';  GRANT role [,role2,...] TO user [,user2,...]; GRANT 'school_read' TO 'kangshifu'@'localhost'; # 要手动激活角色 SET DEFAULT ROLE ALL TO 'kangshifu'@'localhost'; SELECT CURRENT_ROLE();  REVOKE role FROM user;  "},{"title":"存储引擎​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#存储引擎","content":"InnoDB：具备外键支持功能的事务存储引擎；MyISAM：主要的非事务处理存储引擎。 "},{"title":"索引结构​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#索引结构","content":""},{"title":"InnoDB​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#innodb","content":"在 InnoDB 中，数据和索引存放在相同的结构中，InnoDB 的数据文件就是一颗 B+树。 物理上分为聚簇索引和非聚簇索引。 聚簇索引​ 每个表都有一个聚簇索引，数据和索引存放在一起。默认使用主键进行索引，如果没有主键则引擎会生成一个隐藏列作为主键。 使用记录主键值的大小进行记录和页的排序； 页内的记录是按照主键的大小顺序排成一个单向链表；存放目录项记录的页分为不同层次，在同一层次中也是根据页中用户记录的主键大小顺序排成一个双向链表。 B+树的叶子节点存储的是完整的用户记录。 优点： 数据访问更快，因为聚簇索引将索引和数据保存在同一个 B+树中，因此从聚簇索引中获取数据比非 聚簇索引更快；聚簇索引对于主键的 排序查找 和 范围查找 速度非常快；按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 节省了大量的 io 操作。 缺点： 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于 InnoDB 表，我们一般都会定义一个 自增的 ID 列为主键；更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为 不可更新；二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。 非聚簇索引​ 也称为辅助索引/二级索引。 对于表中其它字段的索引就是非聚簇索引。 其中页内节点的记录是按照该列的值大小排序的单项链表，除了保存该列的值之外，还保存了该条记录的主键 ID，目的是为了保证页内节点的唯一性； 其中记录保存了该列的值和主键值，在查找的时候如果需要其他字段的值的话会根据主键值去聚簇索引中查找该记录。 联合索引也是非聚簇索引，如果 a、b 字段联合索引的话，会先按照 a 字段排序、再按照 b 字段排序。 "},{"title":"MyISAM​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#myisam","content":"在 MyISAM，数据和索引是分离的，索引中存放了对应数据在文件中的相对位置。 "},{"title":"数据结构​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#数据结构","content":"Hash​ 只能等值比较，无法范围查找无序需要处理哈希冲突对联合索引处理不好，不能使用联合索引中的部分字段查找InnoDB 不支持 Hash 索引 B-Tree​   B+Tree​  B+树和 B 树的差异： B+树中只在叶子结点存放数据，非叶子结点只作索引；B+树中所有关键字都在叶子结点出现，叶子结点构成一个有序链表，结点内部的关键字也构成了有序链表；B+树中非叶子结点的关键字也会存储在子节点中，B 树中某个节点包含的关键字不会存储在子节点中。 "},{"title":"InnoDB 数据存储结构​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#innodb-数据存储结构","content":""},{"title":"数据存储的基本结构​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#数据存储的基本结构","content":"InnoDB 将数据划分为页，页默认大小是 16KB。 以页作为磁盘和内存之间交互的基本单位，一个页中可以存储多条行记录。  页面之间可以不在物理上连续，只需要通过双向链表关联即可。每个数据页中的记录都会按照主键值排序，形成单项链表。  "},{"title":"页的内部结构​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#页的内部结构","content":"按类型划分页： 数据页（保存 B+树节点）系统页Undo 页事务数据页   "},{"title":"行格式​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#行格式","content":""},{"title":"使用索引​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#使用索引","content":""},{"title":"索引分类​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#索引分类","content":"普通索引（INDEX）唯一索引（UNIQUE INDEX）主键索引（PRIMARY KEY）单列索引（INDEX）联合索引（INDEX）全文索引（FULLTEXT INDEX）空间索引（SPATIAL INDEX） "},{"title":"查看索引​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#查看索引","content":"SHOW INDEX FROM test1;  "},{"title":"创建索引​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#创建索引","content":"# 建表时一起创建索引 # 1. 普通索引 CREATE TABLE book( book_id INT , book_name VARCHAR(100), authors VARCHAR(100), info VARCHAR(100) , comment VARCHAR(100), year_publication YEAR, INDEX(year_publication) ); # 2. 唯一索引 CREATE TABLE test1( id INT NOT NULL, name varchar(30) NOT NULL, UNIQUE INDEX uk_idx_id(id) ); # 3. 主键索引 CREATE TABLE student ( id INT(10) UNSIGNED AUTO_INCREMENT , student_no VARCHAR(200), student_name VARCHAR(200), PRIMARY KEY(id) ); # 4. 单列索引 CREATE TABLE test2( id INT NOT NULL, name CHAR(50) NULL, INDEX single_idx_name(name(20)) ); # 5. 组合索引 CREATE TABLE test3( id INT(11) NOT NULL, name CHAR(30) NOT NULL, age INT(11) NOT NULL, info VARCHAR(255), INDEX multi_idx(id,name,age) ); # 6. 全文索引 CREATE TABLE test4( id INT NOT NULL, name CHAR(30) NOT NULL, age INT NOT NULL, info VARCHAR(255), FULLTEXT INDEX futxt_idx_info(info) ); SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’); # 7. 空间索引 CREATE TABLE test5( geo GEOMETRY NOT NULL, SPATIAL INDEX spa_idx_geo(geo) ); # 建表后创建索引 ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC] CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC | DESC]  "},{"title":"删除索引​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#删除索引","content":"ALTER TABLE table_name DROP INDEX index_name; DROP INDEX index_name ON table_name;  "},{"title":"降序索引​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#降序索引","content":"MySQL 8.0 新特性。创建索引时使某个字段降序排序在 B+树中。 在某些情况下可以提升效率，如查询时使用某个字段降序排列作为条件。 CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));  "},{"title":"隐藏索引​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#隐藏索引","content":"MySQL 8.0 新特性。可以手动隐藏某个索引而不删除它，使查询优化器不使用它。 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。  CREATE TABLE tablename( propname1 type1[CONSTRAINT1], propname2 type2[CONSTRAINT2], ...... propnamen typen, INDEX [indexname](propname1 [(length)]) INVISIBLE ); CREATE INDEX indexname ON tablename(propname[(length)]) INVISIBLE; ALTER TABLE tablename ADD INDEX indexname (propname [(length)]) INVISIBLE; # 切换成隐藏索引 ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; # 切换成非隐藏索引 ALTER TABLE tablename ALTER INDEX index_name VISIBLE;  "},{"title":"索引的设计原则​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#索引的设计原则","content":""},{"title":"适合创建索引的情况​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#适合创建索引的情况","content":"字段的数值有唯一性的限制频繁作为 WHERE 查询条件的字段经常 GROUPBY 和 ORDERBY 的列UPDATE、DELETE 的 WHERE 条件列DISTINCT 字段需要创建索引使用列的类型小的创建索引使用字符串前缀创建索引区分度高 (散列性高) 的列适合作为索引使用最频繁的列放到联合索引的左侧在多个字段都要创建索引的情况下，联合索引优于单值索引 "},{"title":"不适合创建索引的情况​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#不适合创建索引的情况","content":"在 where 中使用不到的字段，不要设置索引数据量小的表最好不要使用索引有大量重复数据的列上不要建立索引避免对经常更新的表创建过多的索引不建议用无序的值作为索引删除不再使用或者很少使用的索引不要定义冗余或重复的索引 "},{"title":"性能分析工具的使用​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#性能分析工具的使用","content":""},{"title":"last_query_cost​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#last_query_cost","content":"SHOW STATUS LIKE 'last_query_cost';  +-----------------+----------+ | Variable_name | Value | +-----------------+----------+ | Last_query_cost | 1.000000 | +-----------------+----------+  可以查询到上一次查询使用了多少个页。 "},{"title":"slow_query_log​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#slow_query_log","content":"# 开启慢查询记录 set global slow_query_log='ON'; # 设置慢查询的时间阈值 set global long_query_time = 1;  开启慢查询日志之后，记录的查询语句默认保存在/var/lib/mysql/&lt;hostname&gt;-slow.log文件中。可以使用mysqldumpslow工具来分析这个日志文件。 "},{"title":"SHOW PROFILE​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#show-profile","content":"set profiling = 'ON'; # 查看当前会话下的 profiles show profiles; # 查看最近一次的 profile show profile; # 查看某个编号的 profile show profile cpu,block io for query 2;  ALL：显示所有的开销信息。BLOCK IO：显示块 IO 开销。CONTEXT SWITCHES：上下文切换开 销。CPU：显示 CPU 开销信息。IPC：显示发送和接收开销信息。MEMORY：显示内存开销信 息。PAGE FAULTS：显示页面错误开销信息。SOURCE：显示和 Source_function，Source_file，Source_line 相关的开销信息。SWAPS：显示交换次数开销信息。 "},{"title":"EXPLAIN/DESCRIBE​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#explaindescribe","content":"table​ EXPLAIN 语句输出的每条记录都对应着某个单表的访问方法。 id​ id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行；每个 id 表示一趟独立的查询，一个 sql 的查询趟数越少越好。 select_type​ 名称\t描述SIMPLE\tSimple SELECT (not using UNION or subqueries) PRIMARY\tOutermost SELECT UNION\tSecond or later SELECT statement in a UNION UNION RESULT\tResultofaUNION SUBQUERY\tFirst SELECT in subquery DEPENDENT SUBQUERY\tFirst SELECT in subquery, dependent on outer query DEPENDENT UNION\tSecond or later SELECT statement in a UNION, dependent on outer query DERIVED\tDerived table MATERIALIZED\tMaterialized subquery UNCACHEABLE SUBQUERY\tA subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query UNCACHEABLE UNION\tThe second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) partitions​ -- 创建分区表， -- 按照 id 分区，id&lt;100 p0 分区，其他 p1 分区 CREATE TABLE user_partitions (id INT auto_increment, NAME VARCHAR(12),PRIMARY KEY(id)) PARTITION BY RANGE(id)( PARTITION p0 VALUES less than(100), PARTITION p1 VALUES less than MAXVALUE );  DESC SELECT * FROM user_partitions WHERE id&gt;200;  type​ 越靠前越好。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 const 级别。 systemconsteq_refreffulltextref_or_nullindex_mergeunique_subqueryindex_subqueryrangeindexALL possible_keys​ 可能会使用上的索引。 key​ 实际上用到的索引。 key_len​ 使用到的联合索引的长度，单位是字节。 ref​ 当使用索引列等值查询时，与索引列等值匹配的对象信息。 rows​ 预估需要读取的记录数。 filtered​ 经过搜索条件过滤后剩余记录数的百分比。 Extra​ No tables used，查询语句中没有使用到任何数据表Impossible WHEREUsing whereNo matching min/max rowUsing indexUsing index conditionUsing join buffer (Block Nested Loop)Not existsUsing intersect(...)Using union(...)Using sort_union(...)Zero limitUsing filesortUsing temporary... 输出格式​ 传统格式JSON 格式TREE 格式 EXPLAIN FORMAT=JSON SELECT .... EXPLAIN FORMAT=TREE SELECT ....  "},{"title":"SHOW WARNINGS​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#show-warnings","content":"使用SHOW WARNINGS来查看被优化过的 SQL 语句。 "},{"title":"trace​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#trace","content":"SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on; set optimizer_trace_max_mem_size=1000000;  select * from student where id &lt; 10;  select * from information_schema.optimizer_trace;  "},{"title":"sys schema​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#sys-schema","content":"索引情况​ #1. 查询冗余索引 select * from sys.schema_redundant_indexes; #2. 查询未使用过的索引 select * from sys.schema_unused_indexes; #3. 查询索引的使用情况 select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema='dbname' ;  表相关​ # 1. 查询表的访问量 select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; # 2. 查询占用bufferpool较多的表 select object_schema,object_name,allocated,data from sys.innodb_buffer_stats_by_table order by allocated limit 10; # 3. 查看表的全表扫描情况 select * from sys.statements_with_full_table_scans where db='dbname';  语句相关​ #1. 监控SQL执行的频率 select db,exec_count,query from sys.statement_analysis order by exec_count desc; #2. 监控使用了排序的SQL select db,exec_count,first_seen,last_seen,query from sys.statements_with_sorting limit 1; #3. 监控使用了临时表或者磁盘临时表的SQL select db,exec_count,tmp_tables,tmp_disk_tables,query from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0 order by (tmp_tables+tmp_disk_tables) desc;  IO 相关​ #1. 查看消耗磁盘IO的文件 select file,avg_read,avg_write,avg_read+avg_write as avg_io from sys.io_global_by_file_by_bytes order by avg_read limit 10;  Innodb 相关​ #1. 行锁阻塞情况 select * from sys.innodb_lock_waits;  "},{"title":"索引优化与查询优化​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#索引优化与查询优化","content":""},{"title":"索引失效的情况​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#索引失效的情况","content":"联合索引违反最左匹配原则；计算、函数、类型转换 (自动或手动) 导致索引失效；范围条件后边的列索引失效；不等于!=索引失效is null 可以使用索引，is not null 无法使用索引like 以通配符%开头索引失效OR 前后存在非索引的列，索引失效使用不相同的字符集会导致索引失效 "},{"title":"JOIN 的优化​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#join-的优化","content":"保证被驱动表的 JOIN 字段已经创建了索引；需要 JOIN 的字段，数据类型保持绝对一致；LEFT JOIN 时，选择小表作为驱动表，减少外层循环的次数；INNER JOIN 时，MySQL 会自动将。选择相信 MySQL 优化策略；能够直接多表关联的尽量直接关联，不用子查询；不建议使用子查询，建议将子查询 SQL 拆开结合程序多次查询，或使用 JOIN 来代替子查询；衍生表建不了索引。 "},{"title":"JOIN 的原理​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#join-的原理","content":"先在前表中寻找匹配条件的行，再去后表中对照比较。 "},{"title":"子查询优化​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#子查询优化","content":"使用 JOIN 代替子查询。连接查询不需要建立临时表，并且还能使用上索引。 "},{"title":"排序优化​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#排序优化","content":"Order by 时 select * 是一个大忌。最好只 Query 需要的字段； "},{"title":"GROUP BY 优化​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#group-by-优化","content":"where 效率高于 having，能写在 where 限定的条件就不要写在 having 中了；group by 先排序再分组；包含了 order by、group by、distinct 这些查询的语句，where 条件过滤出来的结果集请保持在 1000 行 以内，否则 SQL 会很慢。 "},{"title":"覆盖索引​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#覆盖索引","content":"一个索引包含了满足查询结果的数据就叫做覆盖索引。 避免 Innodb 表进行索引的二次查询 (回表)；可以把随机 IO 变成顺序 IO 加快查询效率。 索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务 DBA，或者称为业务数据架构师的工作。 "},{"title":"索引下推​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#索引下推","content":"Index Condition Pushdown(ICP) 是 MySQL 5.6 中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。ICP 可以减少存储引擎访问基表的次数以及 MySQL 服务器访问存储引擎的次数。 "},{"title":"数据库设计原则​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#数据库设计原则","content":""},{"title":"范式​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#范式","content":"在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式 (1NF)、第二范式 (2NF)、第三范式 (3NF)、巴斯-科德范式 (BCNF)、第四范式 (4NF) 和第五范式 (5NF，又称完美范式) 。 第一范式​ 第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为不可再次拆分的最小数据单元。 第二范式​ 第二范式要求，在满足第一范式的基础上，还要满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。（要求中的主键，其实可以拓展替换为候选键）。 第三范式​ 第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段。通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。 巴斯范式​ 它在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。 "},{"title":"反范式化​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#反范式化","content":"为满足某种商业目标，数据库性能比规范化数据库更重要。 "},{"title":"数据库其它调优策略​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#数据库其它调优策略","content":""},{"title":"调优的目标​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#调优的目标","content":"尽可能 节省系统资源，以便系统可以提供更大负荷的服务。(吞吐量更大)；合理的结构设计和参数调整，以提高用户操作 响应的速度。(响应速度更快)；减少系统的瓶颈，提高 MySQL 数据库整体的性能。 "},{"title":"事务​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#事务","content":""},{"title":"事务的特性​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#事务的特性","content":"原子性​ 原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。 一致性​ 致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。 隔离型​ 事务的隔离性是指一个事务的执行不被其他事务干扰。 持久性​ 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 "},{"title":"事务的状态​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#事务的状态","content":"MySQL 根据这些操作所执行的不同阶段把事务大致划分成几个状态。 活动的 (active)部分提交的 (partially committed)失败的 (failed)中止的 (aborted)提交的 (committed)  "},{"title":"显式事务​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#显式事务","content":"# 1. BEGIN; # 2. START TRANSACTION; START TRANSACTION READ ONLY; START TRANSACTION READ WRITE; START TRANSACTION WITH CONSISTENT SNAPSHOT;  "},{"title":"隐式事务​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#隐式事务","content":"每条 DML 语句都在一个事务中，默认会自动提交，可以设置autocommit来关闭自动提交。 SET autocommit = 0; SET autocommit = OFF;  在一些情况下会触发隐式自动提交事务。 执行 DDL 语句；开启一个新事务；加载数据的语句；关于 MySQL 复制的语句；其它。 "},{"title":"隔离级别​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#隔离级别","content":" SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别; #其中，隔离级别格式: # &gt; READ UNCOMMITTED # &gt; READ COMMITTED # &gt; REPEATABLE READ # &gt; SERIALIZABLE  "},{"title":"事务日志​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#事务日志","content":"事务的隔离性由锁机制实现；而事务的原子性、一致性和持久性由事务的 redo 日志和 undo 日志来保证。 REDO LOG 称为 重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性；UNDO LOG 称为 回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。 "},{"title":"锁​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#锁","content":""},{"title":"表锁​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#表锁","content":"意向锁（intention lock）​ 意向锁是由存储引擎，用户无法手动操作意向锁，在为数据行加共享、排他锁之前，InooDB 会先获取该数据行所在数据表的对应意向锁。 意向锁不会与行级的共享、排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。 元数据锁（MDL）​ 当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。 "},{"title":"行锁​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#行锁","content":"记录锁（Record Locks）​ 记录锁也就是仅仅把一条记录锁上。 间隙锁（Gap Locks）​ 用来解决幻读问题。gap 锁的提出仅仅是为了防止插入幻影记录而提出的。 临键锁（Next-Key Locks）​ 锁住某条记录，并且阻止其他事务在该记录前边的间隙插入新记录。是记录锁和间隙锁的结合。 插入意向锁（Insert Intention Locks）​ InnoDB 规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。 "},{"title":"加锁方式​","type":1,"pageTitle":"MySQL 进阶","url":"docs/notes/database/mysql-advanced#加锁方式","content":"可以隐式加锁，每条 DML 语句都自动会使用锁；也可以显式加锁。 # 共享锁 select .... lock in share mode # 排他锁 select .... for update  "},{"title":"Java","type":0,"sectionRef":"#","url":"docs/notes/java/","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"Java","url":"docs/notes/java/#参考资料","content":"2021 年度全网最全 Java 学习路线 - 哔哩哔哩尚硅谷 Java 零基础入门教程（含百道 Java 真题，2 万多行 Java 代码实战）_哔哩哔哩_bilibili30 天搞定 Java 核心技术 - 程序员标配，人手一套尚硅谷教程30 天搞定 Java 核心技术（上） - 谷粒学苑 - Java 培训 | 大数据培训 | 前端培训|HTML5 培训|Linux 运维培训_程序员一站式 IT 在线学习平台 - Powered By EduSoho "},{"title":"Java 语言概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-语言概述","content":""},{"title":"软件开发介绍​","type":1,"pageTitle":"Java","url":"docs/notes/java/#软件开发介绍","content":"人机交互方式​ 图形化界面（Graphical User Interface, GUI）命令行方式（Command Line Interface, CLI） 常用的 DOS 命令​ dir列出目录下的文件以及文件夹md创建目录rd删除目录cd进入指定目录cd..进入上级目录cd\\进入根目录del删除文件exit退出 DOS 命令行echo回显；可以用输出重定向输出内容到文件，如echo javase &gt; 1.txtTAB代码提示←→移动光标↑↓调整历史命令DeleteBackspace删除字符 "},{"title":"计算机编程语言介绍​","type":1,"pageTitle":"Java","url":"docs/notes/java/#计算机编程语言介绍","content":"第一代语言：机器语言，指令以二进制代码形式存在；第二代语言：汇编语言，使用助剂符表示一条机器指令；第三代语言：高级语言。 "},{"title":"Java 语言概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-语言概述-1","content":"Java 语言是 SUN（Stanford University Network）1995 年推出的一门高级编程语言。 编程语言排行榜：index | TIOBE - The Software Quality Company。 Java 简史​ 1991 年 Green 项目，开发语言最初命名为 Oak（橡树）1996 年，发布 JDK 1.01999 年，Java 分成 J2SE、J2EE 和 J2ME，JSP/Servlet 技术诞生2004 年，发布里程碑式版本 JDK 1.5，为突出此版本的重要性，更名为 JDK 5.02005 年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME2009 年，Oracle 公司收购 SUN，交易价格 74 亿美元2014 年，发布 JDK 8.0，是继 JDK 5.0 以来变化最大的版本2018 年 3 月，发布 JDK 10.0，版本号也称为 18.32018 年 9 月，发布 JDK 11.0，版本号也称为 18.9 Java 技术体系平台​ Java SE（Java Standard Edition）标准版，面向桌面级应用开发；Java EE（Java Enterprise Edition）企业版，是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如 Servlet、JSP 等，主要针对于 Web 应用程序开发；ava ME（Java Micro Edition）小型版，支持 Java 程序运行在移动终端上的平台；Java Card，支持一些 Java 小程序（Applets）运行在小内存设备（如智能卡）上的平台。 "},{"title":"Java 语言的环境搭建​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-语言的环境搭建","content":"JRE（Java Runtime Environment，Java 运行环境）JDK（Java Development Kit，Java 开发工具包）   "},{"title":"开发体验——Hello World​","type":1,"pageTitle":"Java","url":"docs/notes/java/#开发体验hello-world","content":"编写 文件以.java为后缀以类为基本单位一个文件中只能由一个public类如果存在public类，则源代码文件名需要与类名相同程序的入口为固定写法，public static void main(String[] args) { /* ... */ }语句之间用分号分隔 编译，javac A.java运行，java 类名  "},{"title":"注释​","type":1,"pageTitle":"Java","url":"docs/notes/java/#注释","content":"单行注释，// 注释多行注释，/* 注释 */文档注释，/** @author Roddy */，可以用javadoc工具解析，生成代码文档 "},{"title":"Java API 文档​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-api-文档","content":"Java 8 中文版 - 在线 API 中文手册 - 码工具Overview (Java Platform SE 8 ) "},{"title":"Java 基本语法​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-基本语法","content":""},{"title":"关键字与保留字​","type":1,"pageTitle":"Java","url":"docs/notes/java/#关键字与保留字","content":"Java Language Keywords (The Java™ Tutorials &gt; Learning the Java Language &gt; Language Basics) 关键字（keyword）：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词）。关键字中所有字母都为小写。 保留字（reserverd word）：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。有两个goto、const。  "},{"title":"标识符​","type":1,"pageTitle":"Java","url":"docs/notes/java/#标识符","content":"命名规则​ Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符。 由 26 个英文字母大小写，0-9 、_或 $ 组成；数字不可以开头；不可以使用关键字和保留字，但能包含关键字和保留字；Java 中严格区分大小写，长度无限制；标识符不能包含空格。 命名规范​ 命名规范，不强制但是强烈建议。 包名：xxxyyyzzz类名、接口名：XxxYyyZzz变量名、方法名：xxxYyyZzz常量名：XXX_YYY_ZZZ "},{"title":"变量​","type":1,"pageTitle":"Java","url":"docs/notes/java/#变量","content":"概念​ 内存中的一个存储区域该区域的数据可以在同一类型范围内不断变化变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值。 作用​ 用于在内存中保存数据。 使用规则​ Java 中每个变量必须先声明，后使用使用变量名来访问这块区域的数据变量的作用域为其定义所在的一对{}内变量只有在其作用域内才有效同一个作用域内，不能定义重名的变量 变量分类​ 按类型分类​  @startmindmap * Java 数据类型 **: 基本数据类型 （primitive type）; *** 数值型 **** 整数类型（byte，short，int，long） **** 浮点类型（float，double） *** 字符型（char） *** 布尔型（boolean） **: 引用数据类型 （reference type）; *** 类（class） ****_ 字符串在这里 *** 接口（interface） *** 数组（[]） @endmindmap  按声明位置分类​ 成员变量：在方法体外，类内部声明的变量； 实例变量：没有static修饰的变量；类变量：有static修饰的变量。 局部变量：在方法体内部声明的变量。 变量的初始值​ 成员变量有初始值，局部变量没有初始值，需要显示初始化，不然不能通过编译检查。 数据类型\t默认值byte\t0 short\t0 int\t0 long\t0L float\t0.0F double\t0.0 char\t0（int类型）或'\\u0000' boolean\tfalse 引用类型\tnull 数据类型​   #\t数据类型\t占用存储空间\t表数范围\t备注1\tbyte\t1 字节\t[−128,127][-128,127][−128,127] 2\tshort\t2\t[−215,215−1][-2^{15},2^{15}-1][−215,215−1] 3\tint\t4\t[−232,232−1][-2^{32},2^{32}-1][−232,232−1]（约为 21 亿）\t默认的整数类型 4\tlong\t8 数字后面加l或L可声明为此类型 5\tfloat\t4\t尾数可以精确到 7 位有效数字\t后加f或F 6\tdouble\t8\t精度是float的两倍\t默认的浮点数字类型 7\tchar\t2\t\\u0000~\\uFFFF，即0~65535，无符号 16 位二进制数\t存储一个 Unicode 编码字符，用一对单引号''包括，可以用 Unicode 编码，比如'\\u00443' 8\tboolean 只可以在true或false两个字面量之间取值 浮点类型补充​ float 遵循 IEEE R32.24 规范，double 遵循 IEEE R64.53 规范。 无论是单精度还是双精度在存储中都分为三个部分： 符号位（Sign） ：0 代表正，1 代表为负指数位（Exponent）：用于存储科学计数法中的指数数据，并且要加上偏移量（float 偏移量 127，double 偏移量 1023）尾数部分（Mantissa）   注意： 浮点类型不精确，因为可能会舍弃存不下的位float 类型的表示范围比 long 类型的表示范围大 // TODO 补充浮点数知识 自动类型转换​ int a = 100; long b = a;   容量（表数范围/精度）小的类型在需要的时候会自动转为容量大的类型，不会丢失精度；有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算；byte、short、char之间不会相互转换，它们三种类型在计算时会首先转为int类型；boolean类型不会与其他类型转换；任何基本数据类型和Sting字符串在进行+运算时，基本数据类型会首先被转换为字符串类型，参与字符串拼接。 Unicode 与 ASCII​ char类型的变量在转换为int类型的时候会转换为对应 Unicode 编码的十进制值。Unicode 兼容 ASCII。 ASCII TableUnicode 14.0 Character Code Charts String​ String不是基本数据类型，而是引用数据类型，它是一个类；可以使用字面量方式声明，用双引号&quot;&quot;包括；也可以用new String()的方式创建对象；String在和+使用的时候意义为字符串拼接而不是加法，在和基本数据类型进行拼接运算时，基本数据类型会首先被转为String类型； 强制类型转换​ long a = 100L; int b = (int) a;  boolean类型不可以被转换为其他类型；如果想把更大容量/更高精度的类型转为小容量/低精度类型的时候可以用强制类型转换，有丢失精度的和数据的风险。 "},{"title":"进制​","type":1,"pageTitle":"Java","url":"docs/notes/java/#进制","content":"这是常用进制在 Java 中的声明方式。 进制\t开头二进制（Binary）\t0b或0B 八进制（Octal）\t0 十进制（Decimal） 十六进制（Hex）\t0x或0X "},{"title":"运算符​","type":1,"pageTitle":"Java","url":"docs/notes/java/#运算符","content":"算术运算符​  %的结果和前一个操作数的正负相同，与后一个操作数的正负无关；(a++)++是行不通的，编译错误。 赋值运算符​ =当两侧的数据类型不一致的时候，可以使用自动类型转换或强制类型转换处理支持连续赋值扩展赋值运算符，不会改变原有的数据类型 +=，a+=b &lt;=&gt; a=a+b-=*=/=%= short s = 3; s = s + 2; // 编译不通过 s += 2; // 不改变原来的数据类型  比较运算符​  比较运算符的结果都是boolean类型，要么是true，要么是false。 逻辑运算符​  位运算符​   位运算符对整数的二进制进行运算；&lt;&lt;左移一位相当于×2\\times2×2；&gt;&gt;右移一位相当于÷2\\div2÷2；没有无符号左移运算符&lt;&lt;&lt;；异或^在交换两个整数类型变量的值的时候有妙用，异或三次次即可交换值，不需要中间变量。 // 加减交换整数值 // 可能会超出 int 的范围 n1 = n1 + n2; n2 = n1 - n2; n1 = n1 - n2; // 用异或交换整数值 n1 = n1 ^ n2; n2 = n1 ^ n2; n1 = n1 ^ n2;  三元运算符​ （条件表达式） ? 表达式 1 : 表达式 2;  当条件表达式为true时，执行表达式 1，整个表达式的值为表达式 1 的结果；否则执行表达式 2，整个表达式的结果为表达式 2 的结果；表达式 1 和表达式 2 必须是同种类型。 运算符的优先级​  "},{"title":"程序流程控制​","type":1,"pageTitle":"Java","url":"docs/notes/java/#程序流程控制","content":"顺序结构​ Java 程序在整体上是顺序结构的，依据语句书写的顺序从前往后执行。 分支结构​ ifif-elseswitch-case switch表达式中的值必须是下面几种类型之一 byteshortintcharEnum（JDK 5）String（JDK 7） case子句的值必须是常量，不能是变量名或者不确定值的表达式；所有case字句的值应该互斥；break关键字用于跳出switch结构，如果没有使用break则会接着向下执行，意味着可以匹配多个case；default子句是可选的，位置也是灵活的（不一定要写在case语句之后），在没有匹配到case语句时会执行default子句中的表达式；如果default语句写在case语句之前，并且没有break，在匹配default语句之后还会向下执行case里的语句，直到遇到break或者执行完毕。这是一个很反直觉的行为，所以default子句尽量写在最后，并且如果不是特殊情况下，每条case语句都应包含一个break。 循环结构​ forwhiledo-while "},{"title":"数组​","type":1,"pageTitle":"Java","url":"docs/notes/java/#数组","content":""},{"title":"数组的概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/#数组的概述","content":"数组（Array）是多个相同数据类型按一定顺序排列的集合。 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型；数组在内存中是一整块连续的空间，数组名引用的是这块连续空间的首地址；数组的长度一旦确定就不能修改。 "},{"title":"一维数组​","type":1,"pageTitle":"Java","url":"docs/notes/java/#一维数组","content":"声明​ int a[]; int[] a;  动态初始化​ int[] arr = new int[3]; arr[0] = 3;  静态初始化​ int[] arr = new int[]{1, 2, 3}; // 类型推断 int[] arr = {1, 2, 3};  默认值​ 数组成员具有默认值，和成员变量的初始值规则相同。不管是通过动态初始化还是静态初始化的方式来初始化数组，数组成员都有默认值，不过通过静态初始化方式初始化之后，数组成员的值又立刻被修改了一次。 "},{"title":"多维数组的使用​","type":1,"pageTitle":"Java","url":"docs/notes/java/#多维数组的使用","content":"声明​ int arr[][]; int [][] arr; // 也可以这样写 int[] arr[]，也是二维数组的声明 int[] arr[] = new int[3][3]; // 注意特殊写法 // x 是一维数组，y 是二维数组 int[] x, y[];  动态初始化​ int arr[][] = new int[3][2]; arr[0][1] = 2;  // 后面的可以先不初始化 int arr[][] = new int[3][]; arr[0] = new int[3]; arr[0][2] = 1; // 多维数组不必是规则矩阵形式 arr[1] = new int[2]; arr[1][1] = 2;  静态初始化​ int[][] arr = new int[][]{{1, 1, 1}, {2, 2, 2}, {3, 3, 3}}; // 类型推断 int[][] arr = {{1, 1, 1}, {2, 2, 2}, {3, 3, 3}};  "},{"title":"面向对象编程​","type":1,"pageTitle":"Java","url":"docs/notes/java/#面向对象编程","content":""},{"title":"面向过程与面向对象​","type":1,"pageTitle":"Java","url":"docs/notes/java/#面向过程与面向对象","content":"面向过程编程（Procedure Oriented Programming，POP），以函数为最小单位，考虑怎么做； 面向对象编程（Object Oriented Programming, OOP），以类/对象为最小单位，考虑谁来做。 "},{"title":"面向对象的三大特征​","type":1,"pageTitle":"Java","url":"docs/notes/java/#面向对象的三大特征","content":"封装（Encapsulation）​ 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的安全性、可扩展性和可维护性。 修饰符\t同一个类\t同一个包\t不同包的子类\t同一个工程private\t✅ （空）\t✅\t✅ protected\t✅\t✅\t✅ public\t✅\t✅\t✅\t✅ 在修饰class时只能用public或者空修饰符。 继承（Inheritance）​ 子类继承了父类，就继承了父类的所有方法和属性。但是父类中的private成员进行了隐藏，不能直接访问。 父类中的成员，无论是公有还是私有，均被子类继承。只是因为访问控制修饰符的原因，子类不能对继承的私有成员直接进行访问。 子类不会继承父类的构造器，但是一定会调用父类的构造器。 Java 中只能实现单继承。 Java 中所有的类都直接或间接继承自Object类。 子类可以根据需要方法重写（Overwrite）。 子类中的方法和父类中的方法必须有相同的名称和参数列表；子类方法的返回值类型不能大于父类方法的返回值类型；子类方法的访问权限不能小于父类方法的访问权限； 父类中的private方法不能被重写，但是可以在子类中声明相同方法签名的方法，不称为重写；父类中的static方法也不能被重写，可以重新声明。 子类方法抛出的异常不能大于父类方法的异常。 多态（Polymorphism）​ 编译时和运行时对象类型不一致，就出现了对象的多态性。子类对象可以替代父类对象使用。 编译时，看左边（类型声明）；运行时，看右边（对象实例）。 多态不适用于属性，属性是在编译器确定的，运行时也看左边。 意味着方法会被完全覆盖，但是属性不会被覆盖。但是依然可以在子类内部通过super关键字调用直接父类中被覆盖的方法。 可以通过向上转型和向下转型来使用继承树中各个类的属性和方法。 instanceof运算符用来判断某一个对象是否是某个类或该类子类的实例，返回true或false。 java.lang.Object#getClass方法可以获取对象的运行时类名。 抽象​ 也算是面向对象的特征之一，如果有人问的话。 "},{"title":"类和对象​","type":1,"pageTitle":"Java","url":"docs/notes/java/#类和对象","content":"类（Class）是对一类事物的描述，是抽象的、概念上的定义； 对象（Object）是实际存在的该类事物的每个个体，也称为实例（Instance）。 "},{"title":"类的成员​","type":1,"pageTitle":"Java","url":"docs/notes/java/#类的成员","content":"属性​ 属性（Field）又称为成员变量，分为实例变量（没有static修饰）和类变量（有static修饰）。 方法​ 方法的重载（Overload）指的是在同一个类内同名但是参数列表不完全相同的多个方法； 方法的重写（Overwrite）指的是在子类中对父类中已有的方法进行重新实现，方法的签名相同（返回值和抛出的异常范围可以更小）。 参数的值传递：对于基本数据类型，形参（方法内可以操作的参数）就是实参的复制，对形参的改变不会影响到实参；对于引用数据类型，形参是实参内存地址的复制，对形参直接修改不会影响到实参，通过形参名指向的内存地址对该对象/数组内的成员进行操作实际上就是对实参的操作。 构造器​ 没有返回值 在创建对象的时候自动执行 可以用public/protected/private修饰 protected的构造器只能在当前包内用，其它地方不能new这个对象private的构造器只能在类内部用，不能在外部用，常用于单例模式 构造器不是方法 构造器不能被继承 代码块​ 代码块中的变量都是局部变量。 内部类​ 在 Java 中，允许在在类中定义类结构，称为内部类。内部类的名称不能与外部类的名称相同。 可以被以下关键词修饰： staticfinalabstract成员内部类可以被四种不同的权限修饰符修饰 成员内部类​ 静态内部类 可以调用外部类的静态成员，包括私有的；在外部可以直接实例化；静态内部类不会随着外部类的初始化而初始化，只有在用到的时候才会被初始化，静态内部类内的静态代码块不会随着外部类的初始化而执行。 InnerClassTest.StaticA staticA = new InnerClassTest.StaticA();  非静态内部类 可以调用外部的非静态成员，相当于外部类类名。this. 成员，包括私有的；在内部类中this指向自身，外部类类名。this可以访问外部类的this；在外部实例化非静态内部类时需要先实例化外部类，通过外部类实例化内部类。 A.B.C c = new InnerClassTest().new A().new B().new C();  局部内部类​ 定义在方法中。 局部内部类可以使用外部方法的局部变量，但是该变量必须是final的，Java 8 中在局部内部类使用的外部局部变量会自动声明为final的 Java 8 之前需要手动声明。由局部内部类和局部变量的不同生命周期所致；不能使用权限修饰符，和局部变量一样；不能使用static修饰，因此也不能包含静态成员。 匿名内部类​ 匿名内部类必须继承父类或实现接口匿名内部类只有一个对象匿名内部类的对象只能用多态形式引用 "},{"title":"关键字​","type":1,"pageTitle":"Java","url":"docs/notes/java/#关键字","content":"class​ 用于定义类，只能用public或者空权限修饰符。 this​ 实例本身的引用；在构造器中代表正在初始化的对象；可以在构造器中调用其它重载的构造器，必须放在构造器代码块的首行。 super​ 用于显式调用继承来的成员（成员变量/方法）；用于调用直接父类的构造器，必须在子类的构造器中使用，必须在代码块的第一行； static​ static可以用来修饰： 属性方法代码块内部类 被修饰的成员有以下特点： 随着类的加载而加载，只会加载一次优先于对象存在修饰的成员被所有该类的对象共享访问权限允许时，可以不创建对象，直接通过类名调用 final​ final可以用来修饰： 类，表示该类不能被继承方法，表示该方法不能被重写成员变量，表示该变量的值不能被修改，即为常量，必须在声明时赋值或者在构造器中赋值局部变量形参，表明形参在方法的代码块内不能被修改 abstract​ abstract可以用来修饰： 类，抽象类 抽象类不能被实例化，必须有子类继承它并且实现所有的抽象方法之后才能实例化子类如果子类没有重写所有的抽象方法，子类也必须声明为抽象类，含有抽象方法的类必须声明为抽象类不能用abstract修饰final类抽象类可以有构造器 方法，抽象方法 含有抽象方法的类必须声明为抽象类不能用abstract修饰private方法、静态方法、final方法 interface​ 用于定义接口。 接口的思想就是定义了规范，继承是「是不是」的关系，而接口是「能不能」的关系。 接口的所有成员变量默认都是public static final修饰的接口中的所有方法都默认都是public abstract修饰的接口没有构造器一个类可以实现多个接口接口也可以实现其它接口接口与实现类之间也可以表现出多态的特性 Java 8 中对接口的增强： 静态方法默认方法 如果实现了接口并继承了一个类，并且接口中有默认方法和类中的方法同名同参数列表，则接口中的默认方法会被忽略，遵循类优先原则，子类在通过super调用父类方法的时候会调用类中的方法而不是接口中的默认方法，如果需要调用接口中的默认方法可以通过接口名。super. 方法名 ()来调用。 public class InterfaceTest { public static void main(String[] args) { new C().a(); } } interface A { default void a() { System.out.println(&quot;a&quot;); } } abstract class B { public void a() { System.out.println(&quot;b&quot;); } } class C extends B implements A { @Override public void a() { super.a(); A.super.a(); } }  接口可以完全取代抽象类吗？ 不能，抽象类有类的结构，比如说构造器，抽象类可以私有的成员；接口中只能定义public的成员。抽象类可以实现更多细节，接口更轻量。能用接口实现的就尽量用接口，不能用接口实现的采用抽象类。 package​ 指明本源文件中定义的类所在的包。 import​ import用于声明本源文件中用到的外部类的包位置。 java.lang包下的类不需要声明，可以直接用。 import static用于引入外部的静态成员（静态变量/静态方法），可以直接在本源文件中通过名称调用，不用再加上其所在的类名。 native​ 用来修饰方法，表明该方法不是用 Java 语言实现的，而是用底层的 C 语言或者 C++ 实现的。 "},{"title":"类的初始化顺序​","type":1,"pageTitle":"Java","url":"docs/notes/java/#类的初始化顺序","content":"在编译后的字节码文件中不存在构造器，转而出现了&lt;init&gt;()方法，该方法包括： 代码块中的代码显示赋值的代码构造器中的代码 其中 1 和 2 的执行顺序与代码的实际顺序相同，构造器中的代码总是最后执行。 &lt;init&gt;()方法的数量与构造函数的数量相同，调用构造方法实际上就是调用了对应的该方法。 也不存在代码块了，代码块中的代码都拷贝到每个&lt;init&gt;()方法中了。显示赋值也消失了，也同时放在该方法中执行。执行顺序与源码中的书写顺序一致。 最后才是构造器中原有的代码执行。 在有继承的情况下，先在父类中按照此顺序执行，然后再到子类中按照此顺序执行。 如果子类重写了父类的方法，则会调用子类中的该方法而不是父类中的方法。 静态代码块在类初始化的时候执行，所以优先级最高。 父类：成员变量之前的静态代码块父类：成员变量之后的静态代码块子类：成员变量之前的静态代码块子类：成员变量之后的静态代码块父类：成员变量之前的代码块父类：显式赋值父类：成员变量之后的代码块父类：构造方法子类：成员变量之前的代码块子类：显式赋值子类：成员变量之后的代码块子类：构造方法 "},{"title":"异常处理​","type":1,"pageTitle":"Java","url":"docs/notes/java/#异常处理","content":""},{"title":"异常概述​","type":1,"pageTitle":"Java","url":"docs/notes/java/#异常概述","content":"程序执行中发生的不正常情况称为「异常」。开发过程中的语法错误和逻辑错误不属于异常。 "},{"title":"异常体系结构​","type":1,"pageTitle":"Java","url":"docs/notes/java/#异常体系结构","content":" Throwable是所有异常的公共父类，只有此类才能被抛出或者抓取。 Error，Java 虚拟机无法解决的严重的问题，如 JVM 内部系统严重错误、资源耗尽等严重情况等，一般不编写针对性的代码进行处理，捕获了也没用，应该从其它方面解决这些问题；Exception，其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。 RuntimeException，运行时异常，不建议捕获，应该尽量避免。因为这些异常发生比较频繁，如果在代码中显示捕获的话不利于阅读；其它异常，在编译时就能发现并且必须处理的异常，要么捕获，要么一直抛出到最上级。 "},{"title":"常见异常​","type":1,"pageTitle":"Java","url":"docs/notes/java/#常见异常","content":""},{"title":"异常处理机制​","type":1,"pageTitle":"Java","url":"docs/notes/java/#异常处理机制","content":"try-catch-finally​ try 包裹可能发生异常的代码块。如果出现异常就会在当前执行的语句处中断。如果在catch中捕获了该类型的异常就会跳转到对应的catch代码块。如果显式抛出异常则当前方法中断，异常交给调用者处理。如果都没有则程序中断。 catch 捕获某种类型的异常，可以多个catch并列，在捕获到异常之后进行对应处理。 finaly 不管有没有发生异常，该代码段都会执行，通常用于资源清理工作，确保无论何时资源都能被正常关闭。如果该代码块里使用了return语句，那么在try或者catch代码块里的 return语句将失效，因为在执行 try代码块里的return语句之前会先执行finally代码段里的return，然后方法就终止了。还有需要注意的是，如果在finally代码块里没有return语句的情况下，修改返回变量的值是无效的，在执行finally代码块之前就已经将返回值给到return处了，再执行return的时候不会拿最新的变量值，类似于i++的机制。 try-with-resoucees​ Java 8 引入，实现AutoCloseable接口的资源可以放在try后面的括号里初始化，在之后会自动关闭；多个资源之间用分号分隔。 Java 9 增强，资源可以不在括号中初始化，在其中声明即可。 try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } catch { }  throws​ 写在参数列表之后，方法体之前。表明当前方法可能会抛出异常的类型，这些异常不会在该方法内被处理。告知调用者在使用此方法的时候应该对这些异常进行处理，要么捕获要么再抛出。 throw​ 在方法体内中使用，主动抛出一个异常，终止该方法。 如果是一个编译时异常就需要在throws后声明，如果是运行时异常就不用声明。 "},{"title":"自定义异常​","type":1,"pageTitle":"Java","url":"docs/notes/java/#自定义异常","content":"从Exception或者它的子类派生出一个新类即可。 "},{"title":"多线程​","type":1,"pageTitle":"Java","url":"docs/notes/java/#多线程","content":""},{"title":"多线程基本概念​","type":1,"pageTitle":"Java","url":"docs/notes/java/#多线程基本概念","content":"程序（Program）是一段有序执行的静态代码的集合；进程（Process）是程序的一次执行过程，有生命周期；线程（Thread）是进程的进一步细分，比进程更轻量化，在线程之间切换的开销更小，效率更高，多个线程可以共享相同的内存区域。 一个 Java 程序至少有三个线程：主线程、垃圾回收线程和异常处理线程。 并行：多个 CPU 同时执行多个任务；并发：一个 CPU 采用时间片同时执行多个任务。 "},{"title":"线程的创建和使用​","type":1,"pageTitle":"Java","url":"docs/notes/java/#线程的创建和使用","content":"继承 Thread 类​ 从 Thread 类中派生出一个新类，重写run方法；创建线程类的对象，调用start方法，Java 会新开一个线程，执行run方法。 实现 Runnable 接口​ 新类，实现 Runnable 接口，重写run方法；还是通过Thread类来执行，它有一个构造方法接收Runnable类型的参数；调用Thread对象的start方法来启动线程。 Callable 和 FutureTask​ Java 5 新增，可以获得线程运行完毕之后的结果，返回值具有泛型支持。 新类，实现Callable接口，重写call()方法。 用FutureTask套Callable，再用Thread套FutureTask。 可以用FutureTask的get()方法获取返回值，这个方法会一直阻塞直到得到结果。 CallableDemo cd = new CallableDemo(); FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(cd); new Thread(task).start(); log.info(&quot;Task started.&quot;); String result = task.get(); log.info(&quot;Result got： {}&quot;, result);  线程池​ Java 5 中提供的线程池 API，ExecutorService和Executors。 可以手动创建线程池。 ExecutorService是接口，常见子类有ThreadPoolExecutor。 也可以使用Executors工具类来创建预先定义好设置的线程池。 Executors.newCachedThreadPool()newFixedThreadPool()newSingleThreadPool()newScheduledThreadPool() 创建线程池之后会拿到一个ExecutorService接口的对象，其实现类为ThreadPoolExecutor，其中有两个方法可以提交新任务。 submit(Runnable task)执行成功返回nullsubmit(Callable&lt;T&gt; task)有返回值execute(Runnable command)无返回值 "},{"title":"Thread 类中的常用方法​","type":1,"pageTitle":"Java","url":"docs/notes/java/#thread-类中的常用方法","content":"run要求子类重写，它的方法体也成为线程体start线程启动sleep(long millis)阻塞线程getName获取线程名称，默认是自动生成的，也可以在实例化对象的时候传递给构造器setName设置线程名称static currentThread获取当前线程的实例getPriority获取线程优先级，默认线程的优先级和它被创建的线程的优先级相同，主线程的默认优先级是 5setPriority设置线程优先级，范围为[1,10][1,10][1,10]，越大约高，但是执行时间还得看系统的调度策略checkAccess判断当前线程有没有权限修改目标线程stop()废弃的中断线程方法interrupt中断线程，如果在线程外部中断要确保有权限修改该线程。如果线程被其它方法阻塞的时候中断还会抛出异常join在线程外执行，阻塞当前线程，一直等到该线程执行完毕yeld放弃本次 CPU 时间 "},{"title":"线程的生命周期​","type":1,"pageTitle":"Java","url":"docs/notes/java/#线程的生命周期","content":"以下是操作系统概念中的线程的生命周期。 状态名\t解释\t触发条件创建\t新建但未开始\t在生成线程对象，并没有调用该对象的start()方法 就绪\t处于就绪队列\tstart()之后，但未获得 CPU 时间片 运行\t正在执行\t获得 CPU 时间片 阻塞\t处于阻塞队列\t等待资源、wait()、sleep()、suspend() 死亡\t执行完毕\trun()方法运行完毕或者调用stop()方法  JDK 中用枚举类Thread.State定义了线程的几种状态。 状态名\t解释\t触发条件NEW\t新建但未开始\tnew之后，start()之前 RUNNABLE\t可运行\t正在运行或者处于就绪队列 BLOCKED\t阻塞\t等待监视器锁或者调用wait() WAITTING\t等待\twait() TIMED_WAITTING\t可自行返回的等待状态\tsleep()、带时间的wait()、带时间的join() TERMINATED\t执行完毕\trun()方法运行完毕或者调用stop()方法 "},{"title":"线程的同步​","type":1,"pageTitle":"Java","url":"docs/notes/java/#线程的同步","content":"同步代码块​ synchronized（锁对象）{}  规定一段代码，在任何时刻只能有一个对象运行。在运行之前会检查锁对象是否已加锁，如果没有，在运行的时候就给锁对象加锁，运行结束之前解锁。 关于锁对象，要确保它在每个实例中是同一个对象。以继承Thread方式创建的线程中就不能使用this作为锁对象，因为每个实例中的Thread对象不同；以实现Runnable接口方式创建的线程可以使用this作为锁对象，因为在创建线程的时候可以只有一个该类的实例，然后通过这唯一的实例去创建线程。并且在后一种方式中，所有线程共享数据，不需要用static修饰。 同步方法​ 用synchronized修饰方法，同一时刻只能有一个线程执行此方法。 同步方法无法自己选择锁对象。对于非静态方法，锁对象是this；对于静态方法，锁对象是当前类的Class对象。使用的时候就要判断锁对象合不合适。 Lock​ 在 Java 5 之后提供了一种新的方式来确保线程安全，可以通过显式定义同步锁对象来实现同步。 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。ReentrantLock是该接口的实现类。  "},{"title":"线程的通信​","type":1,"pageTitle":"Java","url":"docs/notes/java/#线程的通信","content":"在 Object 类中定义了一些方法。 wait在被手动唤醒之前一直暂停此线程，必须由锁对象（线程监视器对象）来调用notify唤醒一个正在等待的线程，从上次暂停的地方继续执行notifyAll唤醒所有正在等待的线程，在多个生产者和多个消费者的时候注意用 wait()和sleep() Object.wait()会释放锁，Thread.sleep()不会释放锁。 生产者和消费者问题。 package org.example.thread_test; import lombok.extern.slf4j.Slf4j; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ProducerConsumerTest { public static void main(String[] args) { ExecutorService pool = Executors.newFixedThreadPool(7); Clerk clerk = new Clerk(); Producer producer = new Producer(clerk); Consumer consumer = new Consumer(clerk); pool.execute(producer); pool.execute(consumer); pool.shutdown(); } } @Slf4j class Producer implements Runnable { private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { clerk.add(); } } } @Slf4j class Consumer implements Runnable { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { clerk.minus(); } } } @Slf4j class Clerk { private int count = 0; public static final int MAX = 20; public synchronized void add() { try { Thread.sleep(100L); } catch (InterruptedException e) { e.printStackTrace(); } if (count &lt; MAX) { log.info(&quot;生产 1，剩余 {}&quot;, ++count); notify(); } else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } public synchronized void minus() { try { Thread.sleep(100L); } catch (InterruptedException e) { e.printStackTrace(); } if (count &gt; 0) { log.info(&quot;消费 1，剩余 {}&quot;, --count); notify(); } else { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } }  "},{"title":"懒汉单例模式的线程安全问题​","type":1,"pageTitle":"Java","url":"docs/notes/java/#懒汉单例模式的线程安全问题","content":"常规方法，使创建对象的操作互斥，只允许创建一个对象。 class Lazy { private static Lazy INSTANCE; private Lazy() { } public static Lazy getInstance() { if (INSTANCE == null) { // 外层判断为了提高效率 // 当内层已经创建好对象之后，其它线程和创建对象的线程就不是竞争关系了 // 可以直接去取已经创建好的实例 synchronized (Lazy.class) { if (INSTANCE == null) { // 内层判断为了安全 INSTANCE = new Lazy(); } } } return INSTANCE; } }  还有一种更简单的方法，利用内部类不会随着外部类的初始化而初始化的特点，完成懒汉单例。 class SimpleLazy { private SimpleLazy() { } public static SimpleLazy getInstance() { return Inner.INSTANCE; } // 内部类不会随着外部类的初始化而初始化 // 静态代码不会随着外部类的初始化而执行 // 而是在使用的时候才会初始化 private static class Inner { public static final SimpleLazy INSTANCE = new SimpleLazy(); } }  "},{"title":"ThreadLocal​","type":1,"pageTitle":"Java","url":"docs/notes/java/#threadlocal","content":"数据容器，和线程绑定。每个线程得到的值不一样。 "},{"title":"枚举类​","type":1,"pageTitle":"Java","url":"docs/notes/java/#枚举类","content":"Java 5 之后，有了enum关键字，可以更方便地实现枚举类。 枚举类型不能继承其它类型，因为枚举类型的每个实例实际上继承了java.lang.Enum抽象类。 protected Enum(String name, int ordinal); public final String name(); public final int ordinal();  在编译的时候编译器会将enum真正转化为Enum的子类，所以可以使用该类的方法。 并且Enum类重写了toString()方法，默认返回name属性值。 Enum类中还有一个静态方法valueOf，可以获取对应值的枚举类实例。 public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name)  还有一个values方法不是继承的，而是编译器添加的。它存在于每个枚举类中，能获取到该类的对应值的枚举类实例。 public static T[] values()  枚举类可以实现接口，并且每个常量可以分别对接口有不同的实现。也可以统一实现接口，跟正常用法一样。 public class Test6 { public static void main(String[] args) { MyEnum.A.test(); // a MyEnum.B.test(); // b MyEnum.C.test(); // 统一实现 } } interface MyInterface { void test(); } enum MyEnum implements MyInterface { A { @Override public void test() { System.out.println(&quot;a&quot;); } }, B { @Override public void test() { System.out.println(&quot;b&quot;); } }, C; @Override public void test() { System.out.println(&quot;统一实现&quot;); } }  "},{"title":"注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/#注解","content":"其实也是一种注释，是代码级别的注释，会被编译器处理。普通注释会被编译器直接忽略。不直接修改程序逻辑，可以通过反射读取出注解信息，根据需要作出不同行为。 "},{"title":"预定义注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/#预定义注解","content":"@Override，标注在方法上，在编译时会检查这个方法是否符合重写的要求，一定确保这个方法成功重写了父类的方法。给程序员看的时候也能快速看出这是一个重写的方法。@Deprecated，标注方法，表明该方法已弃用，有更好的实现供选择。@SuppressWarnings，抑制编译时的警告信息，可以作用在类、类成员、方法参数等。会抑制在该类型作用域内的所有警告信息。value参数可以传入具体抑制哪种警告，或者传入「all」抑制所有警告信息。 "},{"title":"文档注释相关注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/#文档注释相关注解","content":"@author@param@return@see@since@version@exception@throws... "},{"title":"自定义注解​","type":1,"pageTitle":"Java","url":"docs/notes/java/#自定义注解","content":"定义注解​ 属性的数据类型有限制： 基本数据类型String枚举ClassAnnotaion以上这些类型的数组 属性可以有默认值，可以通过default关键字来实现。 @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface Test7 { String value() default &quot;111&quot;; String[] name(); }  元注解​ 标注在注解声明处的注解。 @Target指明注解可以标注的位置。@Retention指明注解的生命周期。 SOURCE只在源码阶段有效，就跟普通的注释一样，编译的时候丢弃CLASS在编译的时候会保存到字节码文件中，但是虚拟机不会在运行时保留，默认是这个级别RUNTIME会在运行时保留，可以通过反射读取 @Documented被 javadoc 读取。@Inherited继承的时候也会继承到注解。 使用​ 在合适位置标注，以@开头。 如果注解没有属性，不需要加括号。 如果注解只需传入一个value属性，则直接传入属性即可。 如果需要传入的属性有多个，或者传入的单个属性不是value，则需要使用键值对的形式传入对应的值。 如果传入的属性要求是数组，在数组只有一个元素的情况下可以省略花括号{}。 @Test7(value = &quot;&quot;, name = &quot;&quot;) @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface Test7 { String value(); String[] name(); }  读取​ 参考反射相关知识。 "},{"title":"Java 8 注解新特性​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-8-注解新特性","content":"@Repeatable可重复注解​ 在 JDK8 之前如果需要重复注解的话，需要新建一个注解，其中包含目标注解的数组，通过数组来重复使用注解。 在 JDK8 中新增了一个元注解@Repeatable，还是需要一个新的注解包含目标注解的数组，但是不需要用数组的方式传递了，直接标注多个同类型的注解即可。 类型注解​ @Target的参数ElementType的枚举值多了两个： TYPE_PARAMETER：表明注解可以使用在类型变量的声明语句中，如泛型声明；TYPE_USE：表示注解能使用在任何类型的语句中，泛型、变量类型转换、抛出的异常。 "},{"title":"常用类​","type":1,"pageTitle":"Java","url":"docs/notes/java/#常用类","content":""},{"title":"Object​","type":1,"pageTitle":"Java","url":"docs/notes/java/#object","content":"Object是所有类的根父类。 equals，比较两个对象，默认行为和比较运算符==相同，都是比较内存地址，子类可以根据需要对该方法进行重写，对内容进行比对；hashCode，默认根据内存地址计算对象的哈希值，如果重写了equals方法则原则上需要重写此方法；clone，返回对象的复制，是一个protected方法，子类需要重写此方法并调用super.clone()，也可以自己实现克隆细节，并实现Cloneable接口；finalize，在对象被回收之前垃圾回收器会调用此方法，子类可以重写此方法来在被回收之前做一些事情；可以通过System.gc()或Runtime.getRuntime().gc()来通知垃圾回收器进行回收，但是否会进行回收是不确定的；toString，返回对象的字符串表示，建议所有子类重写。默认返回「类名 @十六进制 hash」。getClass，获取当前对象的运行时类名。 "},{"title":"包装类​","type":1,"pageTitle":"Java","url":"docs/notes/java/#包装类","content":"Java 提供了 8 种基本数据类型的包装类，使得基本数据类型的变量具有类的特征。 基本数据类型\t包装类byte\tByte short\tShort int\tInteger long\tLong float\tFloat double\tDouble boolean\tBoolean char\tCharacter 其中，Byte、Short、Integer、Long、Float和Double都是Number的子类。 自动装箱与自动拆箱​ JDK 1.5 提供的自动拆箱和自动封箱的机制可以让基本数据类型和包装类自动转换。在需要的时候，自动在基本数据类型和包装类之间转换。 Integer a = 5; int b = a;`  缓存​ 为了提高性能，比较常用的基本数据类型的包装类会被缓存。 通过new关键字获取的对象在堆中，直接得到的包装类在方法区中，这个才是被缓存的。 基本数据类型\t包装类\t缓存byte\tByte\t[−128,127][-128,127][−128,127] short\tShort\t[−128,127][-128,127][−128,127] int\tInteger\t[−128,127][-128,127][−128,127] long\tLong\t[−128,127][-128,127][−128,127] float\tFloat\t不缓存 double\tDouble\t不缓存 char\tCharacter\t[0,127][0,127][0,127] boolean\tBoolean\ttrue和false 常用 API​ 字符串解析​ 各个包装类都有一个parseXxx的方法，用于从字符串中解析出对应类型的值，返回包装类。 public static int parseInt(String s) throws NumberFormatException  Integer​ MAX_VALUEint 类型可表示的最大值，2^{31}-1231−1MIN_VALUE最小值，-2^{31}−231toBinaryString转为二进制字符串toOctalString八进制toHexString十六进制 Character​ toUpperCasetoLowerCase "},{"title":"System​","type":1,"pageTitle":"Java","url":"docs/notes/java/#system","content":"包含三个流： PrintStream outInputStream inPrintStream err 这是系统默认的输出流，可以通过setIn、SetOut、SetErr来替换掉系统默认的输出流。 常用方法： currentTimeMillis()arraycopy(Object src, int srcPos, Object dest, int destPos, int length)exit(int status)getProperty(String key) "},{"title":"String​","type":1,"pageTitle":"Java","url":"docs/notes/java/#string-1","content":"与基本数据类型的转换​ String-&gt;基本数据类型 使用各个包装类的方法，使用的时候注意可能会抛出异常 Integer.parseInt()Float.parseFloat() 基本数据类型-&gt;String String.valueOf()使用连接运算符+，1 + &quot;&quot; = &quot;1&quot; 特殊性​ 通过字面量声明的 String 对象存在常量池中，是不可变的，只要修改了字符串就会产生新对象。通过new关键字取得的字符串对象不在常量池中。 常量池里的对象可以共享，提高性能。 常量池位置​ Java 6，在方法区； Java 7，在堆中专门划分了一块区域来存储字符串常量； Java 8，在元空间（Meta space）中，类似于方法区，甚至可以独立于 JVM 存在。 底层存储结构​ Java 8，使用char[]存储； Java 9，使用byte[]存储。 不可变性​ char[]使用final修饰，意味着数组不能扩容。同时它也是私有的，外部也不能修改某一个元素的值；String 提供的所有对字符串修改的方法都会返回一个新对象。 字面量和直接创建对象的不同​ String str = new String(&quot;str&quot;);  在这个过程中产生了两个对象；&quot;str&quot;是一个对象，在常量池；又通过new关键字得到一个对象，在堆。两者的char values[]指向相同的地址。具体代码在 String 的构造器中。 拼接​ String s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; String s3 = &quot;helloworld&quot;; String s4 = s1 + &quot;world&quot;; String s5 = s1 + s2; String s6 = &quot;hello&quot; + &quot;world&quot;; System.out.println(s3 == s4); // false System.out.println(s3 == s5); // false System.out.println(s3 == s6); // true  只要有变量参与的拼接，结果都在堆中。s6在编译期间就可以确定结果，所以存在常量池中。 如果给 s1 和 s2 加上final修饰，那么结果都为true。 常用方法​ equals(Object anObject)equalsIgnoreCase(String anotherString)compareTo(String anotherString)compareToIgnoreCase(String str)intern()把字符串放入常量池，并返回引用length()isEmpty()concat(String str)与另一个字符串相连接，相当于+trim()移除开头和结尾的空白字符substring(begin, end)返回子字符串，索引从 0 开始，包含包含左边不包含右边。左闭右开toCharArray()转为字符数组getBytes()转为字节数组 字典排序​ String 实现了Comparable接口，但是默认是按照 Unicode 编码值排序。 java.lang.Collator类实现了Comparator接口，可以选择各地的语言习惯来排序。 在有拼音排序的需求的时候可以采用这个方法来实现。 Collator collator = Collator.getInstance(Locale.CHINESE); int compare = collator.compare(&quot;差&quot;, &quot;啊&quot;); System.out.println(compare);  "},{"title":"StringBuffer​","type":1,"pageTitle":"Java","url":"docs/notes/java/#stringbuffer","content":"可变字符序列。线程安全。效率更低。而StringBuilder相反。默认容量是 16。 没有重写equals方法，比较的是内存地址。 "},{"title":"StringBuilder​","type":1,"pageTitle":"Java","url":"docs/notes/java/#stringbuilder","content":"可变字符序列，Java 5 新增，非线程安全。默认长度是 16，在需要的时候会自动扩容到原来长度的 2 倍再加上 2。 没有重写equals方法，比较的是内存地址。 appendinsertdelete "},{"title":"Math​","type":1,"pageTitle":"Java","url":"docs/notes/java/#math","content":"abs绝对值三角函数sqrt平方根pow幂运算round四舍五入ceil返回比参数大的最近一个整数floor返回比参数小的最近一个整数 "},{"title":"Random​","type":1,"pageTitle":"Java","url":"docs/notes/java/#random","content":"nextInt(int)，随机返回一个在[0,i−1][0,i-1][0,i−1]之间的数。 // 返回一个 [left, right] 之间的数 public static int randomInt(int left, int right) { Random random = new Random(); return random.nextInt(right - left + 1) + left; }  "},{"title":"BigInteger​","type":1,"pageTitle":"Java","url":"docs/notes/java/#biginteger","content":"支持更大的范围，多了一些运算方法。 "},{"title":"BigDecimal​","type":1,"pageTitle":"Java","url":"docs/notes/java/#bigdecimal","content":"精度更高。注意 buyo addsubtractmultiplydivide "},{"title":"日期时间​","type":1,"pageTitle":"Java","url":"docs/notes/java/#日期时间","content":""},{"title":"旧日期时间​","type":1,"pageTitle":"Java","url":"docs/notes/java/#旧日期时间","content":"Date​ 除了下面两个构造器，其它的都过时了。 Date()当前日期获得对象Date(long date)毫秒时间戳转为日期 其中大部分方法也已经过时，可以被Calendar或者DateFormat中的方法替换。 java.sql.Date是 java.util.Date的子类，无特殊需要的情况下均用java.util.Date。 Calendar​ 这是一个抽象类，可以使用它的实现类GregorianCalendar。可以通过Calendar.getInstance()来获取它的实例。 getInstance()获取实现类的实例getInstance(Locale aLocale)getInstance(TimeZone zone)get(int field)通过常量值来获取当前日历对象的某个字段值，比如年份 TimeZone​ 抽象类，可以用静态方法getTimeZone来获取实现类的实例。 getTimeZone(String ID)getAvailableIDs()获取所有时区 id DateFormat​ 这也是一个抽象类，用的是SimpleDateFormat。 SimpleDateFormat(String pattern)构造器，出入格式化字符串format(Date date)将日期对象格式化，返回字符串parse(String source)按照格式将字符串解析为日期对象 "},{"title":"新日期时间​","type":1,"pageTitle":"Java","url":"docs/notes/java/#新日期时间","content":"Java 8 引入了新的日期时间 API。新的对象是不可变的，修改会产生新对象。 新引入了另一套处理日期时间的体系，Date 可以通过toInstant()方法转为新 API。 LocalDate​ yyyy-MM-dd格式的日期。 LocalTime​ 只有时间。 LocalDateTime​ 日期时间。 static now()基于现在的时间创建对象static of()给定日期时间创建对象getMonthgetXxxwithMonth修改月份并返回一个新对象withXxxplusXxx加时间minusXxx减时间isLeapYear是否是闰年format格式化，返回字符串static parse给定字符串和格式解析为时间对象 Duration​ 时间之间的间隔。更精确。 Period​ 日期之间的间隔。 Instant​ 瞬时时间。可以精确到纳秒。从 1970 年的开始算的。没有其它任何上下文信息。 ZonedDateTime​ 带时区的时间。 TemporalAdjuster​ 时间调整期，这是一个接口。在TemporalAdjusters中有许多方法可以得到它的实例。 DateTimeFormatter​ 格式化器。可以用来格式化日期或从字符串解析出日期时间。 ofPattern "},{"title":"工具类​","type":1,"pageTitle":"Java","url":"docs/notes/java/#工具类","content":""},{"title":"Arrays​","type":1,"pageTitle":"Java","url":"docs/notes/java/#arrays","content":"copyOf System.arraycopy() sort "},{"title":"Collections​","type":1,"pageTitle":"Java","url":"docs/notes/java/#collections","content":"Collection 相关的工具类，其中包含了大量的静态方法，方法的参数或者返回值是 Collection。 "},{"title":"Objects​","type":1,"pageTitle":"Java","url":"docs/notes/java/#objects","content":""},{"title":"Spliterators​","type":1,"pageTitle":"Java","url":"docs/notes/java/#spliterators","content":""},{"title":"Files​","type":1,"pageTitle":"Java","url":"docs/notes/java/#files","content":""},{"title":"Paths​","type":1,"pageTitle":"Java","url":"docs/notes/java/#paths","content":""},{"title":"常用接口​","type":1,"pageTitle":"Java","url":"docs/notes/java/#常用接口","content":""},{"title":"Comparable​","type":1,"pageTitle":"Java","url":"docs/notes/java/#comparable","content":"自然排序。需要比较的对象自身实现此接口。String及包装类都实现了此接口。 public int compareTo(T o);  "},{"title":"Compartor​","type":1,"pageTitle":"Java","url":"docs/notes/java/#compartor","content":"定制排序。作为一个比较器，参数需要放入两个对比的对象。 int compare(T o1, T o2);  "},{"title":"Serializable​","type":1,"pageTitle":"Java","url":"docs/notes/java/#serializable","content":""},{"title":"集合​","type":1,"pageTitle":"Java","url":"docs/notes/java/#集合","content":" "},{"title":"Collection​","type":1,"pageTitle":"Java","url":"docs/notes/java/#collection","content":"是单列数据结构的父接口。 for 循环遍历​ 通过size()方法得到集合的长度，通过元素下标遍历，下标从 0 开始。 迭代器遍历​ 调用Iterable#iterator()方法来得到迭代器对象，每次调用都会得到一个新的迭代器对象。 Iterator&lt;E&gt; iterator() 迭代器是一次性使用的，元素的顺序不能保证，只能向后遍历，不能回溯。Java 8 新加入了forEachRemaining方法，可以用函数式接口完成遍历。 boolean hasNext()E next()void remove()void forEachRemaining(Consumer&lt;? super E&gt; action) 在迭代器的过程中不能使用集合本身的有关元素修改的操作如add()和remove()，不然迭代器在下次迭代的时候会抛出异常，这样做的是为了避免同步问题。 在AbstractList中有一个modCount变量，在涉及到对列表元素进行修改的方法中会将modCount++。在迭代器Itr构造的时候会保存当前的modCount值为expectedModCount，在每次迭代和remove()之前都会比对这两个值，如果不相等则意味着在迭代器之外有操作对列表元素进行了修改，为了避免同步问题就会抛出ConcurrentModificationException异常。 如果没有调用next()直接调用remove()，或者在调用了next()之后调用了两次remove()，都会抛出IllegalStateException异常。迭代器Ite中维护了一个lastRet变量，默认是-1，在调用next()之后会更新为当前元素的下标，在调用remove()之后会更新为-1，在调用remove()之前会对其进行检查，如果从来没有调用过next()或者调用两次remove()的时候会抛出异常。 for-each 循环​ Java 5 中新增的语法糖，实际上调用的是迭代器的方法，所以有和迭代器一样的限制。数组也可以用这种方式遍历。注意遍历过程中的元素变量只是局部变量。 for(Person p: persons){ System.out.println(p); }  "},{"title":"List​","type":1,"pageTitle":"Java","url":"docs/notes/java/#list","content":"Vector出现较早（Java 1.0），是线程安全的，效率低ArrayList出现较晚（Java 1.2），是非线程安全的，效率高LinkedList的数据结构是双向链表，其它两者的数据结构是数组，因此对于频繁的插入、删除操作，LinkedList的效率更高 "},{"title":"Set​","type":1,"pageTitle":"Java","url":"docs/notes/java/#set","content":"无序、不可重复的数据结构。底层用的是Map，只用了 key 的那一列。 HashSet，无序，线程不安全，可以存储null值，底层用HashMapLinkedHashSet，元素可以按照添加的顺序遍历，是HashSet的子类，底层用LinkedHashMapTreeSet，可以对添加的对象进行排序，底层用TreeMap "},{"title":"Queue​","type":1,"pageTitle":"Java","url":"docs/notes/java/#queue","content":"LinkedList是Deque的实现类，可以当作栈或队列使用。 \tThrows exception\tReturns special valueInsert\tadd(e)\toffer(e) Remove\tremove()\tpoll() Examine\telement()\tpeek() 有一个子接口Deque。 这些方法可以当作栈使用。 Stack Method\tEquivalent Deque Methodpush(e)\taddFirst(e) pop()\tremoveFirst() peek()\tpeekFirst() 这些方法可以当作双向队列使用。 \tFirst Element (Head)\tFirst Element (Head)\tLast Element (Tail)\tLast Element (Tail)\tThrows exception\tSpecial value\tThrows exception\tSpecial value Insert\taddFirst(e)\tofferFirst(e)\taddLast(e)\tofferLast(e) Remove\tremoveFirst()\tpollFirst()\tremoveLast()\tpollLast() Examine\tgetFirst()\tpeekFirst()\tgetLast()\tpeekLast() "},{"title":"Map​","type":1,"pageTitle":"Java","url":"docs/notes/java/#map","content":"是双列数据结构的顶层接口。Map 的底层也是数组，每个位置放的都是一个Entry，其中包含了 key 和 value。 Hashtable，Java 1.0 引入，当时还没有Map接口，后来 Java 1.2 抽取 Map 接口，Hashtable是线程安全的，其中table是小写，key 不能是nullProperties，Hashtable的子类，用于读取和写入.properties文件，内容也是键值对的形式，key 和 value 都是String类型HashMap，Map的主要实现类，非线程安全，key 可以为nullLinkedHashMap，存储key的时候不仅仅存储 key 的内容，而是存储了一个双向链表的节点，可以按照元素加入的顺序来遍历TreeMap，底层用红黑树，是排序二叉树的一种 "},{"title":"泛型​","type":1,"pageTitle":"Java","url":"docs/notes/java/#泛型","content":"可以在编译期间进行类型检查，更安全。避免了强制类型转换，更方便。 "},{"title":"泛型类/接口​","type":1,"pageTitle":"Java","url":"docs/notes/java/#泛型类接口","content":"class/interface 类名&lt;T1, T2&gt; extends .... { T1 t1; T2 t2; public T1 fn(T2 t2){ } }  如果在实例化时没有指定泛型，则认为此泛型类型为Object静态方法/静态成员不能用类声明的泛型 "},{"title":"泛型方法​","type":1,"pageTitle":"Java","url":"docs/notes/java/#泛型方法","content":"只有声明了泛型参数列表的方法才是泛型方法，泛型方法声明的泛型参数列表只能在这个方法中使用。不论其所在的类是否是泛型类。 //修饰符 泛型 返回值类型 方法名 参数列表 public &lt;T extends Object&gt; T[] toArray(T ...a);  "},{"title":"类型通配符​","type":1,"pageTitle":"Java","url":"docs/notes/java/#类型通配符","content":"&lt;?&gt;任意类型，除了null外不让存，可以取，取出来是Object类型的&lt;? extends Xxx&gt;必须是继承此类&lt;T extends Number &amp; Serializable&gt;，可以有多个限制，但是父类只能有一个，并且必须写在第一位，后面可以跟多个接口&lt;? super Xxx&gt;必须是此类的父类 "},{"title":"I/O​","type":1,"pageTitle":"Java","url":"docs/notes/java/#io","content":"流的分类： 操作数据单位 字节流字符流 数据的流向 输入流输出流 流的角色 节点流处理流  \tByte Based Input\tByte Based Output\tCharacter Based Input\tCharacter Based OutputBasic\tInputStream\tOutputStream\tReader InputStreamReader\tWriter OutputStreamWriter Arrays\tByteArrayInputStream\tByteArrayOutputStream\tCharArrayReader\tCharArrayWriter Files\tFileInputStream RandomAccessFile\tFileOutputStream RandomAccessFile\tFileReader\tFileWriter Pipes\tPipedInputStream\tPipedOutputStream\tPipedReader\tPipedWriter Buffering\tBufferedInputStream\tBufferedOutputStream\tBufferedReader\tBufferedWriter Filtering\tFilterInputStream\tFilterOutputStream\tFilterReader\tFilterWriter Parsing\tPushbackInputStream StreamTokenizer PushbackReader LineNumberReader Strings StringReader\tStringWriter Data\tDataInputStream\tDataOutputStream Data - Formatted PrintStream PrintWriter Objects\tObjectInputStream\tObjectOutputStream Utilities\tSequenceInputStream  表格内容来自 Java IO Tutorial (jenkov.com)。 "},{"title":"File​","type":1,"pageTitle":"Java","url":"docs/notes/java/#file","content":"代表一个文件或目录。 "},{"title":"RandomAccessFile​","type":1,"pageTitle":"Java","url":"docs/notes/java/#randomaccessfile","content":"支持随机读写的文件。对象中维护了一个指针，所有对文件的读写都相对于当前的指针。 "},{"title":"转换流​","type":1,"pageTitle":"Java","url":"docs/notes/java/#转换流","content":"下面的两个类可以将字节流转换为字符流。 InputStreamReaderOutputStreamWriter "},{"title":"打印流​","type":1,"pageTitle":"Java","url":"docs/notes/java/#打印流","content":"PrintStream，是OutputStream的子类PrintWriter，是Writer的子类 System.in、System.out和System.err都是PrintStream。 PrintWriter少了一些参数为byte[]的方法，不能直接写出字节，其它方法都差不多。 以上两者的输出方法都不会抛出 I/O 异常。 "},{"title":"数据流​","type":1,"pageTitle":"Java","url":"docs/notes/java/#数据流","content":"DataInputStreamDataOutputStream 将基本数据类型和String持久化和读入。 "},{"title":"对象流​","type":1,"pageTitle":"Java","url":"docs/notes/java/#对象流","content":"ObjectInputStreamObjectOutputStream 将基本数据类型和String持久化和读入。 对象的序列化和反序列化操作。 在序列化和反序列化的过程中会忽略掉静态成员变量和用transient修饰的成员变量。 要求被操作的类实现java.io.Serializable或java.io.Externalizable接口。 private static final long serialVersionUID用于标识当前对象的版本号，如果不显式声明的话系统会根据类的结构自动计算一个并写入到序列化的结果中。在反序列化的时候会将内存中加载的类的serialVersionUID和序列化结果中的serialVersionUID对比，如果不相同则抛出InvalidClassException异常。 如果显式声明了该字段，并且两个类结构不相同的情况下，反序列化的过程中会尽量读取变量值。如果新增了字段则该字段为默认值，如果删除了字段则忽略该字段；如果更改了字段的类型则会抛出InvalidClassException异常。 在反序列化的过程中可能会抛出ClassNotFoundException。 "},{"title":"NIO​","type":1,"pageTitle":"Java","url":"docs/notes/java/#nio","content":"Java 1.4 引入，更高效的流操作。 "},{"title":"NIO 2​","type":1,"pageTitle":"Java","url":"docs/notes/java/#nio-2","content":"Java 7 引入，对 NIO 进行了扩展。 "},{"title":"Path​","type":1,"pageTitle":"Java","url":"docs/notes/java/#path","content":""},{"title":"Paths​","type":1,"pageTitle":"Java","url":"docs/notes/java/#paths-1","content":""},{"title":"Files​","type":1,"pageTitle":"Java","url":"docs/notes/java/#files-1","content":""},{"title":"网络编程​","type":1,"pageTitle":"Java","url":"docs/notes/java/#网络编程","content":""},{"title":"InetAddress​","type":1,"pageTitle":"Java","url":"docs/notes/java/#inetaddress","content":""},{"title":"ServerSocket​","type":1,"pageTitle":"Java","url":"docs/notes/java/#serversocket","content":"TCP 服务端。 "},{"title":"Socket​","type":1,"pageTitle":"Java","url":"docs/notes/java/#socket","content":"TCP 客户端。 "},{"title":"DatagramSocket​","type":1,"pageTitle":"Java","url":"docs/notes/java/#datagramsocket","content":"UDP，不分服务端与客户端。 非面向连接，不可靠的。 "},{"title":"DatagramPacket​","type":1,"pageTitle":"Java","url":"docs/notes/java/#datagrampacket","content":"UDP 数据包。 "},{"title":"URL​","type":1,"pageTitle":"Java","url":"docs/notes/java/#url","content":""},{"title":"反射​","type":1,"pageTitle":"Java","url":"docs/notes/java/#反射","content":"Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 "},{"title":"获取 Class 实例的方式​","type":1,"pageTitle":"Java","url":"docs/notes/java/#获取-class-实例的方式","content":"Object.classnew Object().getClass()Class.forName(&quot;com.example.A&quot;)&lt;当前类&gt;.class.getClassLoader().loadClass(&quot;com.example.A&quot;) "},{"title":"Class 对象的类型​","type":1,"pageTitle":"Java","url":"docs/notes/java/#class-对象的类型","content":"class类interface接口[]数组，只要数据类型和维度相同就是同一种 Classenum枚举@interface注解基本数据类型void "},{"title":"动态代理​","type":1,"pageTitle":"Java","url":"docs/notes/java/#动态代理","content":"使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 JDK 提供的动态代理要求被代理类必须实现接口。 "},{"title":"Proxy​","type":1,"pageTitle":"Java","url":"docs/notes/java/#proxy","content":"java.lang.reflect.Proxy是专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException  创建代理对象的过程就是创建了一个实现了接口的子类对象，并没有创建被代理的对象。 public class ProxyTest { public static void main(String[] args) { Handler handler = new Handler(); handler.setInstance(new A()); Object instance = Proxy.newProxyInstance(A.class.getClassLoader(), A.class.getInterfaces(), handler); ((Inter) instance).say(&quot;hello&quot;); } } class Handler implements InvocationHandler { private Inter instance; public void setInstance(Inter instance) { this.instance = instance; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { for (Class&lt;?&gt; anInterface : proxy.getClass().getInterfaces()) { System.out.println(anInterface); } System.out.println(method); args[0] = &quot;replace&quot;; return instance == null ? null : method.invoke(instance, args); } }  "},{"title":"新特性​","type":1,"pageTitle":"Java","url":"docs/notes/java/#新特性","content":""},{"title":"Java 7​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-7","content":"switch 支持 String​ try-with-resources​ NIO 2​ 泛型推断​ "},{"title":"Java 8​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-8","content":"函数式（Functional）接口​ 单方法接口。   Lambda 表达式​ 简化 SAM（Single Abstract Method）接口实现的语法糖。 （形参列表）-&gt;{Lambda 体}  如果 Lambda 体里面只有一句话，则可以省略{}以及里面的分号；如果形参列表中形参类型是已知的，那么数据类型可以省略；如果形参列表只有一个形参，并且数据类型可以省略，则可以省略括号；如果只有一句ruturn语句，可以省略return；如果没有形参，()不能省略。 方法引用与构造器引用​ 当 Lambda 体的实现是调用一个现有的方法来实现，并且抽象方法的参数列表与该方法的参数列表对象，那么就可以使用方法引用来简化。 list.forEach(num -&gt; System.out.println(num)); list.forEach(System.out::println);  如果第一个形参是调用方法的，剩下的都作为此方法的参数，也可以使用方法引用。 Arrays.sort(arr, (e1, e2) -&gt; {e1.compareToIgnoreCase(e2)}); Arrays.sort(arr, String::compareToIgnoreCase);  构造器引用，当 Lambda 的方法体是通过创建对象实现的，并且形参列表一致。 Supplier&lt;String&gt; s = String::new; // String[]::new 数组构造器  Stream API​ 数据加工流。 Stream 不负责存储数据，它只负责对数据进行处理Stream 不会改变源对象，每次处理都会返回一个有结果的新 StreamStream 是延迟执行的，在获取结果的时候才会执行之前的操作方法 创建​ &lt;集合对象&gt;.stream()Arrays.stream(arr)static &lt;T&gt; Stream&lt;T&gt; of(T... values)static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)产生一个无限流static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; f)无限流 中间操作​ Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)Stream&lt;T&gt; distinct()Stream&lt;T&gt; limit(long maxSize)Stream&lt;T&gt; skip(long n)static concat()合并两个流Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)对每个元素执行操作，相当于 forEach，但是不是终止操作Stream&lt;T&gt; sorted()Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)对每个元素执行操作，返回该函数返回的元素组成的流&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper) 终结操作​ void forEach(Consumer&lt;? super T&gt; action)long count()boolean allMatch(Predicate&lt;? super T&gt; predicate)boolean anyMatch(Predicate&lt;? super T&gt; predicate)boolean noneMatch(Predicate&lt;? super T&gt; predicate)Optional&lt;T&gt; findFirst()返回第一个元素Optional&lt;T&gt; findAny()返回任意一个Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)相当于 JS 中的 reduce，从左到右依次处理元素值，identity 是初始值，每次 accumulator 的返回值会累加到 identity 上，最后返回该值。&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)把流中的数据收集起来，在Collectors中有许多方法来提供Collectoer的实现类。 Optional​ 单值容器。 public static &lt;T&gt; Optional&lt;T&gt; of(T value)存值public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)可以存 null，如果是 null 则返回空 Optionalstatic &lt;T&gt; Optional&lt;T&gt; empty()直接返回一个空的容器public boolean isPresent()public T get()public void ifPresent(Consumer&lt;? super T&gt; consumer)public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)public T orElse(T other)如果不是空的返回容器中的值，如果是空的返回另一个值public T orElseGet(Supplier&lt;? extends T&gt; other)如果是空的执行方法，返回该方法的返回值public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)public &lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper) 接口中的默认方法和静态方法​ 在之前的接口笔记中有介绍。 新的日期时间 API​ 在之前的笔记中有提及。 "},{"title":"Java 9​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-9","content":"模块化系统​ 在src目录下用module-info.java文件来声明模块信息。 通过module、export和requires关键字来声明模块信息。 交互式编程环境 jShell​ 类似于python和node的命令行交互式编程环境。 接口私有方法​ Java 9 中接口方法可以用private修饰。 匿名实现类使用泛型​ 在 Java 8 中，匿名实现类不能声明泛型，Java 9 中可以。  局部变量类型推断​ 使用var关键字，在代码块中声明变量时可以省略掉变量的类型。 "},{"title":"Java 10​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-10","content":""},{"title":"Java 11​","type":1,"pageTitle":"Java","url":"docs/notes/java/#java-11","content":""},{"title":"MySQL 基础","type":0,"sectionRef":"#","url":"docs/notes/database/mysql","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#参考资料","content":"【宋红康】MySQL 数据库（mysql 安装/基础/高级/优化）_哔哩哔哩_bilibili "},{"title":"数据库的作用​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#数据库的作用","content":"实现数据持久化使用完整的管理系统统一管理 "},{"title":"名词解释​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#名词解释","content":"DB（Database），数据库，它保存了一系列有组织的数据DBMS（Database Management System），数据库管理系统，简称数据库软件，可以对数据库进行操作DBA（Database Administrator），数据库管理员SQL（Structure Query Language），结构化查询语言 "},{"title":"关系型数据库​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#关系型数据库","content":""},{"title":"概念​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#概念","content":"关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的（Structured）。 将数据放到表中，表再放到库中。 "},{"title":"关系​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#关系","content":"一对一一对多多对多自我引用 "},{"title":"命令行​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#命令行","content":"mysql -h localhost -P 3306 -u root -proot  -P指定端口-p指定密码，密码可以不写在命令中，只指定参数而不写密码的话会在交互式命令行中输入密码，不会在密码历史或屏幕中暴露密码 "},{"title":"默认数据库​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#默认数据库","content":"// TODO Mysql 默认带的几个数据库的作用 "},{"title":"SQL​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#sql","content":""},{"title":"SQL 概念​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#sql-概念","content":"结构化查询语言（Structured Query Language），是一种规范，用来操作关系型数据库。但是每种数据库在实现上有略微不同，称为「方言」； "},{"title":"分类​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#分类","content":"DDL（Data Definition Language）数据定义语言：用于操作数据库对象，如数据库、表、字段等。关键字：create、drop、alter、rename、truncate ；DML（Data Manipulation Language）数据操作语言：用于操作数据本身。关键字 insert、delete、update、select ；DCL（Data Control Language）数据控制语言：用户操作数据库 的访问权限和安全级别，以及管理用户，关键字 grant、revoke、commit、rollback、savepoint。 "},{"title":"规则​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#规则","content":"SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进每条命令以;或 \\g或\\G结束 \\g和\\G只能在命令行中使用\\g和;的效果一样\\G会将结果表转置，行列转换 关键字不能被缩写也不能分行关于标点符号 必须保证所有的()、单引号、双引号是成对结束的必须使用英文状态下的半角输入方式字符串型和日期时间类型的数据可以使用单引号表示列的别名，尽量使用双引号，而且不建议省略as "},{"title":"规范​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#规范","content":"这是建议遵守的，不强制。 MySQL 在 Windows 环境下是大小写不敏感的MySQL 在 Linux 环境下是大小写敏感的 数据库名、表名、表的别名、变量名是严格区分大小写的关键字、函数名、列名（或字段名）、列的别名（字段的别名）是忽略大小写的。 推荐采用统一的书写规范 数据库名、表名、表别名、字段名、字段别名等都小写SQL 关键字、函数名、绑定变量等都大写 "},{"title":"注释​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#注释","content":"-- 单行注释 # 单行注释 /* 多行注释 */  "},{"title":"SELECT 语句​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#select-语句","content":"select [distinct | ] 字段列表 from 表名列表 where 条件列表 group by 分组条件 having 分组之后的条件 order by 排序 limit 分页条件 escape '转义字符'  "},{"title":"去除重复行​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#去除重复行","content":"使用关键字DISTINCT去除重复行。 DISTINCT需要放到所有列名的前面DISTINCT是对后面所有列名的组合进行去重 "},{"title":"字段名和关键字冲突​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#字段名和关键字冲突","content":"在表名或字段名和关键字冲突时可能会造成歧义，这是使用着重号包裹字段名来避免歧义。 SELECT * FROM `ORDER`;  "},{"title":"转义字符​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#转义字符","content":"默认的转义字符是\\。 比如在使用like进行模糊查询的时候使用_作为单个字符的通配符，如果此时就是需要查询含有下划线的行，则需对其进行转义，如_\\__，中间的下划线就被转义了。 使用ESCAPE来自定义转义字符，如ESCAPE '&amp;'，意为使用$作为转义字符，此查询语句中的转义字符不再是\\了。 "},{"title":"运算符​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#运算符","content":""},{"title":"算数运算符​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#算数运算符","content":" "},{"title":"比较运算符​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#比较运算符","content":"  如果等号两边的值、字符串或表达式都为字符串，则 MySQL 会按照字符串进行比较，其比较的是每个字符串中字符的 ANSI 编码是否相等。如果等号两边的值一个是整数，另一个是字符串，则 MySQL 会将字符串转化为数字进行比较。如果等号两边的值、字符串或表达式中有一个为 NULL，则比较结果为 NULL。   LIKE 运算符通常使用如下通配符。 %匹配 0 个或多个字符。_只能匹配一个字符。 REGEXP和RLIKE均表示用正则表达式进行匹配。 "},{"title":"逻辑运算符​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#逻辑运算符","content":" "},{"title":"位运算符​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#位运算符","content":" "},{"title":"运算符的优先级​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#运算符的优先级","content":"下图中数字编号越大，优先级越高。   "},{"title":"NULL参与运算​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#null参与运算","content":"所有运算符或列值遇到null值，运算的结果都为null。 使用下面的方法安全处理null值。 &lt;=&gt;is nullis not nullisnull()ifnull() "},{"title":"排序​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#排序","content":"使用ORDER BY子句排序。 select * from 表 order by 字段 1 [, 字段 2, ...] [asc | desc];  ASC（Ascend），升序，默认排序方式DESC（Descend），降序 可以多字段同时排序，在前面字段相同的情况下会比较后面的字段。 "},{"title":"分页​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#分页","content":"使用LIMIT进行分页。 select * from 表 limit [offset,] rows;  offset表示从第几行之后开始，最小值为0，可省略，默认为0rows表示查询出多少行 "},{"title":"多表查询​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#多表查询","content":""},{"title":"内连接​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#内连接","content":"select * from a [inner] join b on a.id = b.id;  只会显示两表的交集，结果集的行必须出现在两个表中。 "},{"title":"外连接​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#外连接","content":"select * from a left | right [outer] join b on a.id = b.id;  左外连接：结果集中的行不仅包含符合连接条件的行，同时还包括左表中的不符合连接条件的行，这些行中来自副表的字段内容都是NULL。右外连接：同理。 "},{"title":"全链接​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#全链接","content":"MySQL 没有全连接，可以使用UNION来实现。 UNION操作符返回两个查询的结果集的并集，去除重复记录；UNION ALL不除重复记录。 "},{"title":"SQL99 语法新特性​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#sql99-语法新特性","content":"自然连接​ 使用NATURAL JOIN来简化多表查询操作，此时会自动将两表中所有同名字段进行等值连接。 USING连接​ 使用USING来简化ON子句，如果连接条件中的字段名称相同的话可以使用。 select * from a join b on a.id = b.id; select * from a join b using (id);  "},{"title":"单行函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#单行函数","content":""},{"title":"数值函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#数值函数","content":"函数\t用法ABS(x)\t返回 x 的绝对值 SIGN(X)\t返回 X 的符号。正数返回 1，负数返回-1，0 返回 0 PI()\t返回圆周率的值 CEIL(x)，CEILING(x)\t返回大于或等于某个值的最小整数 FLOOR(x)\t返回小于或等于某个值的最大整数 LEAST(e1,e2,e3…)\t返回列表中的最小值 GREATEST(e1,e2,e3…)\t返回列表中的最大值 MOD(x,y)\t返回 X 除以 Y 后的余数 RAND()\t返回 0~1 的随机值 RAND(x)\t返回 0~1 的随机值，其中 x 的值用作种子值，相同的 X 值会产生相同的随机数 ROUND(x)\t返回一个对 x 的值进行四舍五入后，最接近于 X 的整数 ROUND(x,y)\t返回一个对 x 的值进行四舍五入后最接近 X 的值，并保留到小数点后面 Y 位 TRUNCATE(x,y)\t返回数字 x 截断为 y 位小数的结果 SQRT(x)\t返回 x 的平方根。当 X 的值为负数时，返回 NULL 角度与弧度互换函数​ 函数\t用法RADIANS(x)\t将角度转化为弧度，其中，参数 x 为角度值 DEGREES(x)\t将弧度转化为角度，其中，参数 x 为弧度值 三角函数​ 函数\t用法SIN(x)\t返回 x 的正弦值，其中，参数 x 为弧度值 ASIN(x)\t返回 x 的反正弦值，即获取正弦为 x 的值。如果 x 的值不在-1 到 1 之间，则返回 NULL COS(x)\t返回 x 的余弦值，其中，参数 x 为弧度值 ACOS(x)\t返回 x 的反余弦值，即获取余弦为 x 的值。如果 x 的值不在-1 到 1 之间，则返回 NULL TAN(x)\t返回 x 的正切值，其中，参数 x 为弧度值 ATAN(x)\t返回 x 的反正切值，即返回正切值为 x 的值 ATAN2(m,n)\t返回两个参数的反正切值 COT(x)\t返回 x 的余切值，其中，X 为弧度值 指数与对数​ 函数\t用法POW(x,y)，POWER(X,Y)\t返回 x 的 y 次方 EXP(X)\t返回 e 的 X 次方，其中 e 是一个常数，2.718281828459045 LN(X)，LOG(X)\t返回以 e 为底的 X 的对数，当 X &lt;= 0 时，返回的结果为 NULL LOG10(X)\t返回以 10 为底的 X 的对数，当 X &lt;= 0 时，返回的结果为 NULL LOG2(X)\t返回以 2 为底的 X 的对数，当 X &lt;= 0 时，返回 NULL 进制间的转换​ 函数\t用法BIN(x)\t返回 x 的二进制编码 HEX(x)\t返回 x 的十六进制编码 OCT(x)\t返回 x 的八进制编码 CONV(x,f1,f2)\t返回 f1 进制数变成 f2 进制数 "},{"title":"字符串函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#字符串函数","content":"MySQL 中，字符串的位置是从 1 开始的。 函数\t用法ASCII(S)\t返回字符串 S 中的第一个字符的 ASCII 码值 CHAR_LENGTH(s)\t返回字符串 s 的字符数。作用与 CHARACTER_LENGTH(s) 相同 LENGTH(s)\t返回字符串 s 的字节数，和字符集有关 CONCAT(s1,s2,......,sn)\t连接 s1,s2,......,sn 为一个字符串 CONCAT_WS(x, s1,s2,......,sn)\t同 CONCAT(s1,s2,...) 函数，但是每个字符串之间要加上 x INSERT(str, idx, len, replacestr)\t将字符串 str 从第 idx 位置开始，len 个字符长的子串替换为字符串 replacestr REPLACE(str, a, b)\t用字符串 b 替换字符串 str 中所有出现的字符串 a UPPER(s) 或 UCASE(s)\t将字符串 s 的所有字母转成大写字母 LOWER(s) 或 LCASE(s)\t将字符串 s 的所有字母转成小写字母 LEFT(str,n)\t返回字符串 str 最左边的 n 个字符 RIGHT(str,n)\t返回字符串 str 最右边的 n 个字符 LPAD(str, len, pad)\t用字符串 pad 对 str 最左边进行填充，直到 str 的长度为 len 个字符 RPAD(str ,len, pad)\t用字符串 pad 对 str 最右边进行填充，直到 str 的长度为 len 个字符 LTRIM(s)\t去掉字符串 s 左侧的空格 RTRIM(s)\t去掉字符串 s 右侧的空格 TRIM(s)\t去掉字符串 s 开始与结尾的空格 TRIM(s1 FROM s)\t去掉字符串 s 开始与结尾的 s1 TRIM(LEADING s1 FROM s)\t去掉字符串 s 开始处的 s1 TRIM(TRAILING s1 FROM s)\t去掉字符串 s 结尾处的 s1 REPEAT(str, n)\t返回 str 重复 n 次的结果 SPACE(n)\t返回 n 个空格 STRCMP(s1,s2)\t比较字符串 s1,s2 的 ASCII 码值的大小 SUBSTR(s,index,len)\t返回从字符串 s 的 index 位置其 len 个字符，作用与 SUBSTRING(s,n,len)、MID(s,n,len) 相同 LOCATE(substr,str)\t返回字符串 substr 在字符串 str 中首次出现的位置，作用于 POSITION(substr IN str)、INSTR(str,substr) 相同。未找到，返回 0 ELT(m,s1,s2,…,sn)\t返回指定位置的字符串，如果 m=1，则返回 s1，如果 m=2，则返回 s2，如果 m=n，则返回 sn FIELD(s,s1,s2,…,sn)\t返回字符串 s 在字符串列表中第一次出现的位置 FIND_IN_SET(s1,s2)\t返回字符串 s1 在字符串 s2 中出现的位置。其中，字符串 s2 是一个以逗号分隔的字符串 REVERSE(s)\t返回 s 反转后的字符串 NULLIF(value1,value2)\t比较两个字符串，如果 value1 与 value2 相等，则返回 NULL，否则返回 value1 "},{"title":"日期和时间函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#日期和时间函数","content":"获取日期、时间​ 函数\t用法CURDATE() ，CURRENT_DATE()\t返回当前日期，只包含年、月、日 CURTIME() ，CURRENT_TIME()\t返回当前时间，只包含时、分、秒 NOW() / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP()\t返回当前系统日期和时间 UTC_DATE()\t返回 UTC（世界标准时间）日期 UTC_TIME()\t返回 UTC（世界标准时间）时间 日期与时间戳的转换​ 函数\t用法UNIX_TIMESTAMP()\t以 UNIX 时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() -&gt;1634348884 UNIX_TIMESTAMP(date)\t将时间 date 以 UNIX 时间戳的形式返回。 FROM_UNIXTIME(timestamp)\t将 UNIX 时间戳的时间转换为普通格式的时间 获取月份、星期、星期数、天数等函数​ 函数\t用法YEAR(date) / MONTH(date) / DAY(date)\t返回具体的日期值 HOUR(time) / MINUTE(time) / SECOND(time)\t返回具体的时间值 MONTHNAME(date)\t返回月份：January，... DAYNAME(date)\t返回星期几：MONDAY，TUESDAY.....SUNDAY WEEKDAY(date)\t返回周几，注意，周 1 是 0，周 2 是 1，。。。周日是 6 QUARTER(date)\t返回日期对应的季度，范围为 1～4 WEEK(date) ， WEEKOFYEAR(date)\t返回一年中的第几周 DAYOFYEAR(date)\t返回日期是一年中的第几天 DAYOFMONTH(date)\t返回日期位于所在月份的第几天 DAYOFWEEK(date)\t返回周几，注意：周日是 1，周一是 2，。。。周六是 7 时间和秒钟转换的函数​ 函数\t用法TIME_TO_SEC(time)\t将 time 转化为秒并返回结果值。转化的公式为：小时*3600+分钟*60+秒 SEC_TO_TIME(seconds)\t将 seconds 描述转化为包含小时、分钟和秒的时间 计算日期和时间的函数​ 函数\t用法DATE_ADD(datetime, INTERVAL expr type)，ADDDATE(date,INTERVAL expr type)\t返回与给定日期时间相差 INTERVAL 时间段的日期时间 DATE_SUB(date,INTERVAL expr type)，SUBDATE(date,INTERVAL expr type)\t返回与 date 相差 INTERVAL 时间间隔的日期 函数\t用法ADDTIME(time1,time2)\t返回 time1 加上 time2 的时间。当 time2 为一个数字时，代表的是秒，可以为负数 SUBTIME(time1,time2)\t返回 time1 减去 time2 后的时间。当 time2 为一个数字时，代表的是秒，可以为负数 DATEDIFF(date1,date2)\t返回 date1 - date2 的日期间隔天数 TIMEDIFF(time1, time2)\t返回 time1 - time2 的时间间隔 FROM_DAYS(N)\t返回从 0000 年 1 月 1 日起，N 天以后的日期 TO_DAYS(date)\t返回日期 date 距离 0000 年 1 月 1 日的天数 LAST_DAY(date)\t返回 date 所在月份的最后一天的日期 MAKEDATE(year,n)\t针对给定年份与所在年份中的天数返回一个日期 MAKETIME(hour,minute,second)\t将给定的小时、分钟和秒组合成时间并返回 PERIOD_ADD(time,n)\t返回 time 加上 n 后的时间 日期的格式化与解析​ 函数\t用法DATE_FORMAT(date,fmt)\t按照字符串 fmt 格式化日期 date 值 TIME_FORMAT(time,fmt)\t按照字符串 fmt 格式化时间 time 值 GET_FORMAT(date_type,format_type)\t返回日期字符串的显示格式 STR_TO_DATE(str, fmt)\t按照字符串 fmt 对 str 进行解析，解析为一个日期 "},{"title":"流程控制函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#流程控制函数","content":"函数\t用法IF(value,value1,value2)\t如果 value 的值为 TRUE，返回 value1，否则返回 value2 IFNULL(value1, value2)\t如果 value1 不为 NULL，返回 value1，否则返回 value2 CASE WHEN 条件 1 THEN 结果 1 WHEN 条件 2 THEN 结果 2 .... [ELSE resultn] END\t相当于 Java 的 if...else if...else... CASE expr WHEN 常量值 1 THEN 值 1 WHEN 常量值 1 THEN 值 1 .... [ELSE 值 n] END\t相当于 Java 的 switch...case... "},{"title":"加密与解密函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#加密与解密函数","content":"函数\t用法PASSWORD(str)\t返回字符串 str 的加密版本，41 位长的字符串。加密结果不可逆，常用于用户的密码加密 MD5(str)\t返回字符串 str 的 md5 加密后的值，也是一种加密方式。若参数为 NULL，则会返回 NULL SHA(str)\t从原明文密码 str 计算并返回加密后的密码字符串，当参数为 NULL 时，返回 NULL。SHA 加密算法比 MD5 更加安全。 ENCODE(value,password_seed)\t返回使用 password_seed 作为加密密码加密 value DECODE(value,password_seed)\t返回使用 password_seed 作为加密密码解密 value "},{"title":"MySQL 信息函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#mysql-信息函数","content":"函数\t用法VERSION()\t返回当前 MySQL 的版本号 CONNECTION_ID()\t返回当前 MySQL 服务器的连接数 DATABASE()，SCHEMA()\t返回 MySQL 命令行当前所在的数据库 USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()\t返回当前连接 MySQL 的用户名，返回结果格式为“主机名 @用户名” CHARSET(value)\t返回字符串 value 自变量的字符集 COLLATION(value)\t返回字符串 value 的比较规则 "},{"title":"其他函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#其他函数","content":"函数\t用法FORMAT(value,n)\t返回对数字 value 进行格式化后的结果数据。n 表示四舍五入后保留到小数点后 n 位 INET_ATON(ipvalue)\t将以点分隔的 IP 地址转化为一个数字 INET_NTOA(value)\t将数字形式的 IP 地址转化为以点分隔的 IP 地址 BENCHMARK(n,expr)\t将表达式 expr 重复执行 n 次。用于测试 MySQL 处理 expr 表达式所耗费的时间 CONVERT(value USING char_code)\t将 value 所使用的字符编码修改为 char_code "},{"title":"聚合函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#聚合函数","content":"聚合函数作用于一组数据，并对一组数据返回一个值。 "},{"title":"AVG 和 SUM 函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#avg-和-sum-函数","content":"可以对数值型数据使用AVG和SUM函数。 "},{"title":"MIN 和 MAX 函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#min-和-max-函数","content":"可以对任意数据类型的数据使用MIN和MAX函数。 "},{"title":"COUNT 函数​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#count-函数","content":"COUNT(*)返回表中记录总数，适用于任意数据类型。 COUNT(expr)返回expr 不为空的记录总数。 问题：用count(*)，count(1)，count(列名)谁好呢？ 其实，对于 MyISAM 引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。 Innodb 引擎的表用count(*),count(1)直接读行数，复杂度是 O(n)，因为 innodb 真的要去数一遍。但好于具体的count(列名)。 问题：能不能使用count(列名)替换count(*)? 不要使用 count(列名) 来替代 count(*)，count(*)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而count(列名)不会统计此列为 NULL 值的行。 "},{"title":"GROUP BY​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#group-by","content":"可以使用GROUP BY子句将表中的数据分成若干组。 在SELECT列表中的字段都必须出现在GROUP BY子句中，除了在聚合函数中的字段。如果不遵守的话在 MySQL 中不会提示错误，但是这个字段在行中是无意义的。 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id ;  包含在GROUP BY子句中的列不必包含在SELECT列表中。 SELECT AVG(salary) FROM employees GROUP BY department_id ;  GROUP BY后可以有多个列，此时按这些列的各个组合进行分组。 使用WITH ROLLUP关键字之后，在所有查询出的分组记录之后增加一条记录，就是将所有组的数据代入到聚合函数中。没有使用聚合函数的列显示为 NULL。 "},{"title":"HAVING​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#having","content":"HAVING不能单独使用，必须要跟GROUP BY一起使用。用来过滤分组结果，满足条件的分组行才会被查询出来。在之后可以使用聚合函数。 WHERE和HAVING的对比。 WHERE跟在FROM后面，HAVING跟在GROUP BY后面；WHERE后面不能使用聚合函数，HAVING可以；WHERE在分组前筛选，HAVING在分组后筛选；在多表查询中WHERE的效率更高，所以不涉及到聚合函数的条件写在WHERE中更好。 "},{"title":"SELECT 的执行过程​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#select-的执行过程","content":"在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。 SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5 FROM player JOIN team ON player.team_id = team.team_id # 顺序 1 WHERE height &gt; 1.80 # 顺序 2 GROUP BY player.team_id # 顺序 3 HAVING num &gt; 2 # 顺序 4 ORDER BY num DESC # 顺序 6 LIMIT 2 # 顺序 7  "},{"title":"子查询​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#子查询","content":"子查询指一个查询语句嵌套在另一个查询语句内部的查询。 子查询要包含在括号内将子查询放在比较条件的右侧单行操作符对应单行子查询，多行操作符对应多行子查询 在下列子句中都可以写子查询。 SELECTFROMWHEREHAVINGORDER BY "},{"title":"单行子查询​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#单行子查询","content":"单行比较操作符后面只能是单行子查询。 "},{"title":"多行子查询​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#多行子查询","content":"多行操作符后面可以是单行子查询，也可以是多行子查询。 操作符\t含义IN\t等于列表中的任意一个 ANY\t需要和单行比较操作符一起使用，和子查询返回的某一个值比较，只要有一行满足条件即可 ALL\t需要和单行比较操作符一起使用，和子查询返回的所有值比较，需要所有行都满足条件 SOME\t实际上是 ANY 的别名，作用相同，一般常使用 ANY "},{"title":"相关子查询​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#相关子查询","content":"子查询会执行多次。子查询中使用了外部的信息。 "},{"title":"EXISTS与NOT EXISTS​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#exists与not-exists","content":"用在WHERE子句中。EXISTS与NOT EXISTS后面都跟一个子查询，如果子查询返回有数据则EXISTS返回1，否则返回0；NOT EXISTS正相反。 SELECT employee_id , last_name , job_id , department_id from employees e WHERE EXISTS ( select 1 from employees e2 WHERE e2.manager_id = e.employee_id );  "},{"title":"相关更新​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#相关更新","content":"使用相关子查询依据一个表中的数据更新另一个表的数据。 UPDATE employees e SET department_name = (SELECT department_name FROM departments d WHERE e.department_id = d.department_id);  "},{"title":"相关删除​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#相关删除","content":"使用相关子查询依据一个表中的数据删除另一个表的数据。 DELETE FROM employees e WHERE employee_id in (SELECT employee_id FROM emp_history WHERE employee_id = e.employee_id);  "},{"title":"通用表表达式​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#通用表表达式","content":"MySQL 8 新特性。 WITH salesrep AS ( SELECT employeeNumber, CONCAT(firstName, ' ', lastName) AS salesrepName FROM employees WHERE jobTitle = 'Sales Rep' ), customer_salesrep AS ( SELECT customerName, salesrepName FROM customers INNER JOIN salesrep ON employeeNumber = salesrepEmployeeNumber ) SELECT * FROM customer_salesrep join salesrep ORDER BY customerName;  "},{"title":"创建表和管理表​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#创建表和管理表","content":""},{"title":"标识符命名规则​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#标识符命名规则","content":"数据库名、表名不得超过 30 个字符，变量名限制为 29 个必须只能包含 A–Z、a–z、0–9和_共 63 个字符同一个 MySQL 软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在 SQL 语句中使用`（着重号）引起来保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了 "},{"title":"MySQL 中的数据类型​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#mysql-中的数据类型","content":"类型\t类型举例整数类型\tTINYINT、SMALLINT、MEDIUMINT、INT（或 INTEGER）、BIGINT 浮点类型\tFLOAT、DOUBLE 定点数类型\tDECIMAL 位类型\tBIT 日期时间类型\tYEAR、TIME、DATE、DATETIME、TIMESTAMP 文本字符串类型\tCHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT 枚举类型\tENUM 集合类型\tSET 二进制字符串类型\tBINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB JSON 类型\tJSON 对象、JSON 数组 空间数据类型\t单值：GEOMETRY、POINT、LINESTRING、POLYGON； 集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 其中，常用的几类类型介绍如下。 数据类型\t描述INT\t从 −231-2^{31}−231 到 231−12^{31}-1231−1 的整型数据。存储大小为 4 个字节 CHAR(size)\t定长字符数据。若未指定，默认为 1 个字符，最大长度 255 VARCHAR(size)\t可变长字符数据，根据字符串实际长度保存，必须指定长度 FLOAT(M,D)\t单精度，占用 4 个字节，M=整数位+小数位M=整数位 + 小数位M=整数位+小数位，D=小数位D=小数位D=小数位。 D&lt;=M&lt;=255D&lt;=M&lt;=255D&lt;=M&lt;=255，0&lt;=D&lt;=300&lt;=D&lt;=300&lt;=D&lt;=30，默认 M+D&lt;=6M+D&lt;=6M+D&lt;=6 DOUBLE(M,D)\t双精度，占用 8 个字节，D&lt;=M&lt;=255D&lt;=M&lt;=255D&lt;=M&lt;=255，0&lt;=D&lt;=300&lt;=D&lt;=300&lt;=D&lt;=30，默认 M+D&lt;=15M+D&lt;=15M+D&lt;=15 DECIMAL(M,D)\t高精度小数，占用 M+2M+2M+2 个字节，D&lt;=M&lt;=65D&lt;=M&lt;=65D&lt;=M&lt;=65，0&lt;=D&lt;=300&lt;=D&lt;=300&lt;=D&lt;=30，最大取值范围与 DOUBLE 相同。 DATE\t日期型数据，格式「YYYY-MM-DD」 BLOB\t二进制形式的长文本数据，最大可达 4G TEXT\t长文本数据，最大可达 4G 常见数据类型的属性，如下： MySQL 关键字\t含义NULL\t数据列可包含 NULL 值 NOT NULL\t数据列不允许包含 NULL 值 DEFAULT\t默认值 PRIMARY KEY\t主键 AUTO_INCREMENT\t自动递增，适用于整数类型 UNSIGNED\t无符号 CHARACTER SET name\t指定一个字符集 "},{"title":"数据类型精讲​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#数据类型精讲","content":"整数类型​ 整数类型\t字节\t有符号数取值范围\t无符号数取值范围TINYINT\t1\t-128~127\t0~255 SMALLINT\t2\t-32768~32767\t0~65535 MEDIUMINT\t3\t-8388608~8388607\t0~16777215 INT、INTEGER\t4\t-2147483648~2147483647\t0~4294967295 BIGINT\t8\t-9223372036854775808~9223372036854775807\t0~18446744073709551615 浮点类型​  定点数类型​ 数据类型\t字节数\t含义DECIMAL(M,D),DEC,NUMERIC\tM+2 字节\t有效范围由 M 和 D 决定 位类型​ 二进制字符串类型\t长度\t长度范围\t占用空间BIT(M)\tM\t1 &lt;= M &lt;= 64\t约为 (M + 7)/8 个字节 日期与时间类型​ 类型\t名称\t字节\t日期格式\t最小值\t最大值YEAR\t年\t1\tYYYY 或 YY\t1901\t2155 TIME\t时间\t3\tHH:MM:SS\t-838:59:59\t838:59:59 DATE\t日期\t3\tYYYY-MM-DD\t1000-01-01\t9999-12-03 DATETIME\t日期时间\t8\tYYYY-MM-DD HH:MM:SS\t1000-01-01 00:00:00\t9999-12-31 23:59:59 TIMESTAMP\t日期时间\t4\tYYYY-MM-DD HH:MM:SS\t1970-01-01 00:00:00 UTC\t2038-01-19 03:14:07UTC 文本字符串类型​ 字符串 (文本) 类型\t特点\t长度\t长度范围\t占用的存储空间CHAR(M)\t固定长度\tM\t0 &lt;= M &lt;= 255\tM 个字节 VARCHAR(M)\t可变长度\tM\t0 &lt;= M &lt;= 65535\t(实际长度 + 1) 个字节 文本字符串类型\t特点\t长度\t长度范围\t占用的存储空间TINYTEXT\t小文本、可变长度\tL\t0 &lt;= L &lt;= 255\tL + 2 个字节 TEXT\t文本、可变长度\tL\t0 &lt;= L &lt;= 65535\tL + 2 个字节 MEDIUMTEXT\t中等文本、可变长度\tL\t0 &lt;= L &lt;= 16777215\tL + 3 个字节 LONGTEXT\t大文本、可变长度\tL\t0 &lt;= L&lt;= 4294967295（相当于 4GB）\tL + 4 个字节 ENUM 类型​ 文本字符串类型\t长度\t长度范围\t占用的存储空间ENUM\tL\t1 &lt;= L &lt;= 65535\t1 或 2 个字节 SET 类型​ 成员个数范围（L 表示实际成员个数）\t占用的存储空间1 &lt;= L &lt;= 8\t1 个字节 9 &lt;= L &lt;= 16\t2 个字节 17 &lt;= L &lt;= 24\t3 个字节 25 &lt;= L &lt;= 32\t4 个字节 33 &lt;= L &lt;= 64\t8 个字节 二进制字符串类型​ 二进制字符串类型\t特点\t值的长度\t占用空间BINARY(M)\t固定长度\tM （0 &lt;= M &lt;= 255）\tM 个字节 VARBINARY(M)\t可变长度\tM（0 &lt;= M &lt;= 65535）\tM+1 个字节 二进制字符串类型\t值的长度\t长度范围\t占用空间TINYBLOB\tL\t0 &lt;= L &lt;= 255\tL + 1 个字节 BLOB\tL\t0 &lt;= L &lt;= 65535（相当于 64KB）\tL + 2 个字节 MEDIUMBLOB\tL\t0 &lt;= L &lt;= 16777215（相当于 16MB）\tL + 3 个字节 LONGBLOB\tL\t0 &lt;= L &lt;= 4294967295（相当于 4GB）\tL + 4 个字节 JSON 类型​ INSERT INTO test_json (js) VALUES ('{&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:{&quot;province&quot;:&quot;beijing&quot;, &quot;city&quot;:&quot;beijing&quot;}}'); SELECT js -&gt; '$.name' AS NAME,js -&gt; '$.age' AS age ,js -&gt; '$.address.province' AS province, js -&gt; '$.address.city' AS city -&gt; FROM test_json;  空间类型​ MySQL 的空间数据类型（Spatial Data Type）对应于 OpenGIS 类，包括单值类型：GEOMETRY、POINT、LINESTRING、POLYGON 以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION。 "},{"title":"管理数据库​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#管理数据库","content":"创建数据库​ CREATE DATABASE 数据库名; CREATE DATABASE 数据库名 CHARACTER SET 'utf8mb4'; CREATE DATABASE IF NOT EXISTS 数据库名 CHARACTER SET 'utf8mb4';  数据库不能改名，只能删除重建。 使用数据库​ # 查看所有数据库 SHOW DATABASES; # 查询建表语句 SHOW CREATE DATABASE 数据库名; # 选择使用某个数据库 USE 数据库名; # 查看当前正在使用的数据库 SELECT DATABASE();  修改数据库​ # 更改数据库字符集 ALTER DATABASE 数据库名 CHARACTER SET 字符集;  删除数据库​ DROP DATABASE 数据库名; # 数据库不存在时不会报错 DROP DATABASE IF EXISTS 数据库名;  "},{"title":"管理表​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#管理表","content":"创建表​ # 方式一 直接创建表 CREATE TABLE [IF NOT EXISTS] 表名( 字段1, 数据类型 [约束条件] [默认值], 字段2, 数据类型 [约束条件] [默认值], 字段3, 数据类型 [约束条件] [默认值], …… [表约束条件] );  CREATE TABLE dept( -- int 类型，自增 deptno INT(2) AUTO_INCREMENT, dname VARCHAR(14), loc VARCHAR(13), -- 主键 PRIMARY KEY (deptno) );  # 方式二 基于子查询创建表，并导入数据 CREATE TABLE 表名 [(列, 列...)] AS (子查询)  CREATE TABLE emp1 AS SELECT * FROM employees;  使用表​ # 查看当前数据库下的所有表 show tables; # 查询建表语句 show create table t1; # 查询表结构 desc t1; describe t1;  修改表​ # 新增列 ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】; ALTER TABLE dept80 ADD job_id varchar(15); # 修改列 ALTER TABLE 表名 MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名2】; ALTER TABLE dept80 MODIFY last_name VARCHAR(30); ALTER TABLE dept80 MODIFY salary double(9,2) default 1000; # 重名命列 ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型; ALTER TABLE dept80 CHANGE department_name dept_name varchar(15); # 删除列 ALTER TABLE 表名 DROP 【COLUMN】字段名 ALTER TABLE dept80 DROP COLUMN job_id;  重命名表​ # 方式一 RENAME TABLE emp TO myemp; # 方式二 ALTER table dept RENAME [TO] detail_dept; -- [TO] 可以省略  删除表​ 在 MySQL 中，当一张数据表没有与其他任何数据表形成关联关系时，可以将当前数据表直接删除；数据和结构都被删除；所有正在运行的相关事务被提交；所有相关索引被删除；DROP TABLE语句不能回滚。 DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n]; DROP TABLE dept80;  清空表​ 删除表中所有的数据；释放表的存储空间；TRUNCATE语句不能回滚，而使用DELETE语句删除数据，可以回滚。 TRUNCATE TABLE detail_dept;  阿里开发规范： 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 "},{"title":"DDL 原子化​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#ddl-原子化","content":"MySQL 8 中支持。在执行 DDL 语句的时候遇到错误可以回滚，不会部分提交。 "},{"title":"DCL​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#dcl","content":"COMMIT，一旦提交，数据就写入到数据库中，不能回滚了；ROLLBACK，回滚到最近一次COMMIT之后。 # 不器用自动提交，默认情况下是自动提交的 SET autocommit = FALSE  "},{"title":"DML​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#dml","content":""},{"title":"插入数据​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#插入数据","content":"# 1 INSERT INTO 表名 VALUES (value1,value2,....); INSERT INTO departments VALUES (70, 'Pub', 100, 1700); # 2 INSERT INTO 表名(column1 [, column2, …, columnn]) VALUES (value1 [,value2, …, valuen]); INSERT INTO departments(department_id, department_name) VALUES (80, 'IT'); # 3 INSERT INTO table_name VALUES (value1 [,value2, …, valuen]), (value1 [,value2, …, valuen]), …… (value1 [,value2, …, valuen]); INSERT INTO emp(emp_id,emp_name) VALUES (1001,'shkstart'), (1002,'atguigu'), (1003,'Tom'); # 4 将查询结果插入到表中 INSERT INTO 目标表名 (tar_column1 [, tar_column2, …, tar_columnn]) SELECT (src_column1 [, src_column2, …, src_columnn]) FROM 源表名 [WHERE condition] INSERT INTO emp2 SELECT * FROM employees WHERE department_id = 90;  "},{"title":"更新数据​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#更新数据","content":"UPDATE table_name SET column1=value1, column2=value2, … , column=valuen [WHERE condition]  "},{"title":"删除数据​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#删除数据","content":"DELETE FROM table_name [WHERE &lt;condition&gt;];  "},{"title":"计算列​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#计算列","content":"MySQL 8 新特性。某一列的值是通过别的列计算得来的。 在 MySQL 8.0 中，CREATE TABLE和ALTER TABLE中都支持增加计算列。 CREATE TABLE tb1( id INT, a INT, b INT, c INT GENERATED ALWAYS AS (a + b) VIRTUAL ); INSERT INTO tb1(a,b) VALUES (100,200); SELECT * FROM tb1;  +------+------+------+------+ | id | a | b | c | +------+------+------+------+ | NULL | 100 | 200 | 300 | +------+------+------+------+  "},{"title":"约束​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#约束","content":""},{"title":"非空约束​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#非空约束","content":"# 建表时添加 CREATE TABLE 表名称( 字段名 数据类型, 字段名 数据类型 NOT NULL, 字段名 数据类型 NOT NULL ); # 建表后添加 alter table 表名称 modify 字段名 数据类型 not null; # 删除 # 去掉not null，相当于修改某个非注解字段，该字段允许为空 alter table 表名称 modify 字段名 数据类型;  "},{"title":"唯一性约束​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#唯一性约束","content":"# 建表时添加 create table 表名称( 字段名 数据类型, 字段名 数据类型 unique, 字段名 数据类型 unique key, 字段名 数据类型 ); create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] unique key(字段名) ); # 建表后添加 alter table 表名称 modify 字段名 字段类型 unique; ALTER TABLE USER ADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD); # 删除 # 查看都有哪些约束 SELECT * FROM information_schema.table_constraints WHERE table_name = '表名'; # 查看表的索引 show index from 表名称; ALTER TABLE USER DROP INDEX uk_name_pwd;  "},{"title":"主键约束​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#主键约束","content":"# 建表时添加 create table 表名称( 字段名 数据类型 primary key, #列级模式 字段名 数据类型, 字段名 数据类型 ); create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] primary key(字段名) #表级模式 ); # 建表后添加 # 字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键 ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); # 删除 alter table 表名称 drop primary key;  "},{"title":"自增列​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#自增列","content":"一个表最多只能有一个自增长列；自增长列约束的列必须是键列（主键列，唯一键列）；自增约束的列的数据类型必须是整数类型；如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。 # 建表时添加 create table 表名称( 字段名 数据类型 primary key auto_increment, 字段名 数据类型 unique key not null, 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值, ); create table 表名称( 字段名 数据类型 default 默认值 , 字段名 数据类型 unique key auto_increment, 字段名 数据类型 not null default 默认值,, primary key(字段名) ); # 建表后添加 alter table 表名称 modify 字段名 数据类型 auto_increment; # 删除 # 去掉auto_increment相当于删除 alter table 表名称 modify 字段名 数据类型;  在 MySQL 8.0 之前，自增主键 AUTO_INCREMENT 的值如果大于max(primary key)+1，在 MySQL 重启后，会重置 AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 MySQL 8.0 将自增主键的计数器持久化到重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB 会根据重做日志中的信息来初始化计数器的内存值。 "},{"title":"外键约束​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#外键约束","content":"从表的外键列，必须引用/参考主表的主键或唯一约束的列；当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束名，根据外键查询效率很高；删除外键约束后，必须手动删除对应的索引。 # 建表时添加 create table 主表名称( 字段1 数据类型 primary key, 字段2 数据类型 ); create table 从表名称( 字段1 数据类型 primary key, 字段2 数据类型, [CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段) ); # 建表后添加 ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx]; # 删除 # 查看某个表的约束名 SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称'; ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名; # 查看某个表的索引名 SHOW INDEX FROM 表名称; ALTER TABLE 从表名 DROP INDEX 索引名;  以下是对约束等级的说明。 Cascade：在父表上 update/delete 记录时，同步 update/delete 掉子表的匹配记录；Set null：在父表上 update/delete 记录时，将子表上匹配记录的列设为 null，但是要注意子表的外键列不能为 not null；No action：如果子表中有匹配的记录，则不允许对父表对应候选键进行 update/delete 操作；Restrict：同 no action，都是立即检查外键约束；Set default：父表有变更时，子表将外键列设置成一个默认的值，但 Innodb 不能识别。 如果没有指定等级，就相当于Restrict方式。对于外键约束，最好是采用：ON UPDATE CASCADE ON DELETE RESTRICT 的方式。 "},{"title":"CHECK 约束​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#check-约束","content":"MySQL5.7 可以使用 check 约束，但 check 约束对数据验证没有任何作用。添加数据时，没有任何错误或警告。但是 MySQL 8.0 中可以使用 check 约束了。 create table employee( eid int primary key, ename varchar(5), gender char check ('男' or '女') );  "},{"title":"DEFAULT 约束​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#default-约束","content":"# 建表时添加 create table 表名称( 字段名 数据类型 primary key, 字段名 数据类型 unique key not null, 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值, ); # 建表后添加 alter table 表名称 modify 字段名 数据类型 default 默认值 not null; # 删除 # 删除默认值约束，也不保留非空约束 # 删除默认值约束，保留非空约束 alter table 表名称 modify 字段名 数据类型; alter table 表名称 modify 字段名 数据类型 not null;  "},{"title":"面试​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#面试","content":"为什么建表时，加not null default ''或default 0 不想让表中出现 null 值。 为什么不想要 null 的值 不好比较。null 是一种特殊值，比较时只能用专门的 is null 和 is not null 来比较。碰到运算符，通常返回 null；效率不高。影响提高索引效果。因此，我们往往在建表时not null default ''或default 0。 带 AUTO_INCREMENT 约束的字段值是从 1 开始的吗 在 MySQL 中，默认 AUTO_INCREMENT 的初始值是 1，每新增一条记录，字段值自动加 1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定 id 值为 5，则以后插入的记录的 id 值就会从 6 开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。 并不是每个表都可以任意选择存储引擎 外键约束（FOREIGN KEY）不能跨引擎使用。 "},{"title":"视图​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#视图","content":"视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间，它是 SQL 中的一个重要概念；视图建立在已有表的基础上, 视图赖以建立的这些表称为基表；视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。 "},{"title":"创建视图​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#创建视图","content":"CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW 视图名称 [(字段列表)] AS 查询语句 [WITH [CASCADED|LOCAL] CHECK OPTION] CREATE VIEW 视图名称 AS 查询语句  "},{"title":"查看视图​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#查看视图","content":"SHOW TABLES; DESC / DESCRIBE 视图名称; SHOW TABLE STATUS LIKE '视图名称'\\G # 执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。 SHOW CREATE VIEW 视图名称;  "},{"title":"更新视图的数据​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#更新视图的数据","content":"MySQL 支持使用 INSERT、UPDATE 和 DELETE 语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。 要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作。 在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持 INSERT 和 DELETE 操作；视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持 INSERT 操作；在定义视图的 SELECT 语句中使用了JOIN 联合查询，视图将不支持 INSERT 和 DELETE 操作；在定义视图的 SELECT 语句后的字段列表中使用了数学表达式或子查询，视图将不支持 INSERT，也不支持 UPDATE 使用了数学表达式、子查询的字段值；在定义视图的 SELECT 语句后的字段列表中使用DISTINCT、聚合函数、GROUP BY、HAVING、UNION等，视图将不支持 INSERT、UPDATE、DELETE；在定义视图的 SELECT 语句中包含了子查询，而子查询中引用了 FROM 后面的表，视图将不支持 INSERT、UPDATE、DELETE；视图定义基于一个不可更新视图；常量视图。 "},{"title":"修改视图​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#修改视图","content":"CREATE OR REPLACE VIEW empvu80 (id_number, name, sal, department_id) AS SELECT employee_id, first_name || ' ' || last_name, salary, department_id FROM employees WHERE department_id = 80; ALTER VIEW 视图名称 AS 查询语句  "},{"title":"删除视图​","type":1,"pageTitle":"MySQL 基础","url":"docs/notes/database/mysql#删除视图","content":"DROP VIEW IF EXISTS 视图名称;  "},{"title":"Android","type":0,"sectionRef":"#","url":"docs/notes/java/android","content":"","keywords":""},{"title":"Android 应用程序构成​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#android-应用程序构成","content":""},{"title":"清单文件简介​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#清单文件简介","content":"几个重要的标签​ &lt;manifest&gt;配置文件根元素；&lt;user-permission&gt;用户权限配置标签；&lt;user-sdk&gt;SDK 版本配置；&lt;application&gt;应用程序配置的根元素；&lt;activity&gt;活动/页面配置；&lt;service&gt;服务配置；&lt;receiver&gt;广播接收者配置；&lt;provider&gt;内容提供者配置。 "},{"title":"进程与线程​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#进程与线程","content":"进程的优先级 前台进程可见进程服务进程后台进程空进程 "},{"title":"布局管理器​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#布局管理器","content":""},{"title":"RelativeLayout​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#relativelayout","content":"在父组件中的相对位置： layout_alignParentLeftlayout_alignParentRight...Top...Buttomlayout_centerHorizontallayout_centerVerticallayout_centerInParent 相对于其他组件： layout_abovelayout_belowlayout_toRightOf(toEndOf)layout_toLeftOf(toStartOf) 对齐： layout_alignLeftlayout_alignRightlayout_alignToplayout_alignBottom "},{"title":"LinearLayout​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#linearlayout","content":"orientation: 用于指定水平和垂直方向gravity: 指定容器内组件的对齐方式，可以同时取多个值right|bottomlayout_gravity: 指定组件相对于父容器的位置layout_weight: 所占比重 "},{"title":"FrameLayout​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#framelayout","content":"foreground: 前景图片，一直在其他组件的上方foregroundGravtiy: 前景图的位置 "},{"title":"TableLayout​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#tablelayout","content":"&lt;TableRow&gt;表格行容器collapseColumns: 折叠列/隐藏列，从0开始，多个值用逗号分隔stretchColumns: 拉伸列shrinkColums: 允许列被收缩 "},{"title":"GridLayout​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#gridlayout","content":"对比表格布局： 表格布局只可以跨列，网格布局可以跨行跨列表格布局中一行组件过多会不显示，网格布局会自动起新行显示 &lt;GridLayout&gt; columnCount: 最大列数rowCount: 最大行数orientation: 方向 子组件 layout_column: 指定位于网格的第几列layout_columnSpan: 跨列数layout_columnWeight: 比重layout_gravity: 子组件在网格内部的对齐layout_row... "},{"title":"嵌套​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#嵌套","content":"原则 根布局管理器必须包含xmlns属性；只能由一个根布局管理器；嵌套太深会影响性能。 "},{"title":"基本 UI 组件​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#基本-ui-组件","content":""},{"title":"TextView​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#textview","content":"layout_widthlayout_heighttextsingleLine: 单行，多余的会被截断，用省略号显示gravity: 指定文字对齐方式，可以多选值，用|分隔 "},{"title":"EditText​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#edittext","content":"hint: 输入提示inputTypedrawableLeft: 左边显示图标drawableStartdrawable...drawPadding: 图标与输入框的间隔lines: 行数 "},{"title":"Button​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#button","content":"onClick: 写触发事件的方法名，该方法有一个 View 参数textAllCaps: 默认为true，会将所有字母大写 "},{"title":"ImageButton​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#imagebutton","content":"没有text属性。 src: 指定图片background: ##0000可以设置为透明 "},{"title":"RadioButton​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#radiobutton","content":"checked: 设置选中状态 &lt;RadioGroup&gt;用于包裹单选按钮组。 "},{"title":"CheckBox​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#checkbox","content":"text: 文字 "},{"title":"DatePicker​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#datepicker","content":""},{"title":"TimePicker​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#timepicker","content":""},{"title":"Chronometer​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#chronometer","content":"format: 格式化 "},{"title":"ProgressBar​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#progressbar","content":"visibility: 设置可见状态，所有组件都可以用 visible: 可见invisible: 不可见，但是还是占据原来的位置gone: 不可见，不占据位置 progress: 设置进度 "},{"title":"SeekBar​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#seekbar","content":"是进度条的子类，所以可以使用进度条的属性和方法 thumb: 改变进度条位置指示器的内容，可以换成别的图片 "},{"title":"RatingBar​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#ratingbar","content":"其实就是拖动条 numStars: 设置星星数量rating: 已选的星星数量stepSize: 步进，默认 0.5，可以选择半颗isIndicator: 只读 "},{"title":"ImageView​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#imageview","content":"scaleType: 设置缩放方式 ImageView | Android 开发者 | Android Developers adjustViewBounds: 允许调整边界以保持图片长宽比，可以消除组件内的空白区域tint: 设置前景色，带透明度的颜色可以当滤镜使用 控制 ImageView 大小的方法：  "},{"title":"ImageSwitcher​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#imageswitcher","content":""},{"title":"GridView​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#gridview","content":"网格视图，通过适配器来设置内容。 numColumns: 列数 "},{"title":"Spinner​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#spinner","content":"entries: 设置可以选择的内容，也可以在代码中通过适配器来设置 "},{"title":"ListView​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#listview","content":"entries 通知数据更新 studentAdapter.notifyDataSetChanged();  "},{"title":"ScrollView​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#scrollview","content":"默认是垂直的，水平的需要使用&lt;HorizontalScrollView&gt; 一个滚动视图里只能放置一个组件，如果需要使用多个的话需要用 ViewGroup 包裹起来 "},{"title":"选项卡​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#选项卡","content":"在布局文件中添加 TabHost、TabWeiget、TabContent 组件； 编写各标签页的 XML 布局文件； 获取并初始化 TabHost 组件； 为 TabHost 添加标签页。 "},{"title":"AlertDialog​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#alertdialog","content":"AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this); dialog.setTitle(&quot;&quot;); dialog.setMessage(&quot;&quot;); dialog.setCancelable(false); dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener(){ @Override public void onClick(DialogInterface dialog, int width){ // do something here } }); dialog.show();  "},{"title":"ProgressDialog​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#progressdialog","content":"带进度条的 Dialog。 "},{"title":"Activity​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#activity","content":""},{"title":"介绍​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#介绍","content":"Activity 是android.content.Context的间接子类，存在于android.app包中；开发者自定义 Activity 时，必须直接或间接继承于Activity类。 所有的 Activity 必须在AndroidManifest.xml文件中注册。 "},{"title":"生命周期​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#生命周期","content":"运行态、暂停态、停止态。   "},{"title":"手动创建 Activity​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#手动创建-activity","content":"创建一个类，继承于android.app.Activity；创建布局文件；重写onCreate()方法，用setContentLayout(R.layout, activityLayoutName)来关联布局文件；在AndroidManifest.xml中注册。 "},{"title":"启动 Activity​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#启动-activity","content":"除了主活动之外，其他活动可以通过 Intent 启动。 startActivity(new Intent(MainActivity.this, RegistrationFormActivity.class));  还可以调用另一个 Activity 并返回结果。 使用StartActivityForResult启动活动； 使用SetResult设置结果； 重写onActivityResult方法。 "},{"title":"关闭 Activity​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#关闭-activity","content":"调用finish()方法，该方法继承于 Activity "},{"title":"Bundle​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#bundle","content":"类似于 HashMap，通过键值对的方式保存数据。  "},{"title":"Fragment​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#fragment","content":"迷你的 Activity。  "},{"title":"创建 Fragment​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#创建-fragment","content":"创建一个类，继承Fragment；重写必要的方法，比如onCreateView()；  "},{"title":"在 Activity 中添加 Fragment​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#在-activity-中添加-fragment","content":"在布局文件中添加​ 使用&lt;fragment&gt;标签，使用name属性指定。 代码动态添加​ 类似于数据库的事务管理，获取 TransactionManager，操作之后还需要手动 commit。  "},{"title":"事件处理​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#事件处理","content":""},{"title":"基于监听的事件处理​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#基于监听的事件处理","content":"注册各种 EventListener，满足条件时触发对应的监听器然后进行处理。 用于处理具体事件。 "},{"title":"基于回调的事件处理​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#基于回调的事件处理","content":"重写各种回调方法，比如重写 Activity 的方法，OnTouchEvent，OnKeyDown，OnKeyUp。 用于处理通用事件。 "},{"title":"物理按键事件处理​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#物理按键事件处理","content":"三种状态： OnKeyDown()OnKeyUp()OnKeyLongPress() 每个物理按键都有一个常量与之对应，形如KeyEvent.KEYCODE_HOME。 "},{"title":"菜单​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#菜单","content":""},{"title":"选项菜单​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#选项菜单","content":"用手机的菜单按钮呼出，或者点击左上角三个点。 编写 xml 布局文件，放在res/menu文件夹下；重写onCreateOptionsMenu()方法，用new MenuInflater.inflate()加载菜单项；重写onOptionsItemSelected()方法，为菜单注册点击事件。 "},{"title":"上下文菜单​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#上下文菜单","content":"注册在具体的组件上，长按呼出。 为组件注册上下文菜单； 创建菜单资源文件；registerForContextMenu() 添加上下文菜单； 重写onCreateContextMenu()方法，还是用MenuInflater来解析菜单的布局文件。 指定菜单项被选择时应作出的处理。 重写onContextItemSelected()方法。 "},{"title":"多媒体​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#多媒体","content":""},{"title":"MediaPlayer​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#mediaplayer","content":"用于播放音频，支持的文件格式： mp3ogg3gpwav 使用步骤​ 创建 MediaPlayer 对象； MediaPlayer.create() ，创建的同时并且装载音频文件。 装载音频文件。 "},{"title":"平面图形绘制​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#平面图形绘制","content":"涉及到的类​ Canvas: 画布Paint: 画笔ColorPath 绘图的基本步骤​ 继承自 View 类 重写 onDraw() 方法 super.onDraw(canvas); Paint paint = new Paint(); paint.setColor(0xffff6600); paint.setStyle(Paint.Style.FILL); canvas.drawRect(10, 10, 280, 150, paint); 将自定义 View 添加到 Activity 中 frameLayout.addView(new MyView(this));  绘制几何图形​ "},{"title":"Handler 消息处理​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#handler-消息处理","content":"线程不安全，所以子线程中不能直接更改主线程的 UI。所以就有了 Handler 机制。 使用 sendMessage() 来发送消息。 重写其中的 handleMessage() 方法来处理消息。 private Handler handler = new Handler() { @Override public void handleMessage(@NonNull Message msg) { switch (msg.what) { case 0: list.add((Bitmap) msg.obj); imageGridAdapter.notifyDataSetChanged(); break; case 1: textView.setText((String) msg.obj); break; } } };  "},{"title":"Message​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#message","content":"创建新的 Message 对象​ Message.obtain()Handler.obtainMessage() private void getImages() { new Thread() { @Override public void run() { try { Connection connection = Jsoup.connect(TARGET_URL); Document document = connection.timeout(3000).get(); Elements elements = document.select(&quot;div a&gt;img[class='lazy']&quot;); Message message = Message.obtain(handler); message.what = 1; message.obj = document.title(); message.sendToTarget(); for (int i = 0; i &lt; elements.size(); i++) { Log.i(&quot;getImages()&quot;, elements.get(i).toString()); String src = elements.get(i).attr(&quot;data-original&quot;); Log.i(&quot;getImages()&quot;, src); getBitmap(src); } } catch (IOException e) { e.printStackTrace(); } } }.start(); }  "},{"title":"Messenger​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#messenger","content":""},{"title":"Looper​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#looper","content":"消息队列管理器。 在主线程创建 Handler 时系统会自动创建 Looper；在子线程中创建 Handler 需要手动创建 Looper 对象。 Lopper.prepare()new Handler()Looper.loop() "},{"title":"Service​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#service","content":"Service 是 Android 四大核心组件之一，主要用于执行无需与用户交互，且需长期执行的功能。 "},{"title":"分类​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#分类","content":"本地 Service​ 服务和启动服务的 Activity 在同一个进程中； 远程 Service​ ……不在……。 "},{"title":"Service 生命周期​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#service-生命周期","content":" "},{"title":"创建本地服务​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#创建本地服务","content":"新服务必须继承自 Service 类，并且在 AndroidManifest.xml 文件中注册。 服务有两种启动方式： 普通方式启动（Started Service）：无法控制服务的执行过程，无法获取服务状态； startService() 启动，stopSelf() 停止自身，stopService() 在其他组件中停止某个服务。 绑定方式启动（Bound Service）：可以获取服务对象，可以控制服务的执行，能够获取服务状态。 "},{"title":"Broadcast​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#broadcast","content":""},{"title":"类型​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#类型","content":"标准广播（Normal broadcasts）​ 是一种完全异步执行的广播，在发出之后所有的接收者几乎同时接收到这条广播消息，因此没有先后顺序。 有序广播（Ordered broadcasts）​ 是一种同步执行的广播，在发出之后同一时刻只会有一个接收者接到消息，在当前接收者处理完逻辑之后才会传递给下一个接收者，所以这种类型的广播是有先后顺序的。并且前面接受广播的接收者可以截断广播，这样后面的接收者就不能接收了。  "},{"title":"接收广播​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#接收广播","content":"静态注册广播接收器​ 在程序未启动的情况下也能接收广播新建类继承自 BroadcastReceiver，并重写 onReceive() 方法在 manifest 文件中注册广播接收器 动态注册​ 必须在已启动的清空下才能接受广播 新建类继承…… 使用 registerReceiver(BroadcastReceiver, IntentFilter) 来注册接收器 其中 BroadcastReceiver 是接收器类的实例 IntentFilter 用来确定要接受的广播的标识 IntentFilter intentFilter = new IntentFilter(); intetnFilter.addAction(Intent.ACTION_SCREEN_ON); 在程序结束之前用 unregisterReceiver(BroadcastReceiver) 取消注册 "},{"title":"发送广播​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#发送广播","content":"发送标准广播​ Intent intent = new Intent(&quot;xxx&quot;); // 这里给的广播标识 sendBroadcast(intent);  发送有序广播​ sendOrderedBroadcast(Intent)如果在 onReceive() 方法中调用了 abortBroadcasat() 方法，就表示将这条广播截断。 "},{"title":"本地广播​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#本地广播","content":"只在本应用之内传递的广播。 注册​ LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(); Intent intent = new Intent(&quot;xxx&quot;); localBroadcastManager.sendBroadcast(intent);  接收​ 和之前动态注册接收系统广播一样。 "},{"title":"数据存储技术​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#数据存储技术","content":""},{"title":"Shared Preference​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#shared-preference","content":"安卓提供的，以最简单的方式永久保存数据的方法。 文件格式：.xml 存储路径：data/data/&lt;package name&gt;/shared_prefs/&lt;*.xml&gt; 写入数据步骤​ 获取 SharedPreference 对象 getSharedPreference(String name, int mode) name文件名称，不包括扩展名mode访问权限，MODE_PRIVATE/MODE_MULTI_PROCESS getPreference(int mode) mode访问权限，同上 获取 SharedPreference.Editor 对象 sharedPreference.edit() 添加数据 editor.putString()editor.putXxx() 提交数据 editor.commit()或者用 apply() 读取数据步骤​ 获取 SharedPreference 对象sharedPreference.getXxx() "},{"title":"文件存储​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#文件存储","content":"通过 Java 的 IO 流来读取磁盘上的文件。 内部存储​ data/data/&lt;package name&gt;/files/*私有的，只有创建该存储空间的应用可以访问当应用被卸载的时候，对应的内部存储空间也会被清空 // 这里省略了异常处理，实际使用的时候注意处理异常 FileInputStream in = openFileInput(&quot;filename&quot;); in.read(buffer); // 用字节数组 String string = new String(buffer); // 转换成字符串 in.close(); FileOutputStream out = openFileOutput(&quot;filename&quot;, MODE_RPIVATE); out.write(string.getBytes()); out.flush(); out.close();  外部存储​ 公共的，所有应用都可以访问表现为 SD 卡，虽然现在大多数手机不能插 SD 卡需要申请权限，要在 Manifest 文件中申请 if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED || ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(this, new String[]{ Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE }, 1); }  // 这里省略了异常处理，实际使用的时候注意处理异常 File file = new File(Environment.getExternalStorageDirectory(), &quot;filename&quot;); FileOutputStream out = new FileOutputStream(file); // ... FileInputStream in = new FileInputStream(file); // ...  "},{"title":"数据库存储​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#数据库存储","content":"public class DatabaseHelper extends SQLiteOpenHelper { private static final String SQL_ON_CREATE = &quot;CREATE TABLE student (&quot; + &quot;id INTEGER NOT NULL,&quot; + &quot;stu_id TEXT(10) NOT NULL,&quot; + &quot;stu_name TEXT(10) NOT NULL,&quot; + &quot;stu_class TEXT(10) NOT NULL,&quot; + &quot;CONSTRAINT android_PK PRIMARY KEY (id)&quot; + &quot;);&quot;; private Context mContext; public DatabaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); mContext = context; } @Override public void onCreate(SQLiteDatabase db) { db.execSQL(SQL_ON_CREATE); } }  "},{"title":"Content Provider​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#content-provider","content":"在不同应用之间实现数据共享，同时保证数据安全。 Content Provider 使用步骤​ 继承 ContentProvider 类在 Manifest 中注册getContentResolver()ContentResolver.insert()/delete()/update()/query() "},{"title":"网络编程​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#网络编程","content":""},{"title":"WebView​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#webview","content":"如果使用网络资源的话记得申请权限在布局文件中添加 Webview 组件 WebView webview = findViewById(); WebSettings settings = webView.getSettings(); settings.setJavaScriptEnabled(true); settings.setSupportZoom(false); // 使用内置浏览器打开链接 webView.setWebViewClient(new WebViewClient()); webView.loadUrl(&quot;https://ithome.com&quot;);  "},{"title":"URLConnection​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#urlconnection","content":"URL url = new URL(path); URLConnection urlConnection = url.openConnection(); urlConnection.setConnectTimeout(3000); urlConnection.connect(); InputStream inputStream = urlConnection.getInputStream();  "},{"title":"HttpURLConnecntion​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#httpurlconnecntion","content":"HttpsURLConnection connection = null; BufferedReader bufferedReader = null; StringBuilder response = null; URL url = new URL(TARGET_URL); connection = (HttpsURLConnection) url.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.setConnectTimeout(3000); connection.setReadTimeout(3000); if (connection.getResponseCode() != 200) { Message message = Message.obtain(handler); message.what = 0; message.obj = connection.getResponseMessage(); return; } InputStream inputStream = connection.getInputStream(); bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); response = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { response.append(line); }  "},{"title":"问题记录​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#问题记录","content":""},{"title":"在 TableLayout 中的 EditText 不能自动换行了​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#在-tablelayout-中的-edittext-不能自动换行了","content":"&lt;EditText android:id=&quot;@+id/comment&quot; android:layout_width=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;start|top&quot; android:inputType=&quot;textMultiLine&quot; android:lines=&quot;5&quot; android:minLines=&quot;5&quot; /&gt;  设置android:layout_weight=&quot;1&quot;，android:width=&quot;0dp&quot;和android:inputType=&quot;textMultiLine&quot;。 "},{"title":"去除 ImageView 组件内多余的空白区域​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#去除-imageview-组件内多余的空白区域","content":"&lt;ImageView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_rowWeight=&quot;0&quot; android:layout_columnWeight=&quot;1&quot; android:adjustViewBounds=&quot;true&quot; android:src=&quot;@mipmap/i4&quot; /&gt;  设置adjustViewBounds属性。 上面的布局用代码实现： // grid 行参数，设置 layout_rowWeight = 0 GridLayout.Spec rowSpec = GridLayout.spec(GridLayout.UNDEFINED, 0f); // gird 列参数，设置 layout_columnWeight = 1 GridLayout.Spec columnSpec = GridLayout.spec(GridLayout.UNDEFINED, 1f); // 构建 LayoutParams GridLayout.LayoutParams params = new GridLayout.LayoutParams(rowSpec, columnSpec); // 设置 layout_height 和 layout_width params.height = GridLayout.LayoutParams.WRAP_CONTENT; params.width = 0; ImageView imageView = new ImageView(MainActivity.this); imageView.setImageResource(id); imageView.setLayoutParams(params); // 去白边 imageView.setAdjustViewBounds(true); layout.addView(imageView);  "},{"title":"GirdLayout 内组件平均分布​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#girdlayout-内组件平均分布","content":"&lt;ImageView android:layout_width=&quot;0dp&quot; android:layout_columnWeight=&quot;1&quot; android:src=&quot;@mipmap/i4&quot; /&gt;  水平平均分布就设置layout_width=&quot;0dp&quot;和layout_columnWeight=&quot;1&quot;；垂直平均分布就设置layout_height和layout_rowWeight。 "},{"title":"Activity 和 BoundService 的双向交互​","type":1,"pageTitle":"Android","url":"docs/notes/java/android#activity-和-boundservice-的双向交互","content":"BoundService 的 IBinder 交给 Activity，Activity 通过 ServiceConnection 的 onServiceConnected() 方法获取，这样 Activity 就能通过 Binder 控制 Service 了； Activity 里声明 Handler，通过 Intent.putExtra(Messenger) 交给 Service，其中 Messenger 封装了 Handler，Service 在其生命周期的 onBind() 方法获取 Messenger，然后通过 messenger.send(message) 方法向 Handler 发送消息，由 Activity 中的 Handler 处理，从而实现 Service 控制 Activity。 "},{"title":"Java Web","type":0,"sectionRef":"#","url":"docs/notes/java/java-web","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#参考资料","content":"尚硅谷丨 2022 版 JavaWeb 教程 (全新技术栈，全程实战)_哔哩哔哩_bilibiliJavaWeb | 代码重工Web 阶段 [还没开始写]group javax.servlet has published 4 artifact(s) with total 41 version(s) "},{"title":"Tomcat​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#tomcat","content":""},{"title":"Tomcat 简介​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#tomcat-简介","content":"Servlet 容器，实现了 Servlet 标准。 "},{"title":"Tomcat 目录结构​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#tomcat-目录结构","content":" "},{"title":"Servlet​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#servlet","content":""},{"title":"概念​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#概念","content":"Server applet，运行在服务器端的小程序。 Servlet 属于 Java EE 标准，用于企业级 Web 开发，后改名为 Jakarta EE。 Servlet、Tomcat 和 Java 版本选择请参考 Tomcat 网站 1。关于 Servlet 名称历史及版本历史可以参考其 维基百科页面 2。 "},{"title":"引入​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#引入","content":"4.0.1 及之前使用此 Maven 坐标，搭配 Tomcat 9 及之前版本。 pom.xml &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 4.0.2 及之后使用此坐标。 pom.xml &lt;!-- https://mvnrepository.com/artifact/jakarta.servlet/jakarta.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 5.0 之后使用此坐标，搭配 Tomcat 10 使用。从 5 开始后包名改变了。 pom.xml &lt;!-- https://mvnrepository.com/artifact/jakarta.servlet/jakarta.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;6.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;  "},{"title":"快速入门​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#快速入门","content":"创建 JavaEE 项目 定义一个类，实现javax.servlet.Servlet接口 实现接口中的抽象方法，只重写service方法就可以 配置 Servlet 改 web.xml 文件 web.xml &lt;!-- 配置 Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo&lt;/servlet-name&gt; &lt;servlet-class&gt;me.iuok.web.Demo&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;  "},{"title":"生命周期​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#生命周期","content":"构造器方法；void init(ServletConfig servletConfig)默认第一次被访问时执行，只会执行一次，设置 &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; 可以在启动时自动执行；void service(ServletRequest servletRequest, ServletResponse servletResponse)每次访问服务的时候都会执行；void destroy()关闭时执行，只执行一次。 "},{"title":"体系结构​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#体系结构","content":"Servlet只是一个接口，我们要使用它的话需要实现里面所有的抽象方法；GenericServlet对所有抽象方法作了空实现，我们只需要重写自己需要用到的方法，比如service()，其它不需要的方法保持默认即可；HttpServlet 对Servlet作了更多的封装，service也不需要我们自己写了，它在 service方法里对请求方式作了判断，然后转发请求到对应的 doGet、doPost 等方法中，我们只需要重写这些方法就可以。 "},{"title":"ServletConfig​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#servletconfig","content":"String getInitParameter(String name)可以从配置文件中读取init-param中的内容。 web.xml &lt;servlet&gt; &lt;servlet-name&gt;exampleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;me.iuok.servlet.ExampleServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;encode&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; Enumeration&lt;String&gt; parameterNames = config.getInitParameterNames(); while (parameterNames.hasMoreElements()) { String parameterName = parameterNames.nextElement(); String value = config.getInitParameter(parameterName); log.info(&quot;{}: {}&quot;, parameterName, value); } Enumeration&lt;String&gt; getInitParameterNames() ServletContext getServletContext() String getServletName() "},{"title":"ServletContext​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#servletcontext","content":"当前 Servlet 类的实例，可以和容器通讯。 Enumeration&lt;String&gt; getInitParameterNames()获取context-param配置，这是所有 Servlet 都可以读取的。这里的context-param没有写在servlet标签之内。 web.xml &lt;context-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/context-param&gt; String getInitParameter(String name) String getContextPath()获取项目路径，在前面会有一个/ String getRealPath(String path)获取文件在磁盘上的真实路径 获取 MIME 类型 String getMimeType(String file) 域对象：共享数据，所用会话所有请求的数据，在整个容器的生命周期里都存在 void setAttribute(String name, Object object)Object getAttribute(String name)void removeAttribute(String name) 获取文件的绝对路径 String getRealPath(String path) 两种获取办法： ServletContext servletRequset.getServletContext()ServletContext genericServlet.getServletContext() "},{"title":"HttpServlet​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#httpservlet","content":"直接实现Servlet来实现方法太麻烦，以后直接继承HttpServlet。它重写了Servlet方法，现在就不需要写service方法了。 doGet(HttpServletRequest req, HttpServletResponse resp)doXxx(...) "},{"title":"ServletRequest​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#servletrequest","content":"获取请求参数 String getParameter(String name)Enumeration&lt;String&gt; getParameterNames()String[] getParameterValues(String name)Map&lt;String,String[]&gt; getParameterMap() RequestDispatcher getRequestDispatcher(String path)获取请求转发器实例，path指定转发目的地，根目录包括项目路径 "},{"title":"HttpServletRequest​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#httpservletrequest","content":"是ServletRequest的子接口。 String getContextPath()获取项目路径，在 ServletContext 中也有一个相同的方法 "},{"title":"ServletResponse​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#servletresponse","content":"ServletOutputStream getOutputStream()获取输出字节流PrintWriter getWriter()获取输出字符流void setCharacterEncoding(String charset)设置响应内容的编码格式void setContentType(String type)加一个请求头Content-Type，可以告诉浏览器返回内容的编码格式 "},{"title":"HttpServletResponse​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#httpservletresponse","content":"是ServletResponse的子接口。 void sendRedirect(String location)发送重定向信息；设置状态码为 302，Location为重定向的地址；浏览器会重新对这个地址发送请求，根目录不包括项目路径，如果需要的时候要手动拼接。setHeader(String name, String value)设置请求头void setStatus(int sc)设置响应状态码 "},{"title":"RequestDispatcher​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#requestdispatcher","content":"forward(ServletRequest request, ServletResponse response)转发请求，可以携带上下文信息，是内部转发，将 request 和 response 交给别的处理器处理，跟流水线一样。include(ServletRequest request, ServletResponse response) "},{"title":"解决乱码问题​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#解决乱码问题","content":"GET 请求的参数乱码，修改 Tomcat 的配置文件，在server.xml中修改Connector标签，添加URIEncoding=&quot;utf-8&quot;属性。 POST 请求的参数乱码，手动指定 request 数据的编码方式。 req.setCharacterEncoding(&quot;utf-8&quot;);  响应内容中的乱码，可以设置服务器端的编码方式。 resp.setCharacterEncoding(&quot;utf-8&quot;);  并且设置响应头让浏览器知道编码方式。以下二选一，功能一样。 resp.setContentType(&quot;text/html;charset=utf-8&quot;); resp.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;);  "},{"title":"Cookie​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#cookie","content":"Cookie[] httpServletRequest.getCookies()void httpServletResponse.addCookie(Cookie cookie) "},{"title":"HttpSession​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#httpsession","content":"HttpSession httpServletRequest.getSession() Session 是服务端会话技术，依赖 Cookie 运行，在 Cookie 中的名字是JSESSIONID。使用下面的命令来获取或者创建一个 Session。 HttpSession session = request.getSession(true);  Session 中可以保存数据，可以在同一个会话中进行访问。 String s = reader.readLine(); session.setAttribute(&quot;value&quot;, s); Object value = session.getAttribute(&quot;value&quot;); writer.write((String) value);  默认情况下 Session 会在浏览器关闭后失效，可以通过设置值为JSESSIONID的 Cookie 的失效时间来保持 Seesion。 HttpSession session = req.getSession(); Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId()); cookie.setMaxAge(60 * 60); resp.addCookie(cookie);  "},{"title":"JSP​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#jsp","content":"Java Server Pages，既可以写 HTML 标签，又可以写 Java 代码。它本质上就是一个 Servlet。 "},{"title":"脚本标签​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#脚本标签","content":"&lt;% coding here %&gt;定义的 Java 代码在 service 方法中&lt;%! coding here %&gt;定义的类的成员&lt;%= coding here %&gt;直接输出里面的变量 "},{"title":"指令​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#指令","content":"用于配置 JSP 页面以及导入资源文件。 &lt;%@ 指令名称 属性名1=属性值1 %&gt;  page：用于配置页面 contentTypepageEncodingimport：导包errorPage：当前页面发生错误之后会自动跳转到指定的错误页面isErrorPage：当前页面是否是错误页面，可以使用内置对象 exceptionisELIgnored：是否忽略 EL 表达式 include：导入其它页面 file taglib：导入标签库 prefixuri "},{"title":"注释​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#注释","content":"&lt;%-- 中间是注释 --%&gt;  "},{"title":"九大隐含对象​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#九大隐含对象","content":"在 JSP 页面中不需要创建可以直接使用的对象。 JSP 内置对象\t实例对象\t备注out\tJspWriter\t字符输出流 config\tServletConfig page\tServlet pageContext\tPageContext exception\tThrowable request\tHttpServletRequest response\tHttpServletResponse application\tServletContext session\tHttpSession\t 关于out字符输出流： 和response.getWriter()类似getWriter()的输出不管定义在 JSP 的哪个位置都会先于out输出 "},{"title":"四大域对象​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#四大域对象","content":"域对象\t类型\t范围\t备注PageContext\tPageContext\t当前 JSP 页面\t只能在 JSP 中获取 Request\tHttpServletRequest\t当前请求 Seesion\tHttpSession\t当前会话 Application\tServletContext\t当前应用\t "},{"title":"EL 表达式​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#el-表达式","content":"Expression Language，可以简化 JSP 页面上 Java 代码的书写。 语法：${表达式} 在 EL 表达式之前加反斜线可以忽略这个表达式的解析。 运算符​ 算术运算符比较运算符逻辑运算符空运算符 empty：判断字符串、数组或集合是否为 null 或长度为 0not empty 获取值​ 语法： ${域名称 .键名}${键名} 从最小的域开始依次寻找这个键名的值 获取对象的属性​ 属性：去掉 get/set 之后剩余的部分第一个字母小写。 List​ ${域 .键名 [索引]} Map​ ${域 .键名.key}${域 .键名.[&quot;key&quot;]} "},{"title":"JSTL​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#jstl","content":"JSP Standard Tag Library，JSP 标准标签库。用于简化和替换 JSP 页面上的 Java 代码。 导入 jar在页面中引入标签库：taglib 指令使用标签 常用标签 if test：接收布尔表达式，如果表达式为 true 则显示标签体内容 choose-when-otherwiseforeach beginendvarstepvarStatus：循环状态 .index：var 定义变量的值.count：循环次数 items "},{"title":"Filter​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#filter","content":""},{"title":"Filter 快速入门​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#filter-快速入门","content":"新类实现接口Filter，重写方法。 "},{"title":"web.xml 配置 Filter​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#webxml-配置-filter","content":"Filter 配置要写在 Servlet 配置之前；Filter 的顺序按照在配置文件中书写的顺序执行。 web.xml &lt;web-app&gt; &lt;filter&gt; &lt;filter-name&gt;XmlFilter&lt;/filter-name&gt; &lt;filter-class&gt;o.e.filter.XmlFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;XmlFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;EchoServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;o.e.servlet.EchoServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;EchoServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/echo&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;  "},{"title":"注解配置 Filter​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#注解配置-filter","content":"Filter 的顺序按照全类名排序。 HelloFilter.java @Slf4j @WebFilter(&quot;*&quot;) public class HelloFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { log.debug(&quot;HelloFilter 初始化&quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { log.debug(&quot;HelloFilter 前&quot;); chain.doFilter(request, response); log.debug(&quot;HelloFilter 后&quot;); } @Override public void destroy() { log.debug(&quot;HelloFilter 销毁&quot;); } }  "},{"title":"Filter 生命周期​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#filter-生命周期","content":"服务器启动的时候会创建 Filter，调用 init 方法每次拦截时执行 doFilter 方法服务器正常关闭时会调用 destroy 方法 "},{"title":"拦截路径​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#拦截路径","content":"url-pattern 精确匹配index.html路径匹配/hello/*后缀匹配*.jsp servlet-name访问指定的 Servlet 时会通过过滤器 "},{"title":"拦截方式​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#拦截方式","content":"dispatcherTypes REQUEST：浏览器直接请求资源会被拦截，默认值FORWARD：内部转发的会被拦截INCLUDE：包含访问ERROR：错误跳转ASYNC：异步访问 "},{"title":"过滤器链​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#过滤器链","content":"默认过滤器全类名字符排序小的过滤器先执行。 在 web.xml 中写在前面的先执行。 "},{"title":"Listener​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#listener","content":""},{"title":"监听器列表​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#监听器列表","content":"ServletContextListener，监听 ServletContext 对象的创建与销毁；HttpSessionListener，监听 HttpSession 对象的创建与销毁；ServletRequestListener，监听 ServletRequest 对象的创建与销毁；ServletContextAttributeListener，监听 ServletContext 中属性的创建、修改和销毁；HttpSessionAttributeListener，监听 HttpSession 中属性的创建、修改和销毁；ServletRequestAttributeListener，监听 ServletRequest 中属性的创建、修改和销毁；HttpSessionBindingListener，监听某个对象在 Session 域中的创建与移除；HttpSessionActivationListener，监听某个对象在 Session 中的序列化与反序列化。 "},{"title":"使用监听器​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#使用监听器","content":"新类，实现监听器XXXListener接口重写方法注册 "},{"title":"Servlet 3.0​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#servlet-30","content":""},{"title":"注解配置​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#注解配置","content":"Servlet 3.0 之后提供了 Servlet 注解支持，可以不用web.xml就能完成 Web 开发，要求 Tomcat &gt;= 7，属于 JSR-315 规范。 @WebServlet，注册 Servlet。@WebFilter@WebListener@WebInitParam，当需要初始化参数的时候可以配合此注解使用 "},{"title":"ServletContainerInitializer​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#servletcontainerinitializer","content":"在类路径下的「META-INF/services/」下创建一个名为javax.servlet.ServletContainerInitializer的文本文件，其中为一个全限定类名，该类为ServletContainerInitializer的实现类。在Servlet容器启动的时候会调用类中的回调方法完成初始化，可以注册Servlet、Listener 和 Filter，替代web.xml。 "},{"title":"异步请求​","type":1,"pageTitle":"Java Web","url":"docs/notes/java/java-web#异步请求","content":" Apache Tomcat® - Which Version Do I Want?↩Jakarta Servlet - Wikipedia↩ "},{"title":"JDBC","type":0,"sectionRef":"#","url":"docs/notes/java/jdbc","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"JDBC","url":"docs/notes/java/jdbc#参考资料","content":"尚硅谷 JDBC 核心技术视频教程（康师傅带你一站式搞定 jdbc）_哔哩哔哩_bilibili "},{"title":"JDBC 程序编写步骤​","type":1,"pageTitle":"JDBC","url":"docs/notes/java/jdbc#jdbc-程序编写步骤","content":" "},{"title":"获取数据库连接​","type":1,"pageTitle":"JDBC","url":"docs/notes/java/jdbc#获取数据库连接","content":"// DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver()); Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/atguigudb&quot;, &quot;root&quot;, &quot;root&quot;); System.out.println(connection);  可以不使用registerDriver注册驱动，驱动会自动注册，详情请查看DriverManager中的静态代码块，通过ServiceLoader加载了 MySQL 驱动，在com.mysql.cj.jdbc.Driver中的静态代码块中会自动注册自己。 "},{"title":"执行查询语句​","type":1,"pageTitle":"JDBC","url":"docs/notes/java/jdbc#执行查询语句","content":"@Test public void testQuery() throws IOException, SQLException { InputStream inputStream = GetConnectionTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties properties = new Properties(); properties.load(inputStream); Connection connection = DriverManager.getConnection((String) properties.get(&quot;url&quot;), properties); PreparedStatement statement = connection.prepareStatement(&quot;select * from employees where employee_id = ?&quot;); statement.setObject(1, 100); ResultSet resultSet = statement.executeQuery(); if (resultSet.next()) { for (int i = 0; i &lt; resultSet.getMetaData().getColumnCount(); i++) { System.out.println(resultSet.getObject(i + 1)); } } resultSet.close(); statement.close(); connection.close(); }  "},{"title":"批量执行​","type":1,"pageTitle":"JDBC","url":"docs/notes/java/jdbc#批量执行","content":"@Test public void testInsert2() throws Exception{ Connection conn = JDBCUtils.getConnection(); //1.设置为不自动提交数据 conn.setAutoCommit(false); String sql = &quot;insert into goods(name)values(?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++){ ps.setString(1, &quot;name_&quot; + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0){ //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); } } //2.提交数据 conn.commit(); JDBCUtils.closeResource(conn, ps); }  "},{"title":"事务​","type":1,"pageTitle":"JDBC","url":"docs/notes/java/jdbc#事务","content":"调用 Connection 对象的setAutoCommit(false)以取消自动提交事务在所有的 SQL 语句都成功执行后，调用commit()方法提交事务在出现异常时，调用rollback()方法回滚事务 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 "},{"title":"数据库连接池​","type":1,"pageTitle":"JDBC","url":"docs/notes/java/jdbc#数据库连接池","content":"资源重用。由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性；更快的系统反应速度。数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间；新的资源分配手段。对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源；统一的连接管理，避免数据库连接泄漏。在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露。 "},{"title":"Spring","type":0,"sectionRef":"#","url":"docs/notes/java/spring","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#参考资料","content":"【尚硅谷】SSM 框架全套教程，MyBatis+Spring+SpringMVC+SSM 整合一套通关_哔哩哔哩_bilibili "},{"title":"概述​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#概述","content":""},{"title":"Spring 的优势​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#spring-的优势","content":"解耦AOP声明式事务方便测试方便集成各种优秀框架 "},{"title":"Spring 的体系结构​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#spring-的体系结构","content":" "},{"title":"IoC​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#ioc","content":""},{"title":"核心容器​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#核心容器","content":"ApplicationContext 的三个常用实现类： ClassPathXmlApplicationContext，加载类路径下的配置文件FileSystemXmlApplicationContext，加载磁盘任意目录下的配置文件AnnotationConfigApplicationContext，读取注解创建容器 &lt;!-- bean.xml --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;me.iuok.dao.UserDao&quot;&gt;&lt;/bean&gt;  // 获取核心容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); // 两种获取方法都可以 UserDao bean = (UserDao) ac.getBean(&quot;userDao&quot;); UserDao userDao = ac.getBean(&quot;userDao&quot;, UserDao.class);  "},{"title":"Spring 对 Bean 的管理细节​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#spring-对-bean-的管理细节","content":"创建 Bean 的三种方式​ 使用默认构造函数创建。在 xml 中配置了 Bean 的 id 和 class，并且没有配置其它配置项就会使用对象的默认空参构造器来实例化对象，如果该对象没有空参构造器就会抛出异常； &lt;bean id=&quot;userDao&quot; class=&quot;me.iuok.dao.UserDao&quot;/&gt; 使用工厂类中的方法创建对象，获取其返回值，并存入容器。先创建工厂实例，再调用工厂方法； &lt;bean id=&quot;factory&quot; class=&quot;me.iuok.dao.UserDao&quot;/&gt; &lt;bean id=&quot;userDao&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getInstance&quot;/&gt; 使用工厂类中的静态方法创建对象，获取其返回值，并存入容器。因为是静态方法所以不用事先创建工厂类的实例。 &lt;bean id=&quot;userDao&quot; class=&quot;me.iuok.dao.UserDao&quot; factory-method=&quot;getInstance&quot;/&gt;  Bean 对象的作用范围​ 调整 bean 标签的 scope 属性。 scope\t说明singleton\t单例，默认值 prototype\t多例 request\t只在 request 域生效 session\tsession 域 global-session\t集群的 session 域，用于在负载均衡的机器之间共享数据 Bean 对象的生命周期​ 单例模式，Bean 的生命周期和容器的生命周期相同 创建对象：默认情况下，Bean 的创建随着容器的创建存活：只要容器存活，对象就存活销毁对象：随着容器的销毁 多例 创建对象：向容器索取的时候创建存活：一直存活，Spring 不会关闭它销毁对象：被其它机制销毁，比如手动关闭，被垃圾回收等 可以配置 bean 标签的 init-method 和 destroy-method 属性来分别制定初始化方法和销毁方法，Spring 容器在创建和销毁对象的时候会调用。 &lt;bean id=&quot;userDao&quot; class=&quot;me.iuok.dao.UserDao&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;  InitializingBean​ 是一个接口，规定了afterPropertiesSet()方法。 DisposableBean​ 是一个接口，规定了destory()方法。 JSR-250​ 有两个注解@PostConstruct和@PreDestory，在javax.annotation下，Spring 对这两个注解作了支持，可以控制 Bean 的生命周期方法。 其实 JSR-250 中的@PostConstruct和@PreDestory就是在InitDestoryAnnotationBeanPostProcessor中被处理的。 BeanPostProcessor​ 实现接口org.springframework.beans.factory.config.BeanPostProcessor，可以给 Bean 的生命周期加两个步骤。 该接口有postProcessBeforeInitialization和postProcessAfterInitialization两个方法，分别在所有初始化方法调用之前和之后调用，控制所有 Bean 的生命周期。 @AutoWired是在AutoWiredAnnotationBeanPostProcessor中被处理的。 完整生命周期​ 通过构造器或工厂方法创建 Bean 实例；populateBean()为 Bean 的属性赋值postProcessBeforeInitialization()@PostConstruct标注的方法InitialingBean接口中的afterPropertiesSet()方法initMethod指定的初始化方法postProcessAfterInitialization()Bean 可以使用了@PreDestory标注的方法DisposableBean中的destory()方法destroyMethod指定的销毁方法  "},{"title":"依赖注入​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#依赖注入","content":"Dependency injection，在当前类需要其他类的对象，由 Spring 容器为我们提供，我们只需在配置文件中维护依赖关系。 使用构造函数注入​ public class User { private UserDao userDao; public User(UserDao userDao) { this.userDao = userDao; } }  &lt;bean id=&quot;userDao&quot; class=&quot;me.iuok.dao.UserDao&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt; &lt;bean id=&quot;user&quot; class=&quot;me.iuok.domain.User&quot;&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt;  属性名\t说明type\t指定参数类型，写全类名，在有歧义的时候指定，平常不用 index\t指定参数的索引，从 0 开始 name\t指定参数的名称，通常用这个而不是索引 value\t直接给构造参数赋值，用于基本数据类型和 String 类型 ref\t引用另一个 bean 来给构造参数赋值 setter 注入​ 通过 set 方法注入属性。set 方法名去掉 set 之后剩下的部分首字母小写就称为属性（Property）。 name，属性名value，属性值ref，Bean 引用 public class User { private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } }  引用其他 Bean 注入。 &lt;bean id=&quot;userDao&quot; class=&quot;me.iuok.domain.UserDao&quot;&gt; &lt;!-- ... --&gt; &lt;/bean&gt; &lt;bean id=&quot;user&quot; class=&quot;me.iuok.domain.User&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt;  直接定义一个内部 Bean 供自己使用，这个 Bean 没有 ID。 &lt;bean id=&quot;user&quot; class=&quot;me.iuok.domain.User&quot;&gt; &lt;property name=&quot;userDao&quot;&gt; &lt;bean class=&quot;me.iuok.domain.UserDao&quot;&gt; &lt;!-- ... --&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt;  p 名称空间​ 为了简化 XML 配置，采用属性配置信息而非子元素配置信息，就是property标签的简便写法。 使用p:fieldName-ref=&quot;BeanId&quot;语法还可以引用其他 Bean。 &lt;bean id=&quot;studentSuper&quot; class=&quot;com.atguigu.helloworld.bean.Student&quot; p:studentId=&quot;2002&quot; p:stuName=&quot;Jerry2016&quot; p:age=&quot;18&quot; /&gt;  复杂类型的注入​ 还可以注入诸如 List、Map 之类的复杂类型，通过构造方法和属性都可以注入。 &lt;bean id=&quot;user&quot; class=&quot;me.iuok.domain.User&quot; init-method=&quot;init&quot;&gt; &lt;constructor-arg name=&quot;list&quot;&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;value&gt;ddd&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;property name=&quot;list&quot;&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;value&gt;ddd&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;  标签名\t注入类型\t备注array\tList 或数组\t&lt;value&gt;value&lt;/value&gt; list\tList\t同上 set\tList\t同上 props\tMap\t&lt;prop key=&quot;key&quot;&gt;value&lt;/prop&gt; map\tMap\t&lt;entry key=&quot;&quot; value=&quot;&quot;/&gt; 只需要记住两组就可以了，标签可以混用。 util:list标签可以定义一个数组，供其它地方引用；util:map标签可以定义一个 Map，供其它地方引用。 特殊值注入​ 使用null标签来表示 null 值。 &lt;bean id=&quot;user&quot; class=&quot;me.iuok.domain.User&quot;&gt; &lt;property name=&quot;userDao&quot;&gt; &lt;null /&gt; &lt;/property&gt; &lt;/bean&gt;  在CDATA标签内的内容可以不用转义，这是一个特殊的标签，所以只能放在标签的内容部分，不能放入属性部分。下面的例子中小于号&lt;就不用转义。 &lt;property name=&quot;expression&quot;&gt; &lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt; &lt;/property&gt;  "},{"title":"引入外部配置文件​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#引入外部配置文件","content":"context:property-placeholder来引入外部配置文件，使用 SpEL 表达式${prop.userName}来引用值。 &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;  "},{"title":"FactoryBean​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#factorybean","content":"实现org.springframework.beans.factory.FactoryBean接口，并且将该类注册到容器中后，配置的 Bean 不是该类本身，而是getObject()返回的那个实例。 如果想获取 FactoryBean 类本身的话，需要在 ID 前面加上「&amp;」字符。此机制的实现细节在BeanFactory工厂接口中。 "},{"title":"基于注解的配置​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#基于注解的配置","content":"基于注解的配置所要达成的目的和基于配置文件的配置所要达成的目的相同，都是为了降低程序间的耦合，只是配置的形式不一样。 不完全注解​ 首先在配置文件中开启包扫描。 &lt;context:component-scan base-package=&quot;me.iuok&quot;/&gt;  完全注解​ 可以新建一个类作为配置类，替换掉 xml 配置，使所有的配置都在 Java 代码中完成。此时在新建容器的时候就要使用 AnnotationConfigApplicationContext 类了。 @Configuration，标注当前类是一个配置类。@ComponentScan，和context:component-scan标签的作用一样，开启包扫描，自动扫描 Bean 并加入容器。@Bean(name)，标注在方法上，用于将该方法的返回值对象存入容器中。id 默认为当前方法名称，可以用 name 属性指定。如果该方法有参数，Spring 自动完成依赖注入。还可以搭配创建对象里的一些注解使用，用于替换 bean 标签里的其它属性。initMethod和destoryMethod来指定初始化和销毁方法。@Lazy，懒加载，针对单实例 Bean。容器启动的时候不创建对象，在第一次获取 Bean 的时候才创建对象并进行初始化。@Conditional，根据条件判断是否注册 Bean。其中属性是Condition接口，需要自己实现来决定是否注册 Bean。@Import，用于导入其它配置类，在其它配置类上就不用写@Configuration注解了，也不用在扫描包的时候加上其它类的包名了。可以传入一个普通类作为配置类；可以传入ImportSelector接口，指定需要导入的类的全限定类名；可以传入ImportBeanDefinitionRegister接口，手动向容器中注册 Bean。@PropertySource，指定 properties 配置文件，Spring 会自动解析。开头写上 classpath: 或者 file: 来指明这个文件来自类路径还是来自系统路径。可以搭配@Value和 SpEL 使用，${key} 就能直接拿到配置文件里的配置项。@Profile，根据当前环境，动态激活组件。在什么都没配置的情况下，默认激活的 profile 是 default。可以用虚拟机参数指定激活的 prifile，-Dspring.profiles.active=dev。 创建对象​ 注解\t说明@Component @Controller\t表现层 @Service\t业务层 @Repository\t持久层 它们的作用完全相同，都是创建当前类的对象并存入容器中。 其它三个都是 @Component 的别名，通过这个注解标记 @AliasFor(annotation = Component.class)。 起多个名字的原因是为了方便在不同场景使用，让业务更清晰。 属性value用于指定 Bean 的 id，默认为首字母小写的当前类名。 @Component public class UserDao { public void init() { log.info(&quot;init&quot;); } public void destroy() { log.info(&quot;destroy&quot;); } }  @Scope(value)，设置作用范围，和 bean 标签中的 scope 属性达到的效果是一样的，取值也一样。@PostConstruct，用于标注初始化方法。@PreDestroy，用于标注销毁方法。 依赖注入注解​ @Autowired：可以标注在成员变量上，也可以标注在方法参数上。只要容器中只有唯一一个对应该类型的对象，就可以直接注入。如果有多个匹配就会注入 id 与该变量名称相同的 Bean。使用注解注入时就不需要 setter 了。可以使用在数组和集合类型上，会自动装配所有满足要求的 Bean。如果使用在Map&lt;String, Xxx&gt;上，会自动装配所有满足要求的 Bean，并且把 id 作为 key。@Primary：在自动装配的时候作为首选候选者。@Order：以数值指定候选 Bean 的优先级排序。@Qualifier(value)：搭配上一个注解使用，在匹配类型的情况下再指定 Bean 的 id。在给方法参数标注的时候可以单独使用。@Resource(name)：JSR-250，直接指定 Bean 的 id 进行注入，单独使用。@Inject：JSR-330，需要导入javax.inject相关包，和@AutoWired类似，但是没有required属性。@Value(value)：用于注入基本类型和 String 类型的数据，可以使用 SpEL 表达式来注入环境变量中的值，写法为 ${exp}。还可以搭配@PropertySource来引用配置文件。 "},{"title":"Aware接口​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#aware接口","content":"如果想使用 Spring 底层的组件如ApplicationContext、BeanFactory、Environment等，可以实现org.springframework.beans.factory.Aware接口的子接口。这些依赖（大部分）都会在ApplicationContextAwareProcessor中被注入，该类是BeanPostProcessor的实现类。 ApplicationContextAwareEnvironmentAwareBeanFactoryAware... "},{"title":"AOP​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#aop","content":""},{"title":"概念​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#概念","content":"Aspect Oriented Programming，面向切面编程。减少重复代码，降低程序耦合，提升开发效率。 英文\t中文\t说明Joinpoint\t连接点\t被拦截到的点，在 Spring 中，指的是方法 Pointcut\t切入点\t被增强的 Joinpoint Advice\t通知/增强\t拦截后做的事情，有前置通知、后置通知、异常通知、最终通知和环绕通知 Introduction\t引介\t是一种特殊的通知，是指在不修改源码的前提下可以在运行期间动态地添加一些方法或者属性 Target\t目标对象\t被代理的目标对象 Weaving\t织入\t把增强应用到目标对象来创建新的代理对象的过程 Proxy\t代理\t一个类被 AOP 织入增强之后，就产生一个结果代理类 Aspect\t切面\t是切入点和通知的结合 "},{"title":"XML 配置​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#xml-配置","content":"导入依赖 &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt; &lt;/dependency&gt; 目标对象要实现接口 public interface UserService { void hello(); } @Slf4j public class UserServiceImpl implements UserService { public void hello() { log.info(&quot;UserServiceImpl.hello()&quot;); } } 把目标对象和通知类交由容器管理 &lt;bean id=&quot;userService&quot; class=&quot;me.iuok.service.impl.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;logger&quot; class=&quot;me.iuok.util.Logger&quot;/&gt; 开始织入 &lt;aop:config&gt; &lt;!-- 可以配置切面表达式引用 --&gt; &lt;aop:pointcut id=&quot;serviceImpl&quot; expression=&quot;execution(* me.iuok.service.impl.*.*(..))&quot;/&gt; &lt;!-- id 可以随便, ref 引用通知类 --&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!-- 配置前置通知，method 设置调用方法，pointcut 是切入点表达式 --&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void me.iuok.service.impl.UserServiceImpl.hello())&quot;/&gt; &lt;!-- 后置通知--&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut=&quot;execution(* me.iuok.service.impl.*.*(..))&quot;/&gt; &lt;!-- 异常通知--&gt; &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;serviceImpl&quot;/&gt; &lt;!-- 最终通知--&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;serviceImpl&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试 // 注意这里要使用目标对象的接口类型 UserService userService = ac.getBean(&quot;userService&quot;, UserService.class); userService.hello();  切入点表达式​ execution(&lt;exp&gt;)execution(public void me.iuok.service.impl.UserServiceImpl.hello())格式：访问修饰符 返回值类型 包名。类名。方法名 (参数类型列表) 访问修饰符 可以省略，表示任意 返回值 可以使用通配符 * 表示任意类型 包名 可以使用通配符 *，但是多少级包就需要使用多少个通配符可以使用 .. 表示当前包和子包 类名和方法名 都可以使用通配符 参数列表 可以直接写数据类型基本数据类型直接写，引用数据类型写全类名也可以使用通配符 * 表示任意类型，但是不包括没有参数的可以使用 .. 表示有无参数均可的任意类型 全通配写法：* *..*.*(..) 环绕通知​ 环绕通知就是整个增强后的方法，在 Spring 中它可以通过代码配置其它各种通知在何时何处如何实现。 配置方式实现的通知执行顺序不太可靠，如果对执行顺序有很高要求的话可以使用代码配置环绕通知，使用@Order注解来决定顺序。 &lt;aop:config&gt; &lt;!-- 可以配置切面表达式引用 --&gt; &lt;aop:pointcut id=&quot;serviceImpl&quot; expression=&quot;execution(* me.iuok.service.impl.*.*(..))&quot;/&gt; &lt;!-- id 可以随便, ref 引用通知类 --&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;serviceImpl&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;  public Object around(ProceedingJoinPoint pjp) { Object object = null; try { log.info(&quot;before&quot;); object = pjp.proceed(pjp.getArgs()); log.info(&quot;after-returning&quot;); } catch (Throwable throwable) { throwable.printStackTrace(); log.info(&quot;after-throwing&quot;); } finally { log.info(&quot;after&quot;); } return object; }  "},{"title":"注解配置​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#注解配置","content":"开启包扫描和自动代理，可以使用 XML 开启也可以使用注解开启 &lt;context:component-scan base-package=&quot;me.iuok&quot;/&gt; &lt;aop:aspectj-autoproxy/&gt; @Configuration @ComponentScan(basePackages = &quot;me.iuok&quot;) @EnableAspectJAutoProxy public class AppConfig { } 把目标类和通知类都交由容器管理 @Slf4j @Service public class UserService { public Integer sayHello() { log.info(&quot;UserService.sayHello&quot;); return 1; } } 在通知类上标注 @Aspect 注解，表明这是一个通知类 @Slf4j @Aspect @Component public class LogAspect { ... } 在方法上加入通知注解 @Before(&quot;pt()&quot;) public void before(JoinPoint joinPoint) { log.info(&quot;Aspect: before，{}&quot;, joinPoint.toLongString()); } @After(&quot;pt()&quot;) public void after(JoinPoint joinPoint) { log.info(&quot;Aspect: after，{}&quot;, joinPoint.toLongString()); } @AfterThrowing(value = &quot;pt()&quot;, throwing = &quot;e&quot;) public void afterThrowing(JoinPoint joinPoint, Exception e) { log.info(&quot;Aspect: afterThrowing，{}, {}&quot;, joinPoint.toLongString(), e); } @AfterReturning(value = &quot;pt()&quot;, returning = &quot;returning&quot;) public void afterReturning(JoinPoint joinPoint, Object returning) { log.info(&quot;Aspect: afterReturning，{}, {}&quot;, joinPoint.toLongString(), returning); } 同时也可以引用切入点表达式，注意引用的时候要用方法名加括号 @Pointcut(&quot;execution(* me.iuok.service.impl.*.*(..))&quot;) private void pt(){}  "},{"title":"声明式事务​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#声明式事务","content":"XML 配置声明式事务​ 配置数据库信息 &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;constructor-arg name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;constructor-arg name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 把 DAO 和 Service 交由容器管理 &lt;bean id=&quot;mockDao&quot; class=&quot;me.iuok.dao.impl.MockDaoImpl&quot;&gt; &lt;constructor-arg name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;mockService&quot; class=&quot;me.iuok.service.impl.MockServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;mockDao&quot; ref=&quot;mockDao&quot;/&gt; &lt;/bean&gt; 配置事务管理器 &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 配置事务的通知，与事务管理器关联；并为事务配置规则，这里为 login 方法配置了规则。其中 name 属性可以用通配符 * &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;login&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 配置切入点表达式，并与通知关联 &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* me.iuok.service.impl.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;/aop:config&gt; 完成，根据配置，在执行 login 方法的时候会开启只读事务。 注解配置声明式事务​ @EnableTransactionManagement开启事务支持 @Configuration @ComponentScan(basePackages = &quot;me.iuok&quot;) @PropertySource(&quot;classpath:jdbc.properties&quot;) @EnableTransactionManagement public class AppConfig {} 把数据库连接相关的对象仍到容器里 @Bean public DriverManagerDataSource driverManagerDataSource(@Value(&quot;${jdbc.url}&quot;) String url, @Value(&quot;${jdbc.username}&quot;) String username, @Value(&quot;${jdbc.password}&quot;) String password) { return new DriverManagerDataSource(url, username, password); } @Bean public JdbcTemplate jdbcTemplate(DriverManagerDataSource driverManagerDataSource) { return new JdbcTemplate(driverManagerDataSource); } 把 TransactionManager 也仍到容器里 @Bean(&quot;transactionManager&quot;) public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } @Transactional 在需要使用事务的服务类上标注注解，可以标注在类上，也可以标注在方法上，用于设置类全局规则和针对于方法的自定义规则。 @Service @Transactional public class MockServiceImpl implements MockService { private MockDao mockDao; @Autowired public MockServiceImpl(MockDao mockDao) { this.mockDao = mockDao; } @Transactional(readOnly = true) public Mock login(String username, String password) { List&lt;Mock&gt; mocks = mockDao.findByEmail(username); return mocks.isEmpty() ? null : mocks.get(0); } } 完成，相对于 xml 配置方式来说，注解配置在一定程度上更简单，但是它不支持切入点表达式，所以不能用通配符配置。 说明​ 声明式事务在默认情况下只针对运行时异常回滚，编译时异常不回滚。 事务的传播行为​  事务的隔离级别​ 隔离级别\t脏读\t不可重复读\t幻读READ UNCOMMITTED\t✔️\t✔️\t✔️ READ COMMITTED\t❌\t✔️\t✔️ REPEATABLE READ（MySQL 默认）\t❌\t❌\t✔️ SERIALIZABLE\t❌\t❌\t❌ "},{"title":"与其他组件的整合​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#与其他组件的整合","content":""},{"title":"JUnit4​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#junit4","content":"依赖​ junit ≥ 4.1.2spring-contextspring-test 替换 JUnit 的默认启动类​ 在测试类上标注。 @RunWith(SpringJUnit4ClassRunner.class)  指定 Spring 配置​ 如果是配置文件就指定 locations，如果是配置类就指定 classes。 @ContextConfiguration(classes = Config.class)  这就搭建好 Spring 的测试运行环境了，就可以在测试类中使用 Spring 的注解了。 "},{"title":"Junit5​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#junit5","content":"@ExtendWith(SpringExtension.class) @ContextConfiguration(&quot;classpath:spring/Spring.xml&quot;)  还有一个更简单的写法，集成了上面两个注解。 @SpringJUnitConfig(locations = &quot;classpath:spring/Spring.xml&quot;)  "},{"title":"JdbcTemplate​","type":1,"pageTitle":"Spring","url":"docs/notes/java/spring#jdbctemplate","content":"&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt;  @Configuration @ComponentScan(basePackages = &quot;me.iuok&quot;) @PropertySource(&quot;classpath:jdbc.properties&quot;) public class AppConfig { @Bean public DriverManagerDataSource driverManagerDataSource(@Value(&quot;${jdbc.url}&quot;) String url, @Value(&quot;${jdbc.username}&quot;) String username, @Value(&quot;${jdbc.password}&quot;) String password) { return new DriverManagerDataSource(url, username, password); } @Bean public JdbcTemplate jdbcTemplate(DriverManagerDataSource driverManagerDataSource) { return new JdbcTemplate(driverManagerDataSource); } }  "},{"title":"Spring MVC","type":0,"sectionRef":"#","url":"docs/notes/java/spring-mvc","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#参考资料","content":"Maven Repository: org.springframework » spring-webspring-web 5.2.7.RELEASE javadoc (org.springframework)spring-webmvc 5.2.7.RELEASE javadoc (org.springframework) "},{"title":"快速开始​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#快速开始","content":"创建 Maven 工程，导入依赖 配置web.xml，在 Tomcat 容器开始运行时加载 SpringMVC 的 Servlet。并且使用初始化参数设置 Spring 配置文件的位置。之后再把DispatcherServlet映射到所有请求上，所有请求都经过此 Servlet 处理。如果没有设置配置文件路径，则默认路径为/WEB-INF/springMVC-{servlet-name}.xml，其中servlet-name是在web.xml中配置的&lt;servlet-name&gt;的值。 web.xml &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置 Spring，开启包扫描，开启注解支持，并配置一个视图解析器，注入参数 applicationContext.xml &lt;context:component-scan base-package=&quot;me.iuok&quot;/&gt; &lt;!-- 注解支持--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器--&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 编写 Controller，处理业务逻辑 HelloController.java @Slf4j @Controller public class HelloController { @RequestMapping(&quot;/hello&quot;) public String sayHello() { log.info(&quot;HelloController.sayHello&quot;); return &quot;success&quot;; } } 当访问 /hello 的时候就会显示 /WEB-INF/pages/success.jsp 里的内容了。 "},{"title":"配置文件配置项​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#配置文件配置项","content":"&lt;mvc:default-servlet-handler/&gt;会在web.xml中定义一个DefaultServletHttpRequestHandler，路径是/。用户配置的DispatcherServlet的优先级更高，当收到请求时首先交给用户配置的 Servlet 进行处理，如果处理不了再交给默认的。所以这个 Servlet 能处理静态资源。&lt;mvc:annotation-driven/&gt;开启注解扫描。不然注解不生效。 "},{"title":"注解​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#注解","content":""},{"title":"@RequestMapping​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#requestmapping","content":"可以标注在类上也可以标注在方法上，如果标注在类上则所有的方法上的映射继承类上的映射。 属性名\t说明\t示例value\tpath的别名 path\t用于建立请求 URL 和方法之间的关系。 method\t限制请求方式 params\t限制参数\tusername必须出现参数；!username不能出现此参数；username=who限制参数取值 headers\t限制请求头，和 params 类似\t Ant 风格资源地址匹配： ?匹配任意一个字符；*匹配单层路径；**匹配多层路径。 "},{"title":"@RequestParam​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#requestparam","content":"只能标注在方法参数上，把 request 中的表单参数绑定到方法参数上。用于在自动注入不好使的情况下，方法参数名称可以和表单参数名称不相同。 属性名\t说明value\tname的别名 name\t参数名 required\t是否必须有，默认为 true，不提供就会异常 defaultValue\t默认值 "},{"title":"@RequestBody​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#requestbody","content":"标注在方法参数上，用于获取请求体的内容，比如以 JSON 格式传入数据的时候。GET 方法没有请求体，所以不适用。 "},{"title":"@RequestHeader​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#requestheader","content":"标注在方法参数上，用于绑定 request 中的 header 值。 "},{"title":"@PathVariable​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#pathvariable","content":"标注在方法参数上，用于绑定 @RequestMapping 路径里的变量。 @RequestMapping(&quot;/param/{id}&quot;) public void pathVariable(@PathVariable(&quot;id&quot;) String id) {}  "},{"title":"@CookieValue​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#cookievalue","content":"标注在方法参数上，用于绑定 Cookie 值。 "},{"title":"@ResponseBody​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#responsebody","content":"可以标注在类上和方法上，可以把方法的返回值直接输出到 response。 如果返回值是对象可以自动转为 json 格式输出，需要导入 Jackson 的依赖。 "},{"title":"请求参数绑定​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#请求参数绑定","content":"在控制器方法参数列表里写上参数，MVC 就会自动注入参数。 "},{"title":"原生 Servlet 类型​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#原生-servlet-类型","content":"HttpServletRequestHttpServletResponseHttpSessionjava.security.PrincipalLocaleInputStreamOutputStreamReaderWriter "},{"title":"基本数据类型和 String 类型​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#基本数据类型和-string-类型","content":""},{"title":"实体类型​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#实体类型","content":"HttpEntity&lt;&gt;ResponseEntity&lt;&gt;RequestEntity&lt;&gt; "},{"title":"数据共享​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#数据共享","content":""},{"title":"ModelAndView​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#modelandview","content":"@RequestMapping(&quot;/hello&quot;) public ModelAndView test() { ModelAndView modelAndView = new ModelAndView(); log.info(&quot;test 方法被执行&quot;); modelAndView.addObject(&quot;msg&quot;, &quot;你好&quot;); modelAndView.setViewName(&quot;test&quot;); return modelAndView; }  "},{"title":"Map​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#map","content":"@RequestMapping(&quot;/map&quot;) public String map(Map&lt;String, Object&gt; map) { map.put(&quot;msg&quot;, &quot;hello&quot;); return &quot;test&quot;; }  "},{"title":"Model​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#model","content":"@RequestMapping(&quot;/model&quot;) public String map(String username, String password, Model model) { model.addAttribute(&quot;username&quot;, username); model.addAttribute(&quot;password&quot;, password); return &quot;charset&quot;; }  "},{"title":"ModelMap​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#modelmap","content":"@RequestMapping(&quot;/model&quot;) public String map(String username, String password, ModelMap model) { model.addAttribute(&quot;username&quot;, username); model.addAttribute(&quot;password&quot;, password); return &quot;charset&quot;; }  "},{"title":"转发与重定向​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#转发与重定向","content":"return &quot;forward:/hello&quot;  return &quot;redirect:/index.jsp&quot;;  "},{"title":"视图控制器​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#视图控制器","content":"applicationContext.xml &lt;mvc:annotation-driven /&gt; &lt;!-- 只设置下面这一行的话，通过注解设置的路由都会失效 --&gt; &lt;mvc:view-controller path=&quot;/testView&quot; view-name=&quot;success&quot; /&gt;  "},{"title":"HttpMessageConveter​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#httpmessageconveter","content":" 负责将请求信息转为对象，将对象输出为响应信息。 使用HttpEntity&lt;T&gt;/ResponseEntity&lt;T&gt;作为处理方法的入参或返回值。 "},{"title":"文件下载​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#文件下载","content":"返回值类型ResponseEntity&lt;byte []&gt;。 @RequestMapping(&quot;/testResponseEntity&quot;) public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException { ServletContext servletContext = session.getServletContext(); InputStream resourceAsStream = servletContext.getResourceAsStream(&quot;/files/abc.txt&quot;); byte[] body = new byte[resourceAsStream.available()]; resourceAsStream.read(body); MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=abc.txt&quot;); HttpStatus statusCode = HttpStatus.OK; return new ResponseEntity&lt;byte[]&gt;(body, headers, statusCode); }  "},{"title":"文件上传​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#文件上传","content":"上传表单要求method=&quot;post&quot;，enctype=&quot;multipart/form-data&quot; &lt;form action=&quot;testUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 文件：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;br&gt;&lt;br&gt; 描述：&lt;input type=&quot;text&quot; name=&quot;desc&quot;/&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt; 导入依赖 Maven Repository: commons-fileupload » commons-fileupload 配置multipartResolver，id 必须是这个 applicationContext.xml &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;8888&quot;/&gt; &lt;/bean&gt; 处理 @RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST) public String upload(String desc, MultipartFile file) throws IOException { file.transferTo(Paths.get(&quot;&quot;)); return &quot;test&quot;; } 多文件上传，表单改成多个同名的上传域 @RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST) public String upload(String desc, @RequestParam(&quot;file&quot;) MultipartFile[] files) throws IOException { for (MultipartFile file : files) { file.transferTo(Paths.get(&quot;&quot;)); } return &quot;test&quot;; }  "},{"title":"过滤器​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#过滤器","content":""},{"title":"CharacterEncodingFilter​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#characterencodingfilter","content":"这个过滤器用于设置 request 和 response 的字符编码。必须防止在所有其它过滤器之前。不然在 request 被访问之后再设置就没意义了。 forceEncoding设置为false的时候，如果 request 未设置字符集才会对 request 设置字符集，不会对 response 设置字符集；forceEncoding设置为true的时候，任何时候都会对 request 和 response 设置字符集。 web.xml &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter- class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;  "},{"title":"HiddenHttpMethodFilter​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#hiddenhttpmethodfilter","content":"这个过滤器处理请求参数中的_method字段。有些客户端只能发送 GET 和 POST 请求，不能发送 DELETE 或 PUT 请求，这个字段用于告知 Spring MVC 模拟请求方法。 web.xml &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter- class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;  "},{"title":"拦截器​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#拦截器","content":"类似于 Servlet 中的过滤器，对处理进行预处理和后处理。 新类，实现HandlerIntercepter接口，或者继承HandlerInterceptorAdapter，重写方法； 配置文件； applicationContext.xml &lt;!-- 拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 要拦截的路径--&gt; &lt;mvc:mapping path=&quot;&quot;/&gt; &lt;!-- 不拦截的路径--&gt; &lt;mvc:exclude-mapping path=&quot;&quot;/&gt; &lt;!-- 拦截器 Bean--&gt; &lt;bean class=&quot;&quot; /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;  拦截器的执行顺序。  pre()controllerpost()xxx.jspafterCompletion()  对于多个拦截器的执行顺序。preHandle是顺序执行；postHandle是倒序执行；afterCompletion也是倒序执行。 在执行preHandle时，只要遇到一个返回false，剩下的拦截器都不会执行了，postHandle都不会执行。但是返回false之前的其它拦截器的afterCompletion还是会继续执行。 "},{"title":"异常处理​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#异常处理","content":""},{"title":"HandlerExceptionResolver​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#handlerexceptionresolver","content":"Controller 调用 Service，Service 调用 DAO，异常都是向上抛出的，最终交由 DispatcherServlet 进行处理。 新类，实现 HandlerExceptionResolver；重写方法在配置文件里配置 bean "},{"title":"SimpleMappingExceptionResolver​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#simplemappingexceptionresolver","content":"或者有个更简单的办法，自带的有个SimpleMappingExceptionResolver。可以快捷地将异常与视图名对应，发生异常时自动跳转到对应视图，带上异常信息，key 是exception。可以把所有异常作一个通用处理。 applicationContext.xml &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;!-- properties 的键表示处理器方法执行过程中出现的异常 properties 的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- exceptionAttribute 属性设置一个属性名，将出现的异常信息在请求域中进行共享 --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt; &lt;/bean&gt;  "},{"title":"@ControllerAdvice​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#controlleradvice","content":"ExceptionController.java @ControllerAdvice public class ExceptionController { //@ExceptionHandler 用于设置所标识方法处理的异常 @ExceptionHandler(ArithmeticException.class) //ex 表示当前请求处理中出现的异常对象 public String handleArithmeticException(Exception ex, Model model){ model.addAttribute(&quot;ex&quot;, ex); return &quot;error&quot;; } }  "},{"title":"注解配置 Spring MVC​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#注解配置-spring-mvc","content":"在 Servlet 3.0 环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置 Servlet 容器。Spring 提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring 3.2 引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到 Servlet 3.0 容器的时候，容器会自动发现它，并用它来配置 Servlet 上下文。 "},{"title":"Spring MVC 运行流程​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#spring-mvc-运行流程","content":" "},{"title":"与 Spring 整合​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#与-spring-整合","content":"SpringMVC 与 Spring 整合_Hudie.的博客-CSDN 博客_springmvc+spring 整合Spring 整合 SpringMVC | 码农家园 SpringMVC 与 Spring 整合是为了分工明确。 web.xml &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;  mvc.xml &lt;context:component-scan base-package=&quot;com.gql&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt;  spring.xml &lt;context:component-scan base-package=&quot;com.gql&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt;  两个容器同时存在情况下，Spring 容器作为父容器，SpringMVC 容器作为子容器。 SpringMVC 容器中的 Bean 可以引用 Spring 容器中的 Bean，反过来则不行。 "},{"title":"异步请求​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#异步请求","content":"Servlet 3.0 中的异步请求在 SpringMVC 里也作了支持。有两种方式实现异步请求。 "},{"title":"Callable​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#callable","content":"控制器返回一个Callable对象。 @GetMapping(&quot;/callable&quot;) public Callable&lt;String&gt; callable() { log.info(Thread.currentThread().getName()); return () -&gt; { log.info(Thread.currentThread().getName()); return &quot;你好&quot;; }; }  "},{"title":"DeferredResult​","type":1,"pageTitle":"Spring MVC","url":"docs/notes/java/spring-mvc#deferredresult","content":"控制器返回一个DeferredResult对象，然后在其他线程中等待任务完成的时候调用setResult()方法。 @GetMapping(&quot;/deferredResult&quot;) public DeferredResult&lt;String&gt; deferredResult() { DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;&gt;(); processDeferredResult(deferredResult); log.info(&quot;AsyncController.deferredResult&quot;); log.info(Thread.currentThread().getName()); return deferredResult; } private void processDeferredResult(DeferredResult&lt;String&gt; deferredResult) { new Thread(() -&gt; { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } deferredResult.setResult(&quot;Hello&quot;); log.info(&quot;AsyncController.processDeferredResult&quot;); log.info(Thread.currentThread().getName()); }).start(); }  "},{"title":"Mybaitis","type":0,"sectionRef":"#","url":"docs/notes/java/mybatis","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#参考资料","content":"【尚硅谷】SSM 框架全套教程，MyBatis+Spring+SpringMVC+SSM 整合一套通关_哔哩哔哩_bilibilimybatis – MyBatis 3 | 简介mybatis 3.5.5 javadoc (org.mybatis)MyBatis Generator Core – Introduction to MyBatis Generator "},{"title":"简介​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#简介","content":"Mybaitis 是一个持久层框架，用于简化 JDBC 操作。 "},{"title":"开发步骤​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#开发步骤","content":"导入 Mybatis 依赖； &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; 创建数据库和表； 编写实体类； 编写 XML 映射文件 UserMapper.xml； &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;me.iuok.domain.User&quot;&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 编写 XML 配置文件 SqlMapConfig.xml； &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///blog&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;me/iuok/mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 测试。 @Test public void quickStart() throws IOException { InputStream resource = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resource); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; list = sqlSession.selectList(&quot;userMapper.findAll&quot;); for (User user : list) { log.info(user.toString()); } sqlSession.close(); }  "},{"title":"传统 CRUD 案例​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#传统-crud-案例","content":"每个业务中的使用的 SqlSession 都应该是新获取的，因为每个 SqlSession 里面都有一个独立的事务。 "},{"title":"select​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#select","content":"&lt;select id=&quot;findAll&quot; resultType=&quot;me.iuok.domain.User&quot;&gt; select * from user &lt;/select&gt;  @Test public void selectList() { List&lt;User&gt; list = sqlSession.selectList(&quot;userMapper.findAll&quot;); Assert.assertNotEquals(0, list.size()); for (User user : list) { log.info(user.toString()); } }  "},{"title":"insert​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#insert","content":"&lt;insert id=&quot;save&quot; parameterType=&quot;me.iuok.domain.User&quot;&gt; insert into user (username, password) values (#{username}, #{password}) &lt;/insert&gt;  @Test public void insert() { User user = new User(); user.setUsername(&quot;Mybaitis insert test&quot;); user.setPassword(&quot;no password&quot;); int result = sqlSession.insert(&quot;userMapper.save&quot;, user); sqlSession.commit(); log.info(String.valueOf(result)); Assert.assertEquals(1, result); }  在映射文件中要指定参数类型 parameterType；SQL 语句中使用 #{属性名} 来引用实体中的属性值；sqlSession.insert 的返回值是受影响的行数；涉及数据改动，要手动提交事务 sqlSession.commit()。 "},{"title":"update​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#update","content":"&lt;update id=&quot;update&quot; parameterType=&quot;me.iuok.domain.User&quot;&gt; update user set username = #{username}, password = #{password} where id = #{id} &lt;/update&gt;  @Test public void update() { User user = new User(6, &quot;mybatis update&quot;, &quot;new password&quot;); int rows = sqlSession.update(&quot;userMapper.update&quot;, user); sqlSession.commit(); log.info(String.valueOf(rows)); Assert.assertEquals(1, rows); }  "},{"title":"delete​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#delete","content":"&lt;delete id=&quot;deleteById&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id = #{id} &lt;/delete&gt;  @Test public void delete() { int rows = sqlSession.delete(&quot;userMapper.deleteById&quot;, 7); sqlSession.commit(); log.info(String.valueOf(rows)); }  parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）；只有一个参数并且是基本数据类型时，占位符里面的属性名可以随便写。 "},{"title":"代理 DAO 案例​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#代理-dao-案例","content":"XML 映射文件中的 namespace 应该和接口的全限定类名相同；接口中的方法名应该和映射文件中每一个 SQL 语句的 id 相同；接口中方法的参数应该与 parameterType 相同；接口中方法的返回值应该与 resultType 相同。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;me.iuok.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; select * from user &lt;/select&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; select * from user where id = #{id} &lt;/select&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;user&quot;&gt; insert into user (username, password) values (#{username}, #{password}) &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;user&quot;&gt; update user set username = #{username}, password = #{password} where id = #{id} &lt;/update&gt; &lt;delete id=&quot;deleteById&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #{id} &lt;/delete&gt; &lt;/mapper&gt;  public interface UserMapper { List&lt;User&gt; findAll(); User findById(int id); int save(User user); int update(User user); int deleteById(int id); }  public class UserMapperTest { private static InputStream resource; private static SqlSessionFactory sqlSessionFactory; private static SqlSession sqlSession; private static UserMapper userMapper; @BeforeClass public static void beforeClass() throws Exception { resource = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(resource); } @AfterClass public static void afterClass() throws Exception { resource.close(); } @Before public void setUp() throws Exception { sqlSession = sqlSessionFactory.openSession(); userMapper = sqlSession.getMapper(UserMapper.class); } @After public void tearDown() throws Exception { sqlSession.close(); } @Test public void findAll() { List&lt;User&gt; users = userMapper.findAll(); Assert.assertNotEquals(0, users.size()); for (User user : users) { log.info(user.toString()); } } @Test public void findById() { User user = userMapper.findById(2); Assert.assertNotNull(user); log.info(user.toString()); } }  "},{"title":"Java API​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#java-api","content":""},{"title":"Resources​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#resources","content":"URL getResourceURL(String resource) URL getResourceURL(ClassLoader loader, String resource) InputStream getResourceAsStream(String resource) InputStream getResourceAsStream(ClassLoader loader, String resource) Properties getResourceAsProperties(String resource) Properties getResourceAsProperties(ClassLoader loader, String resource) Reader getResourceAsReader(String resource) Reader getResourceAsReader(ClassLoader loader, String resource) File getResourceAsFile(String resource) File getResourceAsFile(ClassLoader loader, String resource) InputStream getUrlAsStream(String urlString) Reader getUrlAsReader(String urlString) Properties getUrlAsProperties(String urlString) Class classForName(String className)  "},{"title":"SqlSession​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#sqlsession","content":"&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter) &lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter)  "},{"title":"核心配置文件.xml​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#核心配置文件xml","content":"configuration propertiessettingstypeAliasestypeHandlersobjectFactorypluginsenvironments environment transactionManagerdataSource databaseProvidermappers "},{"title":"properties​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#properties","content":"引入外部properties文件中的属性，或者自己在此区域中定义属性，可以在后文中使用${name}引用这些属性。 &lt;properties resource=&quot;jdbc.properties&quot;&gt; &lt;property name=&quot;a&quot; value=&quot;b&quot;/&gt; &lt;/properties&gt;  "},{"title":"settings​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#settings","content":"mapUnderscoreToCamelCase​ 映射字段column_name为属性columnName。 "},{"title":"typeAliases​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#typealiases","content":"定义类型别名，为某个类型设置简短的名字，不需要写全类名了，alias可以省略，默认别名就是类名，不区分大小写。 也可以设置扫描某个包路径，其下的所有类都设置别名，别名就是类名，不区分大小写。 &lt;typeAliases&gt; &lt;typeAlias type=&quot;o.e.entity.TUser&quot; alias=&quot;User&quot;/&gt; &lt;package name=&quot;o.e.entity&quot;/&gt; &lt;/typeAliases&gt;  Mybatis 默认定义了一些常用的类型别名，如_int对应int，int对应Integer。完整的默认别名列表可以参考 mybatis – MyBatis 3 | Configuration。 "},{"title":"typeHandlers​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#typehandlers","content":"新类，继承 BaseTypeHandler&lt;&gt;；实现方法；在配置文件中注册。 "},{"title":"plugins​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#plugins","content":"PageHelper​ 导入依赖； &lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.10&lt;/version&gt; &lt;/dependency&gt; 在配置文件中配置； &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;/&gt; &lt;/plugins&gt; 在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个 MyBatis 查询方法会被进行分页。 @Test public void pageHelper() { PageHelper.startPage(1, 2); List&lt;User&gt; users = userMapper.findAll(); Assert.assertNotEquals(0, users.size()); for (User user : users) { log.info(user.toString()); } } 获取分页相关参数，第二个参数是导航的页数，就是前端显示的时候上一页和下一页按钮中的页的数量，通过getNavigatepageNums()方法可以获取页码数组；这个参数是可选的，默认值是 8。 PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;&gt;(users, 5);  "},{"title":"environments​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#environments","content":"可以配置多个环境，初始化时可以选择某个环境进行初始化。 transactionManager.type，设置事务管理器 JDBC，原生事务管理方式，自己手动提交MANAGEd，被管理的，例如 Spring dataSource.type，设置数据源 POOLED，使用数据库连接池UNPOOLED，不适用数据库连接池JNDI，使用上下文的数据源 &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///ssm&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;  Reader config = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); sqlSessionFactory = builder.build(config, &quot;development&quot;);  "},{"title":"mappers​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#mappers","content":"引入 Mybatsi 映射文件。 使用相对于类路径的资源引用 &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; 使用完全限定资源定位符（URL） &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; 将包内的映射器接口实现全部注册为映射器；要求 XML 文件和接口都在同一个包下，并且文件名也相同。 &lt;package name=&quot;org.mybatis.builder&quot;/&gt;  "},{"title":"映射文件.xml​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#映射文件xml","content":""},{"title":"参数​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#参数","content":"原始类型或简单数据类型（比如 Integer 和 String）因为没有其它属性，会用它们的值来作为参数。这个参数可以随意命名。 默认情况下，使用 #{} 参数语法时，MyBatis 会创建 PreparedStatement 参数占位符，并通过占位符安全地设置参数（就像使用 ? 一样）。 在有直接替换字符串需求的情况下，可以使用${}，该值不会被预编译。使用该方法获取原始类型或简单数据类型参数时需要使用value或_parameter作为参数名，不能随意命名。不然会当做通用对象处理，通过对应的 getter 方法获取属性值。Mybatis 3.5 版本之后使用${}获取字面量变量的时候可以随意命名。 当传入参数为单个原始类型或简单数据类型时，#{}可以随意命名；当传入单个 JavaBean 时，#{}和${}都可以通过属性名获取属性，使用的是 getter 方法；当传入多个参数时，#{}可以使用arg0、arg1或param1、param2这样的命名；${}只能使用param1、param2这样的命名；可以手动传入Map&lt;String, Object&gt;，然后直接通过键名来获取参数值；可以在参数上用@Param注解，手动指定该参数的名字，然后通过此名字获取对应值；当传入的参数类型为 List 时，则它对应的键值就叫list，Array 对应array。 "},{"title":"获取自动生成的主键​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#获取自动生成的主键","content":"设置下面两个属性来获取自动生成的主键，在插入完成之后主键值会自动设置到实体类的对应属性上。 useGeneratedKeyskeyProperty &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert ignore into t_user (username, passcode, age, gender, email) values ( #{username}, #{passcode}, #{age}, #{gender}, #{email} ); &lt;/insert&gt;  "},{"title":"parameterType​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#parametertype","content":"可以不用写，Mybatis 会自动进行类型推断。 "},{"title":"resultType​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#resulttype","content":"期望从这条语句中返回结果的类全限定名或别名。如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 "},{"title":"resultMap​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#resultmap","content":"处理实体类属性和数据库字段的映射关系。 "},{"title":"sql​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#sql","content":"可重用 SQL 语句段，定义后用 include 标签引入。 "},{"title":"接口编写​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#接口编写","content":""},{"title":"方法返回值​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#方法返回值","content":"字面量类型Java BeanList、Map 当查询多条结果放入 Map 时，可以使用 List&lt;Map&lt;String, Object&gt;&gt; 声明返回值类型；或者使用Map&lt;String, Object&gt;并配合@MapKey(&quot;id&quot;)注解。前者是 List 中放 Map，后者是 Map 中放 Map。 "},{"title":"模糊查询​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#模糊查询","content":"使用LIKE '%${param1}%'，有 SQL 注入风险；使用LIKE CONCAT('%', '${param1}', '%')，索引失效；使用LIKE #{param1}，在传递参数的时候自己手动拼接通配符。 "},{"title":"字段和属性映射​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#字段和属性映射","content":"在 SQL 语句中使用as来给字段起别名；配置mapUnderscoreToCamelCase为true；使用resultMap手动声明映射关系。 "},{"title":"延迟加载​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#延迟加载","content":"在处理一对一、一对多关系映射时，可以延迟加载数据。 lazyLoadingEnabled，是否开启延迟加载。aggressiveLazyLoading，是否开启侵略性的延迟加载，如果true则任意方法的调用都会触发延迟加载；如果false则参考lazyLoadTriggerMethods。lazyLoadTriggerMethods，可以控制哪些方法被调用可以触发延迟加载，默认有equals,clone,hashCode,toString。 在配置文件中配置即可全局开机延迟加载。 &lt;settings&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt;  在映射文件中可以通过fetchType属性单独配置某条 SQL 语句是否开启延迟加载。 lazy，延迟加载eager，立即加载 &lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt; &lt;association property=&quot;&quot; select=&quot;&quot; fetchType=&quot;eager&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt;  "},{"title":"动态 SQL​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#动态-sql","content":""},{"title":"if​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#if","content":"&lt;select id=&quot;findByCondition&quot; resultType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;id!=null&quot;&gt; and id = #{id} &lt;/if&gt; &lt;if test=&quot;username!=null&quot;&gt; and username = #{username} &lt;/if&gt; &lt;if test=&quot;password!=null&quot;&gt; and password = #{password} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;  @Test public void findByCondition() { User condition = new User(); condition.setUsername(&quot;Roddy&quot;); condition.setPassword(&quot;Whoever&quot;); List&lt;User&gt; users = userMapper.findByCondition(condition); Assert.assertNotEquals(0, users.size()); for (User user : users) { log.info(user.toString()); } }  如果属性值为 null，if 分支不生效；如果传入的 User 为 null，所有分支都不生效，就会查询所有。 "},{"title":"where​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#where","content":"根据条件判断是否加where，并且去掉多余的and或者or。 "},{"title":"set​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#set","content":"&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt; &lt;/set&gt; where id=#{id} &lt;/update&gt;  set元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 "},{"title":"trim​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#trim","content":"&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ... &lt;/trim&gt; &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; ... &lt;/trim&gt;  prefixOverrides属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有prefixOverrides属性中指定的内容，并且插入 prefix 属性中指定的内容。 "},{"title":"choose​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#choose","content":"&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt;  "},{"title":"foreach​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#foreach","content":"&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; open=&quot;id in (&quot; close=&quot;)&quot; separator=&quot;, &quot;&gt; #{id} &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt;  @Test public void findByIds() { List&lt;User&gt; users = userMapper.findByIds(Arrays.asList(2, 3)); Assert.assertNotEquals(0, users.size()); for (User user : users) { log.info(user.toString()); } }  "},{"title":"多表操作​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#多表操作","content":""},{"title":"一对一 XML 查询​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#一对一-xml-查询","content":"public class Article { private Integer id; private String content; private Date createdAt; private Date updatedAt; private User user; }  &lt;sql id=&quot;selectArticle&quot;&gt; select *, a.id as aid, u.id as uid from article as a join user as u on a.user_id = u.id &lt;/sql&gt; &lt;resultMap id=&quot;articleMap&quot; type=&quot;article&quot;&gt; &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;content&quot; property=&quot;content&quot;/&gt; &lt;result column=&quot;created_at&quot; property=&quot;createdAt&quot;/&gt; &lt;result column=&quot;updated_at&quot; property=&quot;updatedAt&quot;/&gt; &lt;!-- &lt;result column=&quot;uid&quot; property=&quot;user.id&quot;/&gt;--&gt; &lt;!-- &lt;result column=&quot;username&quot; property=&quot;user.username&quot;/&gt;--&gt; &lt;!-- &lt;result column=&quot;password&quot; property=&quot;user.password&quot;/&gt;--&gt; &lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;articleMap&quot;&gt; &lt;include refid=&quot;selectArticle&quot;/&gt; &lt;/select&gt;  "},{"title":"一对多 XML 查询​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#一对多-xml-查询","content":"public class User { private Integer id; private String username; private String password; private List&lt;Article&gt; articles; }  &lt;sql id=&quot;selectUser&quot;&gt; select *, u.id uid, a.id aid from user u left join article a on u.id = a.user_id &lt;/sql&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt; &lt;collection property=&quot;articles&quot; ofType=&quot;article&quot;&gt; &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;content&quot; property=&quot;content&quot;/&gt; &lt;result column=&quot;created_at&quot; property=&quot;createdAt&quot;/&gt; &lt;result column=&quot;updated_at&quot; property=&quot;updatedAt&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;/select&gt;  "},{"title":"分步查询​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#分步查询","content":"&lt;resultMap id=&quot;articleMap&quot; type=&quot;article&quot;&gt; &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;content&quot; property=&quot;content&quot;/&gt; &lt;result column=&quot;created_at&quot; property=&quot;createdAt&quot;/&gt; &lt;result column=&quot;updated_at&quot; property=&quot;updatedAt&quot;/&gt; &lt;association property=&quot;user&quot; select=&quot;me.iuok.UserMapper.selectUserById&quot; column=&quot;user_id&quot;/&gt; &lt;/resultMap&gt;  如果在全局配置文件中设置了lazyLoadingEnabled就可以开启关联对象的懒加载。 "},{"title":"缓存​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#缓存","content":""},{"title":"一级缓存​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#一级缓存","content":"一级缓存默认开启不同的SqlSession有不同缓存同一个SqlSession查询条件不同同一个SqlSession两次查询期间执行了增删改操作sqlSession.clearCache()手动清空缓存 "},{"title":"二级缓存​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#二级缓存","content":"二级缓存是SqlSessionFactory级别的要求 POJO 实现Serializable接口二级缓存在SqlSession关闭或提交后才会生效在映射文件中使用&lt;cache /&gt;配置映射文件中的所有 select 语句的结果将会被缓存映射文件中的所有 insert、update 和 delete 语句会刷新所有缓存，包括一级缓存和二级缓存 &lt;cache /&gt;  &lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;  eviction，淘汰策略，默认是LRU；flushInterval，刷新间隔，单位是毫秒，默认不自动刷新，只在执行增删改语句的时候刷新；size，缓存引用数目，默认是 1024；readOnly，true则在从缓存中获取对象的时候返回同一个对象的引用，false则每次都返回一个缓存对象的深拷贝。默认值是false。 "},{"title":"缓存查询顺序​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#缓存查询顺序","content":"先查询二级缓存如果二级缓存中没有，则查询一级缓存 "},{"title":"自定义缓存实现​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#自定义缓存实现","content":"可以通过实现org.apache.ibatis.cache.Cache接口来自定义二级缓存实现。 &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;  "},{"title":"注解开发​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#注解开发","content":""},{"title":"基本查询​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#基本查询","content":"public interface UserMapper { @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); @Select(&quot;select * from user where id = #{id}&quot;) User findById(int id); @Insert(&quot;insert into user (username, password) values (#{username}, #{password})&quot;) int save(User user); @Update(&quot;update user set username = #{username}, password = #{password} where id = #{id}&quot;) int update(User user); @Delete(&quot;delete from user where id = #{id}&quot;) int deleteById(int id); }  "},{"title":"复杂查询​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#复杂查询","content":"一对一注解查询​ public interface ArticleMapper { @Select(&quot;select *, a.id as aid, u.id as uid from article as a join user as u on a.user_id = u.id&quot;) @Results({ @Result(column = &quot;aid&quot;, property = &quot;id&quot;), @Result(column = &quot;content&quot;, property = &quot;content&quot;), @Result(column = &quot;created_at&quot;, property = &quot;createdAt&quot;), @Result(column = &quot;updated_at&quot;, property = &quot;updatedAt&quot;), @Result(column = &quot;uid&quot;, property = &quot;user.id&quot;), @Result(column = &quot;username&quot;, property = &quot;user.username&quot;), @Result(column = &quot;password&quot;, property = &quot;user.password&quot;) }) List&lt;Article&gt; findAll(); @Select(&quot;select * from article&quot;) @Results({ @Result(column = &quot;aid&quot;, property = &quot;id&quot;), @Result(column = &quot;content&quot;, property = &quot;content&quot;), @Result(column = &quot;created_at&quot;, property = &quot;createdAt&quot;), @Result(column = &quot;updated_at&quot;, property = &quot;updatedAt&quot;), @Result(column = &quot;user_id&quot;, property = &quot;user&quot;, javaType = User.class, one = @One(select = &quot;me.iuok.mapper.UserMapper.findById&quot;)) }) List&lt;Article&gt; findAll2(); }  一对多注解查询​ public interface ArticleMapper { @Select(&quot;select * from article where user_id = #{id}&quot;) List&lt;Article&gt; findByUserId(int id); }  public interface UserMapper { @Select(&quot;select * from user&quot;) @Results({ @Result(column = &quot;id&quot;, property = &quot;id&quot;, id = true), @Result(column = &quot;username&quot;, property = &quot;username&quot;), @Result(column = &quot;password&quot;, property = &quot;password&quot;), @Result(column = &quot;id&quot;, property = &quot;articles&quot;, javaType = List.class, many = @Many(select = &quot;me.iuok.mapper.ArticleMapper.findByUserId&quot;) ) }) List&lt;User&gt; findAll(); }  "},{"title":"MyBatis Generator​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#mybatis-generator","content":"根据数据表结构自动生成实体类、接口和 Mapper 文件。 pom.xml文件中加入mybatis-generator-maven-plugin插件。 配置文件命名为generatorConfig.xml，放入资源文件夹。之后执行 Maven 插件的命令即可。  &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.29&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;  "},{"title":"MyBatis3Simple​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#mybatis3simple","content":"这个方案生成的 Mapper 中只有简单的增删改查功能。 &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;context id=&quot;simple&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///ssm&quot; userId=&quot;root&quot; password=&quot;root&quot;/&gt; &lt;javaModelGenerator targetPackage=&quot;o.e.model&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;sqlMapGenerator targetPackage=&quot;o.e.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;o.e.mapper&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;table tableName=&quot;t_user&quot;/&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt;  "},{"title":"MyBatis3​","type":1,"pageTitle":"Mybaitis","url":"docs/notes/java/mybatis#mybatis3","content":"这个方案生成的 Mapper 更复杂，除了实体类之外，还会生成 Example 类，可以完成几乎所有的单表操作。 配置内容除了targetRuntime不一样之外，其它内容没变化。 &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;context id=&quot;simple&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///ssm&quot; userId=&quot;root&quot; password=&quot;root&quot;/&gt; &lt;/generatorConfiguration&gt;  "},{"title":"Thymeleaf","type":0,"sectionRef":"#","url":"docs/notes/java/thymeleaf","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"Thymeleaf","url":"docs/notes/java/thymeleaf#参考资料","content":"Thymeleaf30-尚硅谷-servlet-thymeleaf 快速入门_哔哩哔哩_bilibili第八章 Thymeleaf | 代码重工 "},{"title":"Thymeleaf 简介​","type":1,"pageTitle":"Thymeleaf","url":"docs/notes/java/thymeleaf#thymeleaf-简介","content":"Thymeleaf 是服务端模板技术，可用于替换 JSP。 "},{"title":"配置 Thymeleaf​","type":1,"pageTitle":"Thymeleaf","url":"docs/notes/java/thymeleaf#配置-thymeleaf","content":"@WebServlet(name = &quot;EmployeeViewServlet&quot;, value = &quot;/employee.html&quot;, loadOnStartup = 0) public class EmployeeViewServlet extends HttpServlet { private TemplateEngine templateEngine; @Override public void init() throws ServletException { ServletContextTemplateResolver resolver = new ServletContextTemplateResolver(getServletContext()); resolver.setPrefix(&quot;/WEB-INF/view/&quot;); resolver.setSuffix(&quot;.html&quot;); templateEngine = new TemplateEngine(); templateEngine.setTemplateResolver(resolver); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { try { List&lt;Employee&gt; list = GenericQuery.getList(Employee.class, &quot;select * from employees&quot;); req.setAttribute(&quot;employees&quot;, list); } catch (SQLException e) { e.printStackTrace(); req.setAttribute(&quot;err&quot;, e.getMessage()); } templateEngine.process(&quot;employee&quot;, new WebContext(req, resp, getServletContext()), resp.getWriter()); } }  "},{"title":"约束​","type":1,"pageTitle":"Thymeleaf","url":"docs/notes/java/thymeleaf#约束","content":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;  "},{"title":"正则表达式","type":0,"sectionRef":"#","url":"docs/notes/regular-expression","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"正则表达式","url":"docs/notes/regular-expression#参考资料","content":"正则表达式 - 维基百科，自由的百科全书正则表达式速查表 - imlonghao正则表达式 30 分钟入门教程 "},{"title":"在线工具​","type":1,"pageTitle":"正则表达式","url":"docs/notes/regular-expression#在线工具","content":"RegExr: Learn, Build, &amp; Test RegExregex101: build, test, and debug regexRegulex：JavaScript Regular Expression VisualizerRegexper "},{"title":"RocketMQ","type":0,"sectionRef":"#","url":"docs/notes/message-queuing/rocketmq","content":"","keywords":""},{"title":"参考资料​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#参考资料","content":"2021 年 B 站讲的最牛掰的 RocketMQ 分布式消息中间件：核心原理与最佳实践_哔哩哔哩_bilibiliApache RocketMQrocketmq/docs/cn at master · apache/rocketmqrocketmq-externals/rocketmq-console at master · apache/rocketmq-externals基于 Docker 安装 RocketMQ - 简书rocketmq-docker/docker-compose.yml at master · apache/rocketmq-docker用户手册 · apache/rocketmq-spring Wiki "},{"title":"MQ​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#mq","content":"MQ（Message Queue，消息队列），是一种 FIFO 的队列。 它的作用有： 异步解耦削峰 "},{"title":"RocketMQ 介绍​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#rocketmq-介绍","content":"RcoketMQ 是一款低延迟、高可靠、可伸缩、易于使用的消息中间件。 "},{"title":"NameServer​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#nameserver","content":"注册中心，可以集群。 "},{"title":"Broker​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#broker","content":"真正负责消息收发和存储的实体，可以主从。 "},{"title":"单机部署​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#单机部署","content":"可以使用 Docker Compose 来快速部署 RocketMQ。 RockerMQ 分为 NameServer1 和 Broker2，前者类似于注册中心，后者才是进行存储消息的服务。还有一个第三方服务rocket-mq-console-ng34，是 RocketMQ 的网页控制台。 RocketMQ 的 NameServer 和 Broker 是同一套代码，只是启动的时候参数不一样。apacherocketmq/rocketmq-nameserver和 apacherocketmq/rocketmq-broker在启动参数上有不同。 RocketMQ 的数据存储在user.home目录下，你可以设置user.home环境变量来自定义存储路径。在这两个 Docker 镜像中，该环境变量的值为/opt。 version: &quot;3&quot; services: nameserver: image: apacherocketmq/rocketmq-nameserver:4.5.0-alpine volumes: - nameserver_logs:/root/logs ports: - 9876:9876 environment: JAVA_OPT_EXT: &quot; -Xms128m -Xmx128m -Xmn128m&quot; command: sh mqnamesrv broker: image: apacherocketmq/rocketmq-broker:4.5.0-alpine depends_on: - nameserver volumes: - broker_data:/root/store - broker_logs:/root/logs - /root/docker-compose/rocketmq/broker.conf:/home/rocketmq/broker.conf ports: - 10909:10909 - 10911:10911 - 10912:10912 environment: JAVA_OPT_EXT: &quot; -Xms128m -Xmx128m -Xmn128m&quot; command: sh mqbroker -c /home/rocketmq/broker.conf console: image: apacherocketmq/rocketmq-console:2.0.0 depends_on: - nameserver - broker ports: - 8088:8080 environment: LOGGIN_LEVEL_ROOT: info ROCKETMQ_CONFIG_NAMESRVADDR: nameserver:9876 JAVA_OPTS: &quot; -Xms128m -Xmx128m -Xmn128m&quot; volumes: nameserver_logs: broker_data: broker_logs:  根据上面的文件中的配置内容，你还需要为 Broker 提供配置文件，位于/root/docker-compose/rocketmq/broker.conf。 需要配置 Broker 的外部 IP，不然客户端连接不上。 brokerClusterName = DefaultCluster brokerName = broker-a brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH namesrvAddr=nameserver:9876 brokerIP1=192.168.229.129 defaultTopicQueueNums=4 autoCreateTopicEnable=true autoCreateSubscriptionGroup=true  接着使用docker compose up -d就可以启动容器了，容器名字都会加上当前文件夹名作为前缀。 可以使用docker compose ps查看容器的运行状态。 "},{"title":"集群部署​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#集群部署","content":"// TODO 还没学，学了再写 "},{"title":"开发​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#开发","content":"首先为了使用方便，定义了一些常量。 public class MQConstant { public static final String NAMESERVER_ADDR = &quot;192.168.229.129:9876&quot;; }  "},{"title":"原生 API​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#原生-api","content":"消费者（推送）​ package example.sync; @Slf4j public class Consumer { public static final String CONSUMER_GROUP = &quot;sync_message_consumer&quot;; public static void main(String[] args) throws Exception { DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP); consumer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET); consumer.subscribe(MQTopicConstant.PRACTISE, MQTagConstant.PRACTISE); consumer.registerMessageListener((MessageListenerOrderly) (msgs, context) -&gt; { msgs.forEach(messageExt -&gt; { log.info(&quot;收到消息：{}&quot;, messageExt); log.info(&quot;消息体：{}&quot;, new String(messageExt.getBody())); }); return ConsumeOrderlyStatus.SUCCESS; }); consumer.start(); log.info(&quot;Consumer 已启动&quot;); Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; { log.info(&quot;程序正在退出&quot;); consumer.shutdown(); })); } }  生产者（同步发送）​ package example.sync; @Slf4j public class Producer { public static final String PRODUCER_GROUP = &quot;sync_message_producer&quot;; public static void main(String[] args) throws Exception { DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP); producer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); producer.start(); Stream.generate(RandomUtil::randomInt) .limit(10) .map(i -&gt; new Message(MQTopicConstant.PRACTISE, MQTagConstant.PRACTISE, StrUtil.format(&quot;Hello RocketMQ: {}&quot;, i).getBytes(StandardCharsets.UTF_8))) .forEach(message -&gt; { try { SendResult result = producer.send(message, 10000); log.info(&quot;消息已发送：{}&quot;, result); } catch (Exception e) { log.error(&quot;消息发送失败&quot;, e); } }); producer.shutdown(); } }  生产者（异步发送）​ package example.producer; @Slf4j public class AsyncMessageProducer { public static final String PRODUCER_GROUP = &quot;async_message_producer&quot;; public static void main(String[] args) throws Exception { final int count = 10; DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP); producer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); producer.start(); CountDownLatch countDownLatch = new CountDownLatch(count); Stream.generate(RandomUtil::randomInt) .limit(count) .map(i -&gt; new Message(MQTopicConstant.PRACTISE, MQTagConstant.PRACTISE, StrUtil.format(&quot;Hello RocketMQ: {}&quot;, i).getBytes(StandardCharsets.UTF_8))) .forEach(message -&gt; { try { producer.send(message, new SendCallback() { @Override public void onSuccess(SendResult sendResult) { log.info(&quot;消息发送成功：{}&quot;, sendResult); countDownLatch.countDown(); } @Override public void onException(Throwable e) { log.error(&quot;消息发送失败&quot;, e); countDownLatch.countDown(); } }); log.info(&quot;消息已发送：{}&quot;, message); } catch (Exception e) { log.error(&quot;消息发送失败&quot;, e); } }); countDownLatch.await(); producer.shutdown(); } }  生产者（单向发送）​ // org.apache.rocketmq.client.producer.DefaultMQProducer#sendOneway public void sendOneway(Message msg)  消费者（拉取）​ 主动拉取可以更灵活地消费消息。 // TODO 还需要明白主动拉取后的消费确认机制 package example.consumer; @Slf4j public class PullConsumer { public static final String CONSUMER_GROUP = &quot;pull_message_consumer&quot;; public static void main(String[] args) throws Exception { DefaultLitePullConsumer consumer = new DefaultLitePullConsumer(CONSUMER_GROUP); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET); consumer.setNamesrvAddr(MQConstant.NAMESERVER_ADDR); consumer.subscribe(MQTopicConstant.PRACTISE, MQTagConstant.ALL); consumer.start(); while (true) { List&lt;MessageExt&gt; messages = consumer.poll(); if (CollUtil.isEmpty(messages)) { break; } messages.forEach(messageExt -&gt; log.info(&quot;收到消息：{}&quot;, messageExt)); } Runtime.getRuntime().addShutdownHook(new Thread(consumer::shutdown)); } }  顺序消费​ 顺序消费要做到需要顺序消费的一组消息都发送到同一个队列上。消费者在消费的时候使用串行消费而不是并发消费。 // org.apache.rocketmq.client.producer.DefaultMQProducer#send public SendResult send(Message msg, MessageQueueSelector selector, Object arg)  MessageQueueSelector可以选择发送消息到哪个队列上。 在实际使用中，可以动态地选择队列来实现负载均衡，只要保证需要顺序消费的同一组消息发送到同一个队列上即可。 SendResult sendResult = producer.send(message, (mqs, msg, arg) -&gt; { int i = (Integer) arg % mqs.size(); return mqs.get(i); }, pair.getKey());  广播消息​ 默认情况下，同一个消费者组在消费消息时有竞争关系。在消费消息的时候设置消费者为广播模式就可以让消费者去掉竞争属性。 // org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#setMessageModel public void setMessageModel(MessageModel messageModel)  MessageModel默认为CLUSTERING，需要设置为BROADCASTING。 consumer.setMessageModel(MessageModel.BROADCASTING);  延迟消息​ // org.apache.rocketmq.common.message.Message#setDelayTimeLevel public void setDelayTimeLevel(int level)  可以给Message设置delayLevel，延迟级别分别为1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h，从 1 开始数。 批量消息​ // org.apache.rocketmq.client.producer.DefaultMQProducer#send public SendResult send(Collection&lt;Message&gt; msgs)  可以简单地把消息封装为Collection&lt;Message&gt;，一起发出去。 过滤消息​ 大多数情况下，可以通过 Topic 和 Tag 来过滤消息。 Tag 可以用表达式写。 consumer.subscribe(MQTopicConstant.PRACTISE, MessageSelector.byTag(&quot;TAG&quot;));  在复杂情况下，还可以通过 SQL 语句来过滤消息。  其中变量a可以在发送消息的时候通过putUserProperty()放入。 // org.apache.rocketmq.common.message.Message#putUserProperty public void putUserProperty(final String name, final String value)  只有推送模式的 Consumer 可以使用消息过滤。 事务消息​  事务消息的机制是在发送消息时会发送一个办消息，这个消息存放在系统创建的 Topic 中，对消费者是不可见的。在生产者对消息进行提交之后才会把消息转移到目标 Topic。如果生产者没有对消息进行提交，RocketMQ 会每隔一段时间进行回查，确认本地事务是否已提交成功，如果是则把消息转移到目标 Topic，否则若超过最大回查尝试次数则丢弃消息，默认最大重试次数为 15。 "},{"title":"Spring Boot​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#spring-boot","content":"配置​ 配置解耦，写在配置文件中。 rocketmq.name-server=192.168.229.129:9876 rocketmq.producer.group=spring-boot-producer-group  生产者（同步发送）​ 核心是RocketMQTemplate，消息的发送都依赖它完成。RocketMQTemplate已经在 Spring 容器中，可以自动注入拿到。其中destination的格式为${topic}:${tag}。 // org.springframework.messaging.core.AbstractMessageSendingTemplate#send public void send(D destination, Message&lt;?&gt; message)  发送消息用send()，参数中的Message实际上是org.springframework.messaging.Message，而不是org.apache.rocketmq.common.message.Message。 Message可以用MessageBuilder构建。 MessageBuilder.withPayload(payload).build();  生产者（异步发送）​ // org.apache.rocketmq.spring.core.RocketMQTemplate#asyncSend public void asyncSend(String destination, Message&lt;?&gt; message, SendCallback sendCallback)  生产者（单向发送）​ // org.apache.rocketmq.spring.core.RocketMQTemplate#sendOneWay public void sendOneWay(String destination, Message&lt;?&gt; message)  消费者（推送）​ 消息的消费有了新的抽象。只需实现RocketMQListener接口就可以快速完成消息消费。设计原则是一个接口消费一种消息，如果需要消费其他消息则需要多个接口。 package com.example.rocketmqinspringboot.listener; @Slf4j @Service @RocketMQMessageListener(consumerGroup = MQConstant.CONSUMER_GROUP, topic = MQTopicConstant.PRACTISE, selectorExpression = MQTagConstant.PRACTISE) public class Consumer implements RocketMQListener&lt;String&gt; { @Override public void onMessage(String message) { log.info(&quot;收到消息：{}&quot;, message); } }  上面的例子会直接拿到消息中的 Payload 并且将之转为泛型对应类型的对象。如果你需要拿到消息的头部信息，把泛型设置为MessageExt，其中可以拿到头部信息 5。 顺序消费​ // org.apache.rocketmq.spring.core.RocketMQTemplate#sendAndReceive public &lt;T&gt; T sendAndReceive(String destination, Message&lt;?&gt; message, Type type, String hashKey)  生产者同一组消息指定相同的hashKey，则该组消息会被发送到同一个消息队列上。 // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#consumeMode ConsumeMode consumeMode() default ConsumeMode.CONCURRENTLY;  消费者把consumeMode设置为ORDERLY。 广播消息​ // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#messageModel MessageModel messageModel() default MessageModel.CLUSTERING;  过滤消息​ // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#selectorType SelectorType selectorType() default SelectorType.TAG; // org.apache.rocketmq.spring.annotation.RocketMQMessageListener#selectorExpression String selectorExpression() default &quot;*&quot;;  事务消息​ // org.apache.rocketmq.spring.core.RocketMQTemplate#sendMessageInTransaction public TransactionSendResult sendMessageInTransaction(final String destination, final Message&lt;?&gt; message, final Object arg)  发送事务消息依赖sendMessageInTransaction完成。arg作为自定义参数会被传递到RocketMQLocalTransactionListener#executeLocalTransaction中，本地事务逻辑会在该方法中完成。 package com.example.rocketmqinspringboot.controller; @Operation(summary = &quot;发事务消息&quot;) @PostMapping(&quot;/transaction&quot;) public void sendTransactionMessage(@RequestBody String message) { TransactionSendResult transactionSendResult = rocketMQTemplate.sendMessageInTransaction(getDestination(), getMessage(message), message); log.info(&quot;transactionSendResult: {}&quot;, transactionSendResult); }  package com.example.rocketmqinspringboot.listener; @Slf4j @RocketMQTransactionListener public class TransactionListener implements RocketMQLocalTransactionListener { @Override public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) { String orderNumber = new String((byte[]) msg.getPayload()); log.info(&quot;执行事务，{}&quot;, orderNumber); return RocketMQLocalTransactionState.UNKNOWN; } @Override public RocketMQLocalTransactionState checkLocalTransaction(Message msg) { String orderNumber = new String((byte[]) msg.getPayload()); log.info(&quot;回查，{}&quot;, orderNumber); return RocketMQLocalTransactionState.COMMIT; } }  发送事务消息时，一个RocketMQTemplate对应一个RocketMQLocalTransactionListener，该RocketMQTemplate所发出的事务消息都会在对应的RocketMQLocalTransactionListener中执行。 如果需要定义多个事务消息监听器，就需要多个RocketMQListener，对应多个RocketMQLocalTransactionListener。 package com.example.rocketmqinspringboot.config; @ExtRocketMQTemplateConfiguration public class ExtRocketMQTemplate extends RocketMQTemplate { }  package com.example.rocketmqinspringboot.listener; @RocketMQTransactionListener(rocketMQTemplateBeanName = &quot;extRocketMQTemplate&quot;) public class ExtTransactionListener implements RocketMQLocalTransactionListener { @Override public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) { return RocketMQLocalTransactionState.UNKNOWN; } @Override public RocketMQLocalTransactionState checkLocalTransaction(Message msg) { return RocketMQLocalTransactionState.COMMIT; } }  "},{"title":"Spring Cloud Stream​","type":1,"pageTitle":"RocketMQ","url":"docs/notes/message-queuing/rocketmq#spring-cloud-stream","content":"Spring Cloud Stream 是 Spring 官方提供的一个针对所有开源的消息系统进行统一封装。 配置​ package com.example.rocketmqspringcloudstream; @EnableBinding({Source.class, Sink.class}) @SpringBootApplication public class RocketmqSpringCloudStreamApplication { public static void main(String[] args) { SpringApplication.run(RocketmqSpringCloudStreamApplication.class, args); } }  Source和Sink是 Spring Cloud Stream 提供的简单的消息输入和输出通道。 spring.cloud.stream.bindings.input.destination=STREAM_TOPIC spring.cloud.stream.bindings.input.group=STREAM_GROUP spring.cloud.stream.bindings.output.destination=STREAM_TOPIC spring.cloud.stream.rocketmq.binder.name-server=192.168.229.129:9876  Spring Cloud Stream 关于消息生产和消费的配置都放在配置文件中。 spring.cloud.stream.bindings是一个Map，可以配置多个通道，input就是Sink的通道名，output就是Source的通道名。 如果需要定义其他通道就新增配置文件，然后新增类似于Sink和Sourec的接口。 生产者​ package com.example.rocketmqspringcloudstream.controller; @Tag(name = &quot;消息&quot;) @Slf4j @RestController @RequestMapping(&quot;/messages&quot;) public class MessageController { @Autowired private Source source; @Operation(summary = &quot;发同步消息&quot;) @PostMapping(&quot;/sync&quot;) public void sendSync(@RequestBody String message) { Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;(); headers.put(MessageConst.PROPERTY_TAGS, MQTagConstant.PRACTISE); Message&lt;String&gt; msg = MessageBuilder.createMessage(message, new MessageHeaders(headers)); boolean success = source.output().send(msg); log.info(&quot;success: {}&quot;, success); } }  消费者​ package com.example.rocketmqspringcloudstream.consumer; @Slf4j @Service public class Consumer { @StreamListener(Sink.INPUT) public void consume(String message) { log.info(&quot;收到消息：{}&quot;, message); } }  apacherocketmq/rocketmq-nameserver - Docker Image | Docker Hub↩apacherocketmq/rocketmq-broker - Docker Image | Docker Hub↩apacherocketmq/rocketmq-console - Docker Image | Docker Hub↩rocketmq-externals/rocketmq-console at master · apache/rocketmq-externals↩常见问题 · apache/rocketmq-spring Wiki↩ "}]